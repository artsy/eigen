directive @optionalField on FIELD

directive @principalField on FIELD

type ARImage {
  height: Int
  imageURLs: ImageURLs
  internalID: ID!
  width: Int
}

input ARImageInput {
  internalID: ID!
}

# Autogenerated input type of AcceptPartnerAgreement
input AcceptPartnerAgreementInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  partnerAgreementID: String!
}

# Autogenerated return type of AcceptPartnerAgreement
type AcceptPartnerAgreementPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  partnerAgreementOrErrors: PartnerAgreementOrErrorsUnion!
}

type AccountMutationFailure {
  mutationError: GravityMutationError
}

type AccountMutationSuccess {
  success: Boolean
}

union AccountMutationType = AccountMutationFailure | AccountMutationSuccess

type AccountRequest {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  notes: String
}

# Autogenerated input type of AddAssetToConsignmentSubmission
input AddAssetToConsignmentSubmissionInput {
  assetType: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  externalSubmissionId: ID
  filename: String
  geminiToken: String
  sessionID: String
  size: String
  source: UploadSource
  submissionID: ID
}

# Autogenerated return type of AddAssetToConsignmentSubmission
type AddAssetToConsignmentSubmissionPayload {
  asset: ConsignmentSubmissionCategoryAsset

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddAssetsToConsignmentSubmission
input AddAssetsToConsignmentSubmissionInput {
  assetType: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  externalSubmissionId: ID
  filename: String
  geminiTokens: [String!]
  sessionID: String
  size: String
  sources: UploadSources
  submissionID: ID
}

# Autogenerated return type of AddAssetsToConsignmentSubmission
type AddAssetsToConsignmentSubmissionPayload {
  assets: [ConsignmentSubmissionCategoryAsset!]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddUserToSubmissionMutation
input AddUserToSubmissionMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of AddUserToSubmissionMutation
type AddUserToSubmissionMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consignmentSubmission: ConsignmentSubmission
}

type Admin {
  featureFlag(id: String): FeatureFlag

  # A list of feature flags
  featureFlags(
    # The sort order of the results
    sortBy: FeatureFlagsSortBy = NAME
  ): [FeatureFlag]
}

input AdminCreateFeatureFlagInput {
  clientMutationId: String
  description: String = ""
  impressionData: Boolean = false
  name: String
  strategy: FeatureFlagStrategyInput!
  type: FeatureFlagToggleType!
  variants: [FeatureFlagVariantInputName]
}

type AdminCreateFeatureFlagPayload {
  clientMutationId: String

  # A list of feature flags
  featureFlags(
    # The sort order of the results
    sortBy: FeatureFlagsSortBy = NAME
  ): [FeatureFlag]
}

input AdminDeleteFeatureFlagInput {
  clientMutationId: String
  name: String
}

type AdminDeleteFeatureFlagPayload {
  clientMutationId: String

  # A list of feature flags
  featureFlags(
    # The sort order of the results
    sortBy: FeatureFlagsSortBy = NAME
  ): [FeatureFlag]
  success: Boolean
}

enum AdminToggleFeatureFlagEnvironment {
  DEVELOPMENT
  PRODUCTION
}

input AdminToggleFeatureFlagInput {
  clientMutationId: String
  enabled: Boolean!
  environment: AdminToggleFeatureFlagEnvironment!
  name: String!
}

type AdminToggleFeatureFlagPayload {
  clientMutationId: String

  # A list of feature flags
  featureFlags(
    # The sort order of the results
    sortBy: FeatureFlagsSortBy = NAME
  ): [FeatureFlag]
  success: Boolean
}

input AdminUpdateFeatureFlagInput {
  clientMutationId: String
  description: String
  impressionData: Boolean = false
  name: String!
  type: String = "release"
}

type AdminUpdateFeatureFlagPayload {
  clientMutationId: String

  # A list of feature flags
  featureFlags(
    # The sort order of the results
    sortBy: FeatureFlagsSortBy = NAME
  ): [FeatureFlag]
}

# One item in an aggregation
type AggregationCount {
  count: Int!
  name: String!
  value: String!
}

# A legal agreement requiring partner consent
type Agreement {
  # Agreement content in markdown format
  content: String

  # When the agreement was created
  createdAt: ISO8601DateTime!

  # When the agreement was deactivated in favor of a newer one
  deactivatedAt: ISO8601DateTime

  # Description of this agreement
  description: String

  # Unique ID for this agreement
  id: ID!

  # Name of this agreement
  name: String!

  # When the agreement was last updated
  updatedAt: ISO8601DateTime!
}

type Alert {
  acquireable: Boolean
  additionalGeneIDs: [String]
  additionalGeneNames: [String]
  artistIDs: [String]
  artistSeriesIDs: [String]
  artistSeriesNames: [String]
  artists: [Artist!]!
  artistsConnection(after: String, before: String, first: Int, last: Int): ArtistConnection!

  # Artworks Elastic Search results
  artworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  atAuction: Boolean
  attributionClass: [String]
  colors: [String]
  dimensionRange: String

  # A suggestion for a name that describes a set of saved search criteria in a conventional format
  displayName(
    # An array of fields to exclude from the display name.
    except: [SearchCriteriaFields]

    # An array of fields to include in the display name.
    only: [SearchCriteriaFields]
  ): String!
  forSale: Boolean
  formattedPriceRange: String
  hasRecentlyEnabledUserSearchCriteria: Boolean
  height: String
  href: String

  # A globally unique ID.
  id: ID!
  inquireableOnly: Boolean

  # A type-specific ID.
  internalID: ID!
  keyword: String

  # Human-friendly labels that are added by Metaphysics to the upstream SearchCriteria type coming from Gravity
  labels(
    # An array of fields to exclude from labels array.
    except: [SearchCriteriaFields]

    # An array of fields to include in labels array.
    only: [SearchCriteriaFields]
  ): [SearchCriteriaLabel!]!
  locationCities: [String]
  majorPeriods: [String]
  materialsTerms: [String]
  offerable: Boolean
  partnerIDs: [String]
  priceArray: [Int]
  priceRange: String
  searchCriteriaID: String!
  settings: AlertSettings!
  sizes: [String]
  summary: JSON
  totalUserSearchCriteriaCount: Int
  width: String
}

# A connection to a list of items.
type AlertConnection {
  # A list of edges.
  edges: [AlertEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type AlertEdge {
  counts: AlertsCounts

  # A cursor for use in pagination
  cursor: String!
  isRecentlyEnabled: Boolean

  # The item at the end of the edge
  node: Alert
}

type AlertNotificationItem {
  alert: Alert
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
}

type AlertSettings {
  details: String
  email: Boolean!
  frequency: AlertSettingsFrequency
  name: String
  push: Boolean!
}

enum AlertSettingsFrequency {
  DAILY
  INSTANT
}

input AlertSettingsInput {
  details: String
  email: Boolean
  frequency: AlertSettingsFrequency
  name: String
  push: Boolean
}

input AlertSource {
  # The database id of the object from which the alert originates
  id: ID

  # The type of object from which the alert originates
  type: AlertSourceType
}

# The context from which the alert originates
enum AlertSourceType {
  ARTIST
  ARTWORK
}

enum AlertsConnectionSortEnum {
  ENABLED_AT_DESC
  NAME_ASC
}

type AlertsCounts {
  totalUserSearchCriteriaCount: Int
}

# A connection to a list of items.
type AlertsSummaryArtistConnection {
  # A list of edges.
  edges: [AlertsSummaryArtistEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type AlertsSummaryArtistEdge {
  counts: AlertsSummaryCounts

  # A cursor for use in pagination
  cursor: String!
  isRecentlyEnabled: Boolean

  # The item at the end of the edge
  node: Artist
  topHit: Alert
}

type AlertsSummaryCounts {
  totalUserSearchCriteriaCount: Int
  totalWithAdditionalGeneIdsCount: Int
  totalWithAttributionClassCount: Int
  totalWithOtherMetadataCount: Int
  totalWithPriceRangeCount: Int
}

type Algolia {
  apiKey: String! @deprecated(reason: "Algolia search is no longer supported")
  appID: String! @deprecated(reason: "Algolia search is no longer supported")
  indices: [AlgoliaIndex!]! @deprecated(reason: "Algolia search is no longer supported")
}

type AlgoliaIndex {
  displayName: String! @deprecated(reason: "Algolia search is no longer supported")
  key: String! @deprecated(reason: "Algolia search is no longer supported")
  name: String! @deprecated(reason: "Algolia search is no longer supported")
}

type AnalyticsArtist {
  entityId: String!
}

# Artist Affinity
type AnalyticsArtistAffinity {
  # Artist ID
  artistId: ID!

  # Calculated affinity Score
  score: Float!
}

# The connection type for ArtistAffinity.
type AnalyticsArtistAffinityConnection {
  # A list of edges.
  edges: [AnalyticsArtistAffinityEdge]

  # A list of nodes.
  nodes: [AnalyticsArtistAffinity]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AnalyticsArtistAffinityEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsArtistAffinity
}

# Artist ID and Medium Tuple
input AnalyticsArtistIdMediumTupleType {
  artistId: String!
  medium: String!
}

# Artist Recommendation
type AnalyticsArtistRecommendation {
  # Artist ID
  artistId: ID!

  # Calculated score
  score: Float!
}

# The connection type for ArtistRecommendation.
type AnalyticsArtistRecommendationConnection {
  # A list of edges.
  edges: [AnalyticsArtistRecommendationEdge]

  # A list of nodes.
  nodes: [AnalyticsArtistRecommendation]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AnalyticsArtistRecommendationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsArtistRecommendation
}

# Artist Sparkline
type AnalyticsArtistSparkline {
  artistId: ID!
  artistName: String
  eventDigest: String
  sparkles: BigInt
  tier: Float
  year: String
}

# The connection type for ArtistSparkline.
type AnalyticsArtistSparklineConnection {
  # A list of edges.
  edges: [AnalyticsArtistSparklineEdge]

  # A list of nodes.
  nodes: [AnalyticsArtistSparkline]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AnalyticsArtistSparklineEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsArtistSparkline
}

type AnalyticsArtwork {
  entityId: String!
}

# Artwork Recommendation
type AnalyticsArtworkRecommendation {
  # Artwork ID
  artworkId: ID!

  # Calculated score
  score: Float!
}

# The connection type for ArtworkRecommendation.
type AnalyticsArtworkRecommendationConnection {
  # A list of edges.
  edges: [AnalyticsArtworkRecommendationEdge]

  # A list of nodes.
  nodes: [AnalyticsArtworkRecommendation]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AnalyticsArtworkRecommendationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsArtworkRecommendation
}

# Publish artwork Series Stats
type AnalyticsArtworksPublishedStats {
  percentageChanged: Int!
  period: AnalyticsQueryPeriodEnum!
  timeSeries: [AnalyticsPartnerTimeSeriesStats!]!
  totalCount: Int!
}

# An ISO 8601 datetime
scalar AnalyticsDateTime

# Visitor countries, device, referals and session page
type AnalyticsGroupedStats {
  groupedEntity: AnalyticsGroupedStatsUnion!
  period: AnalyticsQueryPeriodEnum!
}

# The connection type for GroupedStats.
type AnalyticsGroupedStatsConnection {
  # A list of edges.
  edges: [AnalyticsGroupedStatsEdge]

  # A list of nodes.
  nodes: [AnalyticsGroupedStats]

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
}

# An edge in a connection.
type AnalyticsGroupedStatsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsGroupedStats
}

enum AnalyticsGroupedStatsMetricEnum {
  # visitor_by_device
  VISITOR_BY_DEVICE

  # visitor_by_landing_page
  VISITOR_BY_LANDING_PAGE

  # visitor_by_location
  VISITOR_BY_LOCATION

  # visitor_by_referral
  VISITOR_BY_REFERRAL
}

enum AnalyticsGroupedStatsObjectTypeEnum {
  # country
  COUNTRY

  # device type
  DEVICE

  # landing page
  LANDING_PAGE

  # referral
  REFERRAL
}

# A grouped stat item: country or device etc.
union AnalyticsGroupedStatsUnion =
    AnalyticsVisitorsByCountry
  | AnalyticsVisitorsByDevice
  | AnalyticsVisitorsByLandingPage
  | AnalyticsVisitorsByReferral

# A histogram bin
type AnalyticsHistogramBin {
  maxPrice(
    decimal: String = "."
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  maxPriceCents: Int!
  minPrice(
    decimal: String = "."
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  minPriceCents: Int!
  numArtworks: Int!
}

# New For You Recommendation
type AnalyticsNewForYouRecommendation {
  # Artwork ID
  artworkId: ID!

  # Artwork's published_at
  publishedAt: AnalyticsDateTime!

  # Artist affinity score
  score: Float!

  # Version of affinity recommendation
  version: String!
}

# The connection type for NewForYouRecommendation.
type AnalyticsNewForYouRecommendationConnection {
  # A list of edges.
  edges: [AnalyticsNewForYouRecommendationEdge]

  # A list of nodes.
  nodes: [AnalyticsNewForYouRecommendation]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AnalyticsNewForYouRecommendationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsNewForYouRecommendation
}

# Information about pagination in a connection.
type AnalyticsPageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# Stats for pageviews of partner content
type AnalyticsPageviewStats {
  artworkViews: Int
  galleryViews: Int
  percentageChanged: Int!
  period: AnalyticsQueryPeriodEnum!
  showViews: Int
  timeSeries: [AnalyticsPartnerTimeSeriesStats!]!
  totalCount: Int!
  uniqueVisitors: Int
}

# Audience stats of a partner
type AnalyticsPartnerAudienceStats {
  commercialVisitors: Int!
  partnerId: String!
  period: AnalyticsQueryPeriodEnum!
  uniqueVisitors: Int!
}

# Inquiry count time series data of a partner
type AnalyticsPartnerInquiryCountTimeSeriesStats {
  count: Int
  endTime: AnalyticsDateTime
  startTime: AnalyticsDateTime
}

# Inquiry stats of a partner
type AnalyticsPartnerInquiryStats {
  inquiryCount: Int!

  # Inquiry response time in seconds
  inquiryResponseTime: Int
  partnerId: String!
  period: AnalyticsQueryPeriodEnum!

  # Partner inquiry count time series
  timeSeries(cumulative: Boolean = false): [AnalyticsPartnerInquiryCountTimeSeriesStats!]
}

# Sales stats of a partner
type AnalyticsPartnerSalesStats {
  orderCount: Int!

  # Order response time in seconds
  orderResponseTime: Int
  partnerId: String!
  period: AnalyticsQueryPeriodEnum!

  # Partner sales time series
  timeSeries(cumulative: Boolean = false): [AnalyticsPartnerSalesTimeSeriesStats!]
  total(
    decimal: String = "."
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  totalCents: Int!
}

# Sales time series data of a partner
type AnalyticsPartnerSalesTimeSeriesStats {
  count: Int
  endTime: AnalyticsDateTime
  startTime: AnalyticsDateTime
  total(
    decimal: String = "."
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  totalCents: Int!
}

# Partner Stats
type AnalyticsPartnerStats {
  # Time series data on number of artworks published
  artworkPublished(period: AnalyticsQueryPeriodEnum!): AnalyticsPartnerStatsArtworksPublished

  # Time series data on number of artworks published
  artworksPublished(period: AnalyticsQueryPeriodEnum!): AnalyticsArtworksPublishedStats
    @deprecated(reason: "Use artworkPublished for refactored time series bucket code")

  # Audience stats
  audience(period: AnalyticsQueryPeriodEnum!): AnalyticsPartnerAudienceStats

  # Visitor countries, device, referals and session page
  groupedStats(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    metric: AnalyticsGroupedStatsMetricEnum!
    objectType: AnalyticsGroupedStatsObjectTypeEnum!
    period: AnalyticsQueryPeriodEnum!
  ): AnalyticsGroupedStatsConnection

  # Inquiry stats
  inquiry(period: AnalyticsQueryPeriodEnum!): AnalyticsPartnerInquiryStats

  # Different types of partner pageviews
  pageview(period: AnalyticsQueryPeriodEnum!): AnalyticsPartnerStatsPageviews

  # Different types of partner pageviews
  pageviews(period: AnalyticsQueryPeriodEnum!): AnalyticsPageviewStats
    @deprecated(reason: "Use pageview for refactored time series bucket code")
  partnerId: String!

  # Artworks, shows, viewing rooms, or artists ranked by views. Capped at 20 by the underlying sql query.
  rankedStats(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    objectType: AnalyticsRankedStatsObjectTypeEnum!
    period: AnalyticsQueryPeriodEnum!
  ): AnalyticsRankedStatsConnection

  # Sales stats
  sales(period: AnalyticsQueryPeriodEnum!): AnalyticsPartnerSalesStats

  # Top artworks ranked by views
  topArtworks(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AnalyticsRankedStatsConnection @deprecated(reason: "Use rankedStats(objectType: ) instead")

  # Number of unique visitors
  uniqueVisitors(period: AnalyticsQueryPeriodEnum!): Int
    @deprecated(reason: "Use audience() { uniqueVisitors } instead")
}

# Publish artwork Series Stats
type AnalyticsPartnerStatsArtworksPublished {
  partnerId: String!
  percentageChanged: Int!
  period: AnalyticsQueryPeriodEnum!

  # Partner artworks published count time series
  timeSeries(cumulative: Boolean = false): [AnalyticsPartnerStatsArtworksPublishedTimeSeries!]!
  totalCount: Int!
}

# Artworks published time series data of a partner
type AnalyticsPartnerStatsArtworksPublishedTimeSeries {
  count: Int
  endTime: AnalyticsDateTime
  startTime: AnalyticsDateTime
}

# Stats for pageviews of partner content
type AnalyticsPartnerStatsPageviews {
  artworkViews: Int!
  galleryViews: Int!
  partnerId: String!
  percentageChanged: Int!
  period: AnalyticsQueryPeriodEnum!
  showViews: Int!

  # Pageviews time series
  timeSeries(cumulative: Boolean = false): [AnalyticsPartnerStatsPageviewsTimeSeries!]
  totalCount: Int!
  uniqueVisitors: Int!
}

# Pageviews time series data of a partner
type AnalyticsPartnerStatsPageviewsTimeSeries {
  count: Int
  endTime: AnalyticsDateTime
  startTime: AnalyticsDateTime
}

# Partner Time Series Stats
type AnalyticsPartnerTimeSeriesStats {
  count: Int
  endTime: AnalyticsDateTime
  startTime: AnalyticsDateTime
}

# Price Context Filter Type
type AnalyticsPriceContextFilterType {
  category: AnalyticsPricingContextCategoryEnum
  dimension: AnalyticsPricingContextDimensionEnum
}

# Pricing Context Histogram
type AnalyticsPricingContext {
  appliedFilters: AnalyticsPriceContextFilterType!
  appliedFiltersDisplay: String
  bins: [AnalyticsHistogramBin!]!
}

enum AnalyticsPricingContextCategoryEnum {
  # Architecture
  ARCHITECTURE

  # Books and Portfolios
  BOOKS_AND_PORTFOLIOS

  # Design/Decorative Art
  DESIGN_DECORATIVE_ART

  # Drawing, Collage or other Work on Paper
  DRAWING_COLLAGE_OTHER_WORK_ON_PAPER

  # Fashion Design and Wearable Art
  FASHION

  # Installation
  INSTALLATION

  # Jewelry
  JEWELRY

  # Mixed Media
  MIXED_MEDIA

  # Other
  OTHER

  # Painting
  PAINTING

  # Performance Art
  PERFORMANCE

  # Photography
  PHOTOGRAPHY

  # Posters
  POSTERS

  # Print
  PRINT

  # Sculpture
  SCULPTURE

  # Sound
  SOUND

  # Textile Arts
  TEXTILE

  # Video/Film/Animation
  VIDEO_FILM_ANIMATION

  # Work on Paper
  WORK_ON_PAPER
}

enum AnalyticsPricingContextDimensionEnum {
  # Large
  LARGE

  # Medium
  MEDIUM

  # Small
  SMALL
}

enum AnalyticsQueryPeriodEnum {
  # Four weeks
  FOUR_WEEKS

  # One year
  ONE_YEAR

  # Sixteen weeks
  SIXTEEN_WEEKS
}

union AnalyticsRankedEntityUnion = Artist | Artwork | Show | ViewingRoom

# Top artworks, shows, viewing rooms, or artists from a partner
type AnalyticsRankedStats {
  entity: AnalyticsRankedEntityUnion
  period: AnalyticsQueryPeriodEnum!
  rankedEntity: AnalyticsRankedStatsUnion!
  value: Int!
}

# The connection type for RankedStats.
type AnalyticsRankedStatsConnection {
  # A list of edges.
  edges: [AnalyticsRankedStatsEdge]

  # A list of nodes.
  nodes: [AnalyticsRankedStats]

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
}

# An edge in a connection.
type AnalyticsRankedStatsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AnalyticsRankedStats
}

enum AnalyticsRankedStatsObjectTypeEnum {
  # Artist
  ARTIST

  # Artwork
  ARTWORK

  # Show
  SHOW

  # ViewingRoom
  VIEWING_ROOM
}

# An artwork, artist, show, or viewing room
union AnalyticsRankedStatsUnion =
    AnalyticsArtist
  | AnalyticsArtwork
  | AnalyticsShow
  | AnalyticsViewingRoom

type AnalyticsShow {
  entityId: String!
}

# Statistics for users
type AnalyticsUserStats {
  totalPurchaseCount: Int!
  userId: String!
}

type AnalyticsViewingRoom {
  entityId: String!
}

type AnalyticsVisitorsByCountry {
  metric: String!
  name: String!
  percent: Float!
  type: String!
  value: Int!
}

type AnalyticsVisitorsByDevice {
  metric: String!
  name: String!
  percent: Float!
  type: String!
  value: Int!
}

type AnalyticsVisitorsByLandingPage {
  metric: String!
  name: String!
  percent: Float!
  type: String!
  value: Int!
}

type AnalyticsVisitorsByReferral {
  metric: String!
  name: String!
  percent: Float!
  type: String!
  value: Int!
}

# App Authenticator Two-Factor Authentication factor
type AppSecondFactor implements SecondFactor {
  createdAt: ISO8601DateTime!
  disabledAt: ISO8601DateTime
  enabled: Boolean!
  enabledAt: ISO8601DateTime
  internalID: ID!
  kind: SecondFactorKind!
  name: String
  otpProvisioningURI: String
  otpSecret: String
  updatedAt: ISO8601DateTime!
}

# Second factor input attributes
input AppSecondFactorAttributes {
  # Name of the second factor
  name: String
}

# An app second factor or errors
union AppSecondFactorOrErrorsUnion = AppSecondFactor | Errors

type Article implements Node {
  # Maps to the "Primary Author" field in Positron. Ultimately this is only supposed to control the article slug
  author: Author @deprecated(reason: "Use `byline` or `authors` instead")
  authors: [Author!]!

  # The byline for the article. Defaults to "Artsy Editors" if no authors are present.
  byline: String
  cached: Int
  channel: Channel
  channelArticles(
    # Number of articles to return
    size: Int = 12
  ): [Article!]!
  channelID: String @deprecated(reason: "Use `channel` instead")
  contributingAuthors: [Author] @deprecated(reason: "Use `byline` or `authors` instead")
  description: String
  hero: ArticleHero
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  keywords: [String!]!
  layout: ArticleLayout!

  # Classic layout articles may have a lead paragraph. Returns HTML.
  leadParagraph: String
  media: ArticleMedia
  newsSource: ArticleNewsSource
  postscript: String
  publishedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  relatedArticles(
    # Enables configuration for loading the type of articles that sit in between full-page articles
    inVertical: Boolean = false

    # Number of articles to return
    size: Int = 3
  ): [Article!]!

  # Description to favor for meta description
  searchDescription: String

  # Title to favor for document titles
  searchTitle: String
  sections: [ArticleSections!]!
  series: ArticleSeries
  seriesArticle: Article
  slug: String
  sponsor: ArticleSponsor
  thumbnailImage: Image
  thumbnailTeaser: String

  # Title to favor for links to article
  thumbnailTitle: String
  tier: Int
  title: String
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  vertical: String
}

# A connection to a list of items.
type ArticleConnection {
  # A list of edges.
  edges: [ArticleEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArticleEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Article
}

type ArticleFeatureSection {
  # Only YouTube and Vimeo are supported
  embed(autoPlay: Boolean = false): String
  image: Image
  layout: ArticleFeatureSectionType!
  media: String
  title: String
}

enum ArticleFeatureSectionType {
  BASIC
  FULLSCREEN
  SPLIT
  TEXT
}

type ArticleFeaturedArtistNotificationItem {
  article: Article
  artistsConnection(after: String, before: String, first: Int, last: Int): ArtistConnection
}

union ArticleHero = ArticleFeatureSection

type ArticleImageSection {
  caption: String
  id: ID!
  image: Image
  layout: String
}

enum ArticleLayout {
  CLASSIC
  FEATURE
  NEWS
  SERIES
  STANDARD
  VIDEO
}

type ArticleMedia {
  coverImage: Image
  credits: String
  description: String
  duration: String
  releaseDate(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  url: String
}

type ArticleNewsSource {
  title: String
  url: String
}

type ArticleSectionCallout {
  article: String
  hideImage: String
  text: String
  thumbnailUrl: String
  topStories: String
  type: String
}

type ArticleSectionEmbed {
  height: Int
  layout: ArticleSectionEmbedLayout
  mobileHeight: Int
  url: String
}

enum ArticleSectionEmbedLayout {
  COLUMN_WIDTH
  FILLWIDTH
  OVERFLOW
  OVERFLOW_FILLWIDTH
}

type ArticleSectionImageCollection {
  figures: [ArticleSectionImageCollectionFigure!]!
  layout: ArticleSectionImageCollectionLayout!
}

union ArticleSectionImageCollectionFigure =
    ArticleImageSection
  | ArticleUnpublishedArtwork
  | Artwork

enum ArticleSectionImageCollectionLayout {
  COLUMN_WIDTH
  FILLWIDTH
  OVERFLOW_FILLWIDTH
}

type ArticleSectionImageSet {
  counts: ArticleSectionImageSetCounts!
  cover: ArticleSectionImageSetFigure
  figures: [ArticleSectionImageSetFigure!]!
  layout: ArticleSectionImageSetLayout!
  title: String
}

type ArticleSectionImageSetCounts {
  figures: Int!
}

union ArticleSectionImageSetFigure = ArticleImageSection | Artwork

enum ArticleSectionImageSetLayout {
  FULL
  MINI
}

type ArticleSectionSocialEmbed {
  # oEmbed HTML response. Only Twitter is currently supported.
  embed: String
  url: String
}

type ArticleSectionText {
  body: String
  layout: String
}

type ArticleSectionVideo {
  backgroundColor: String
  caption: String

  # Only YouTube and Vimeo are supported
  embed(autoPlay: Boolean = false): String
  image: Image
  layout: ArticleSectionVideoLayout
  url: String!
}

enum ArticleSectionVideoLayout {
  COLUMN_WIDTH
  FILLWIDTH
  OVERFLOW_FILLWIDTH
}

union ArticleSections =
    ArticleSectionCallout
  | ArticleSectionEmbed
  | ArticleSectionImageCollection
  | ArticleSectionImageSet
  | ArticleSectionSocialEmbed
  | ArticleSectionText
  | ArticleSectionVideo

type ArticleSeries {
  # HTML string describing the series
  description: String
}

enum ArticleSorts {
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
}

type ArticleSponsor {
  description: String
  partnerCondensedLogo: String
  partnerDarkLogo: String
  partnerLightLogo: String
  partnerLogoLink: String
  pixelTrackingCode: String
  subTitle: String
}

type ArticleUnpublishedArtwork {
  artist: ArticleUnpublishedArtworkArtist
  artists: [ArticleUnpublishedArtworkArtist!]!
  credit: String
  date: String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  partner: ArticleUnpublishedArtworkPartner

  # A slug ID.
  slug: ID!
  title: String
}

type ArticleUnpublishedArtworkArtist {
  name: String
  slug: String
}

type ArticleUnpublishedArtworkPartner {
  name: String
  slug: String
}

# An articles rail section in the home view
type ArticlesRailHomeViewSection implements GenericHomeViewSection & Node {
  articlesConnection(after: String, before: String, first: Int, last: Int): ArticleConnection

  # The component that is prescribed for this section
  component: HomeViewComponent

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

type Artist implements EntityWithFilterArtworksConnectionInterface & Node & Searchable {
  alertsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
    sort: String
  ): AlertConnection
  alternateNames: [String]
  articlesConnection(
    after: String
    before: String
    first: Int

    # Get only articles with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean = false
    last: Int

    # DEPRECATION REASON: Use `size` instead
    limit: Int
    page: Int
    size: Int
    sort: ArticleSorts
  ): ArticleConnection
  artistSeriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtistSeriesConnection
  artworksConnection(
    after: String
    before: String

    # List of artwork IDs to exclude from the response.
    exclude: [String]
    filter: [ArtistArtworksFilters]
    first: Int
    last: Int
    published: Boolean = true
    sort: ArtworkSorts
  ): ArtworkConnection
  auctionResultsConnection(
    after: String

    # List of aggregations for auction results
    aggregations: [AuctionResultsAggregation]

    # Allow auction results with empty created date values
    allowEmptyCreatedDates: Boolean = true

    # Include auction results with unspecified created dates
    allowUnspecifiedSaleDates: Boolean = true
    before: String

    # Filter auction results by category (medium)
    categories: [String]

    # Currency code
    currency: String

    # Filter auction results by earliest created at year
    earliestCreatedYear: Int
    first: Int

    # Includes auction results with suitable estimate ranges
    includeEstimateRange: Boolean = false

    # Includes auction results without price
    includeUnknownPrices: Boolean = true

    # Filter by artwork title or description keyword search
    keyword: String
    last: Int

    # Filter auction results by latest created at year
    latestCreatedYear: Int

    # Filter auction results by organizations
    organizations: [String]
    page: Int

    # Filter auction results by price
    priceRange: String

    # When true, will only return records for allowed artists.
    recordsTrusted: Boolean = false

    # Filter auction results by end sale date year
    saleEndYear: Int

    # Filter auction results by start sale end date
    saleStartYear: Int
    size: Int

    # Filter auction results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: AuctionResultSorts

    # State of the returned auction results (can be past, upcoming, or all)
    state: AuctionResultsState = ALL
  ): AuctionResultConnection
  awards: String

  # In applicable contexts, this is what the artist (as a suggestion) is based on.
  basedOn: Artist
  bio: String

  # The Artist biography article written by Artsy
  biography: Article
  biographyBlurb(
    format: Format

    # If true, will return featured bio over Artsy one.
    partnerBio: Boolean = true
  ): ArtistBlurb
  birthday: String
  blurb(format: Format): String
  cached: Int
  careerHighlights(
    # Filter by collected shows.
    collected: Boolean

    # Filter by group shows.
    group: Boolean

    # The slug or ID of the Partner
    partnerId: String

    # Filter by solo shows.
    solo: Boolean
  ): [CareerHighlight!]!
  carousel: ArtistCarousel
  collections: [String]
  contemporary(
    excludeArtistsWithoutArtworks: Boolean = true

    # The number of Artists to return
    size: Int
  ): [Artist]
  counts: ArtistCounts
  coverArtwork: Artwork
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  criticallyAcclaimed: Boolean!
  currentEvent: CurrentEvent
  deathday: String
  disablePriceContext: Boolean
  displayLabel: String
  displayName: String
  duplicates: [Artist]

  # Custom-sorted list of shows for an artist, in order of significance.
  exhibitionHighlights(
    # The number of Shows to return
    size: Int = 5
  ): [Show]

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  first: String

  # A string showing the total number of works and those for sale
  formattedArtworksCount: String

  # A string of the form "Nationality, Birthday (or Birthday-Deathday)"
  formattedNationalityAndBirthday: String
  gender: String

  # A list of genes associated with an artist
  genes: [Gene]
  groupIndicator: ArtistGroupIndicator
  hasMetadata: Boolean
  highlights: ArtistHighlights
  hometown: String
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String
  initials(length: Int = 3): String
  insights(
    # The specific insights to return.
    kind: [ArtistInsightKind] = [
      HIGH_AUCTION_RECORD
      ACTIVE_SECONDARY_MARKET
      CRITICALLY_ACCLAIMED
      RECENT_CAREER_EVENT
      ARTSY_VANGUARD_YEAR
      CURATORS_PICK_EMERGING
      TRENDING_NOW
      GAINING_FOLLOWERS
      SOLO_SHOW
      GROUP_SHOW
      BIENNIAL
      PRIVATE_COLLECTIONS
      COLLECTED
      REVIEWED
      AWARDS
      RESIDENCIES
    ]
  ): [ArtistInsight!]!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isConsignable: Boolean

  # Only specific Artists should show a link to auction results.
  isDisplayAuctionLink: Boolean
  isFollowed: Boolean

  # Whether the artist has been created by a user.
  isPersonalArtist: Boolean
  isPublic: Boolean!
  isShareable: Boolean
  last: String
  location: String
  marketingCollections(
    category: String
    isFeaturedArtistContent: Boolean
    size: Int
    slugs: [String!]
  ): [MarketingCollection]
  meta(page: ArtistPage = ABOUT): ArtistMeta!
  middle: String
  name: String
  nationality: String
  partnerArtists(
    # The number of PartnerArtists to return
    size: Int
  ): [PartnerArtist]

  # The Partner's provided biography for the artist
  partnerBiographyBlurb(format: Format): partnerBiographyBlurb
    @deprecated(reason: "This field is deprecated. No longer in use")
  partnersConnection(
    after: String
    before: String
    first: Int
    last: Int
    partnerCategory: [String]
    representedBy: Boolean
  ): PartnerArtistConnection

  # The most recent show for an artist
  recentShow: String
  related: ArtistRelatedData
  sales(
    isAuction: Boolean
    live: Boolean

    # The number of Sales to return
    size: Int
    sort: SaleSorts
  ): [Sale]
  showsConnection(
    active: Boolean
    after: String
    atAFair: Boolean
    before: String
    first: Int
    isReference: Boolean
    last: Int
    page: Int

    # The number of PartnerShows to return
    size: Int
    soloShow: Boolean
    sort: ShowSorts
    status: String
    topTier: Boolean
    visibleToPublic: Boolean
  ): ShowConnection

  # A slug ID.
  slug: ID!

  # Use this attribute to sort by when sorting a collection of Artists
  sortableID: String
  statuses: ArtistStatuses
  targetSupply: ArtistTargetSupply!
  vanguardYear: String
  verifiedRepresentatives: [VerifiedRepresentative!]!
  years: String
}

enum ArtistAlertsSort {
  SORTABLE_ID_ASC
  SORTABLE_ID_DESC
}

type ArtistArtworkGrid implements ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

enum ArtistArtworksFilters {
  IS_FOR_SALE
  IS_NOT_FOR_SALE
}

type ArtistBlurb {
  credit: String
  partner: Partner

  # The partner id of the partner who submitted the featured bio.
  partnerID: String
    @deprecated(reason: "No longer used as the partner field contains the partner.id")
  text: String
}

type ArtistCarousel {
  images: [Image]
}

# A connection to a list of items.
type ArtistConnection {
  # A list of edges.
  edges: [ArtistEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type ArtistCounts {
  articles: Int
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  auctionArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  auctionResults: Int @deprecated(reason: "Favor `statuses#auctionLots`")
  duplicates: Int
  ecommerceArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  follows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  forSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  hasMakeOfferArtworks: Boolean
  myCollectedArtworks: Int!
  partnerShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  relatedArtists: Int
}

# An edge in a connection.
type ArtistEdge {
  # When a relevant `artworksCount` field exists to augment a connection
  artworksCount: Int

  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artist
}

type ArtistGroup {
  # Artists sorted by last name
  items: [Artist]

  # Letter artists group belongs to
  letter: String
}

enum ArtistGroupIndicator {
  DUO
  GROUP
  INDIVIDUAL
  N_A
}

type ArtistHighlights {
  partnersConnection(
    after: String
    before: String
    displayOnPartnerProfile: Boolean
    first: Int
    last: Int
    partnerCategory: [String]
    representedBy: Boolean
  ): PartnerArtistConnection
}

type ArtistInsight {
  artist: Artist

  # Number of entities relevant to the insight.
  count: Int!
  description(format: Format = PLAIN): String

  # List of entities relevant to the insight.
  entities: [String!]!

  # The type of insight.
  kind: ArtistInsightKind

  # Label to use when displaying the insight.
  label: String!

  # The type of insight.
  type: String! @deprecated(reason: "Use `kind` instead.")
}

enum ArtistInsightKind {
  ACTIVE_SECONDARY_MARKET
  ARTSY_VANGUARD_YEAR
  AWARDS
  BIENNIAL
  COLLECTED
  CRITICALLY_ACCLAIMED
  CURATORS_PICK_EMERGING
  GAINING_FOLLOWERS
  GROUP_SHOW
  HIGH_AUCTION_RECORD
  PRIVATE_COLLECTIONS
  RECENT_CAREER_EVENT
  RESIDENCIES
  REVIEWED
  SOLO_SHOW
  TRENDING_NOW
}

type ArtistInsightsCount {
  activeSecondaryMarketCount: Int!
  biennialCount: Int!
  collectedCount: Int!
  groupShowCount: Int!
  reviewedCount: Int!
  soloShowCount: Int!
}

type ArtistMeta {
  description: String!
  title: String!
}

enum ArtistPage {
  ABOUT
  ARTIST_SERIES
  ARTWORKS
  AUCTION_RESULTS
}

# A connection to a list of items.
type ArtistPartnerConnection {
  # A list of edges.
  edges: [ArtistPartnerEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArtistPartnerEdge {
  artist: Artist
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: PartnerArtistArtworksSort
  ): ArtworkConnection
  biography: String
  biographyBlurb(format: Format): PartnerArtistBlurb
  counts: PartnerArtistCounts

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isHiddenInPresentationMode: Boolean
  isUseDefaultBiography: Boolean

  # The item at the end of the edge
  node: Artist
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

type ArtistRelatedData {
  artistsConnection(
    after: String
    before: String
    excludeArtistsWithoutArtworks: Boolean = true
    first: Int
    kind: RelatedArtistsKind
    last: Int
    minForsaleArtworks: Int
  ): ArtistConnection
  genes(after: String, before: String, first: Int, last: Int): GeneConnection

  # A list of the current userâ€™s suggested artists, based on a single artist
  suggestedConnection(
    after: String
    before: String

    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # Exclude artists without any artworks
    excludeArtistsWithoutArtworks: Boolean

    # Exclude artists without for sale works
    excludeArtistsWithoutForsaleArtworks: Boolean

    # Exclude artists the user already follows
    excludeFollowedArtists: Boolean
    first: Int

    # Include featured artists if no results are found
    includeFallbackArtists: Boolean
    last: Int
  ): ArtistConnection
}

type ArtistSeries {
  # List of Mongo IDs for associated Artists
  artistIDs: [String!]!
  artists(page: Int, size: Int): [Artist]
  artworkIDs: [ID!]!
  artworksConnection(after: String, first: Int): ArtworkConnection
  artworksCount: Int!

  # A formatted string that shows the number of available works or
  # (as a fallback) the number of works in general.
  artworksCountMessage: String
  description: String
  descriptionFormatted(format: Format): String
  featured: Boolean!
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  forSaleArtworksCount: Int!
  image: Image
  imageHeight: Int
  imageURL: String
  imageWidth: Int

  # Unique ID for this artist series
  internalID: ID!
  published: Boolean!
  representativeArtworkID: ID
  slug: String!
  title: String!
}

# The connection type for ArtistSeries.
type ArtistSeriesConnection {
  # A list of edges.
  edges: [ArtistSeriesEdge]

  # A list of nodes.
  nodes: [ArtistSeries]

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Total count of matching nodes, before pagination
  totalCount: Int!
}

# An edge in a connection.
type ArtistSeriesEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: ArtistSeries
}

enum ArtistSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  SORTABLE_ID_ASC
  SORTABLE_ID_DESC
  TRENDING_DESC
}

type ArtistStatuses {
  articles: Boolean
  artists: Boolean
  artworks: Boolean
  auctionLots: Boolean
  biography: Boolean
  contemporary: Boolean
  cv(
    # Suppress the cv tab when artist show count is less than this.
    minShowCount: Int = 15
  ): Boolean
  shows: Boolean
}

type ArtistTargetSupply {
  # True if an artist is in the microfunnel list.
  isInMicrofunnel: Boolean

  # True if an artist is a P1 artist.
  isP1: Boolean @deprecated(reason: "Use \"priority\" field instead.")

  # True if artist is in target supply list.
  isTargetSupply: Boolean
  microfunnel: ArtistTargetSupplyMicrofunnel
  priority: ArtistTargetSupplyPriority
  type: ArtistTargetSupplyType
}

type ArtistTargetSupplyMicrofunnel {
  # A list of recently sold artworks.
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Randomize the order of artworks for display purposes.
    randomize: Boolean
  ): ArtworkConnection
  metadata: TargetSupplyMicrofunnelMetadata
}

enum ArtistTargetSupplyPriority {
  FALSE
  TRUE
}

enum ArtistTargetSupplyType {
  AUCTION_MARKET
  CURATED_EMERGING
  HIGHEST_HQDLS
  HIGH_HQDLS
}

# An artists rail section in the home view
type ArtistsRailHomeViewSection implements GenericHomeViewSection & Node {
  artistsConnection(after: String, before: String, first: Int, last: Int): ArtistConnection

  # The component that is prescribed for this section
  component: HomeViewComponent

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type ArtistsWithAlertCountsConnection {
  # A list of edges.
  edges: [ArtistsWithAlertCountsEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArtistsWithAlertCountsEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artist
  totalAlertCount: Int
}

type Artwork implements Node & Searchable & Sellable {
  additionalInformation(format: Format): String
  artaShippingEnabled: Boolean
    @deprecated(reason: "Prefer to use `processWithArtsyShippingDomestic`. [Will be removed in v2]")
  articles(size: Int): [Article]
  artist(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): Artist
  artistNames: String
  artistSeriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtistSeriesConnection
  artists(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): [Artist]
  artsyShippingDomestic: Boolean
  artsyShippingInternational: Boolean

  # Represents the location of the artwork for "My Collection" artworks
  artworkLocation: String @deprecated(reason: "Please use `collectorLocation` instead")

  # Represents the "**classification**" of an artwork, such as _limited edition_
  attributionClass: AttributionClass
  availability: String
  cached: Int

  # Can a user request a lot conditions report for this artwork?
  canRequestLotConditionsReport: Boolean

  # Represents the "**medium type**", such as _Painting_. (This field is also commonly referred to as just "medium", but should not be confused with the artwork attribute called `medium`.)
  category: String @deprecated(reason: "Prefer to use `mediumType`.")

  # Returns the display label and detail when artwork has a certificate of authenticity
  certificateOfAuthenticity: ArtworkInfoRow
  certificateOfAuthenticityDetails: CertificateOfAuthenticityDetails
  collectingInstitution: String
  collectionsConnection(
    after: String
    before: String
    default: Boolean
    first: Int
    last: Int
    page: Int
    saves: Boolean
    size: Int
    sort: CollectionSorts
  ): CollectionsConnection

  # The location of the artwork in My Collection
  collectorLocation: MyLocation

  # Collector signals on artwork
  collectorSignals: CollectorSignals

  # Comparable auction results
  comparableAuctionResults(
    after: String
    before: String
    first: Int
    last: Int
  ): AuctionResultConnection
  condition: ArtworkCondition
  conditionDescription: ArtworkInfoRow

  # Notes by a partner or MyCollection user on the artwork, can only be accessed by partner or the user that owns the artwork
  confidentialNotes: String
  consignmentSubmission: ArtworkConsignmentSubmission
  contactLabel: String

  # Pre-filled inquiry text
  contactMessage: String

  # Returns the associated Fair/Sale/Show
  context: ArtworkContext
  contextGrids(
    # Whether to include the `RelatedArtworksGrid` module. Defaults to `true`; preferred behavior is to opt out with `false`.
    includeRelatedArtworks: Boolean! = true
  ): [ArtworkContextGrid]

  # The currency code used to pay for the artwork
  costCurrencyCode: String

  # The amount paid for the artwork, in cents
  costMinor: Int
  culturalMaker: String
  date: String

  # The depth as expressed by the original input metric
  depth: String
  description(format: Format): String
  dimensions: dimensions
  displayArtistBio: Boolean
  displayLabel: String
  displayPriceRange: Boolean

  # Domestic shipping fee.
  domesticShippingFee: Money
  dominantColors: [String!]!
  downloadableImageUrl: String
  editionNumber: String
  editionOf: String
  editionSet(id: String!): EditionSet
  editionSets(sort: EditionSetSorts): [EditionSet]
  editionSize: String

  # Returns an HTML string representing the embedded content (video)
  embed(autoplay: Boolean = false, height: Int = 450, width: Int = 853): String

  # Flags if artwork located in one of EU local shipping countries.
  euShippingOrigin: Boolean
  exhibitionHistory(format: Format): String
  fair: Fair

  # A list of images and videos for the artwork
  figures(
    # Include all images, even if they are not ready or processing failed.
    includeAll: Boolean
  ): [ArtworkFigures!]!

  # Formatted artwork metadata, including artist, title, date and partner; e.g., 'Andy Warhol, Truck, 1980, Westward Gallery'.
  formattedMetadata: String
  framed: ArtworkInfoRow @deprecated(reason: "Consider using isFramed field (boolean) instead")
  framedDepth: String
  framedHeight: String
  framedMetric: String
  framedWidth: String

  # Returns true when artwork has a certificate of authenticity
  hasCertificateOfAuthenticity: Boolean
  hasMarketPriceInsights: Boolean

  # Whether a request for price estimate has been submitted for this artwork
  hasPriceEstimateRequest: Boolean

  # The height as expressed by the original input metric
  height: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  heightCm: Float

  # Returns the highlighted shows and articles
  highlights: [ArtworkHighlight]
  href: String

  # A globally unique ID.
  id: ID!
  image(
    # Show all images, even if they are not ready or processing failed.
    includeAll: Boolean
    size: Int
  ): Image
  imageRights: String
  imageTitle: String
  imageUrl: String
  images(
    # Show all images, even if they are not ready or processing failed.
    includeAll: Boolean
    size: Int
  ): [Image]

  # Represents the import source of the artwork
  importSource: ArtworkImportSource

  # Structured questions a collector can inquire on about this work
  inquiryQuestions: [InquiryQuestion]

  # Price for internal partner display, requires partner access
  internalDisplayPrice: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # International shipping fee.
  internationalShippingFee: Money

  # Private text field for partner use
  inventoryId: String

  # Whether a work can be purchased through Buy Now
  isAcquireable: Boolean

  # Is this artwork part of an auction that is currently running?
  isBiddable: Boolean

  # When in an auction, can the work be bought immediately
  isBuyNowable: Boolean
  isComparableWithAuctionResults: Boolean
  isDisliked: Boolean!
  isDownloadable: Boolean
  isEdition: Boolean

  # Artwork is eligible for the Artsy Guarantee
  isEligibleForArtsyGuarantee: Boolean!

  # Artwork is eligible for on-platform transaction
  isEligibleForOnPlatformTransaction: Boolean!

  # Artwork meets minimum metadata criteria to have an alert created from it
  isEligibleToCreateAlert: Boolean!
  isEmbeddableVideo: Boolean
  isForSale: Boolean
  isFramed: Boolean
  isHangable: Boolean

  # Is this artwork part of an auction?
  isInAuction: Boolean

  # Is this artwork part of a current show
  isInShow: Boolean

  # Do we want to encourage inquiries on this work?
  isInquireable: Boolean
  isListed: Boolean!
  isNotForSale: String

  # Whether a user can make an offer on a work
  isOfferable: Boolean

  # Whether a user can make an offer on the work through inquiry
  isOfferableFromInquiry: Boolean
  isOnHold: String
  isPriceEstimateRequestable: Boolean
  isPriceHidden: Boolean
  isPriceRange: Boolean

  # Whether a work can be purchased
  isPurchasable: Boolean
  isSaved: Boolean

  # Checks if artwork is saved to user's lists
  isSavedToList(default: Boolean = false, saves: Boolean = true): Boolean!

  # Should the video be used as the cover image
  isSetVideoAsCover: Boolean
  isShareable: Boolean
  isSold: Boolean
  isUnique: Boolean

  # Artwork is marked as "unlisted" (or private) by the partner
  isUnlisted: Boolean!
  lastOfferableActivityAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastSavedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  layer(id: String): ArtworkLayer
  layers: [ArtworkLayer]
  listPrice: ListPrice
  listedArtworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection!
  literature(format: Format): String

  # Represents partner's location
  location: Location
  manufacturer(format: Format): String
  marketPriceInsights: ArtworkPriceInsights

  # Represents the **materials** used in this work, such as _oil and acrylic on canvas_. (This should not be confused with the artwork attribute called `category`, which is commonly referred to as "medium" or "medium type")
  medium: String

  # Represents the "**medium type**", such as _Painting_. (This field is also commonly referred to as just "medium", but should not be confused with the artwork attribute called `medium`.)
  mediumType: ArtworkMedium
  meta: ArtworkMeta

  # The unit of length of the artwork, expressed in `in` or `cm`
  metric: String
  myLotStanding(live: Boolean = null): [LotStanding!]

  # Count of collectors with eligible offerable activities.
  offerableActivity: OfferableActivity

  # Is this work only available for shipping domestically?
  onlyShipsDomestically: Boolean
  partner(
    # Use whatever is in the original response instead of making a request
    shallow: Boolean
  ): Partner
  partnerOffersConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
    sort: PartnerOfferSorts
  ): PartnerOfferConnection
  pickupAvailable: Boolean
  price: String
  priceCurrency: String
  priceIncludesTax: Boolean
  priceIncludesTaxDisplay: String
  priceListed: Money
  priceListedDisplay: String

  # The price paid for the artwork in a user's 'my collection'
  pricePaid: Money
  pricingContext: AnalyticsPricingContext

  # Returns true if this work is eligible to be automatically opted into Artsy Domestic Shipping
  processWithArtsyShippingDomestic: Boolean
  provenance(format: Format): String

  # Whether this artwork is published or not
  published: Boolean!
  publisher(format: Format): String

  # Price which an artwork was sold for. This generally only applies to artworks in the target supply microfunnel and (currently) queries against hardcoded spreadsheet data.
  realizedPrice: String
  realizedToEstimate: String

  # Count of abandoned orders, in the last 30 days.
  recentAbandonedOrdersCount: Int

  # Count of collected artworks, in saves collections, in the last 30 days
  recentSavesCount: Int
  related(size: Int): [Artwork]
  sale: Sale
  saleArtwork(saleID: String = null): SaleArtwork
  saleMessage: String

  # Schema related to saved searches based on this artwork
  savedSearch: ArtworkSavedSearch
  series(format: Format): String

  # The country an artwork will be shipped from.
  shippingCountry: String

  # The string that describes domestic and international shipping.
  shippingInfo: String

  # Minimal location information describing from where artwork will be shipped.
  shippingOrigin: String

  # Is this work available for shipping only within the Continental US?
  shipsToContinentalUSOnly: Boolean
    @deprecated(reason: "Prefer to use `onlyShipsDomestically`. [Will be removed in v2]")
  show(active: Boolean, atAFair: Boolean, sort: ShowSorts): Show
  shows(active: Boolean, atAFair: Boolean, size: Int, sort: ShowSorts): [Show]
  signature(format: Format): String
  signatureDetails: String
  signatureInfo: ArtworkInfoRow

  # size bucket assigned to an artwork based on its dimensions
  sizeBucket: String

  # score assigned to an artwork based on its dimensions
  sizeScore: Float

  # A slug ID.
  slug: ID!
  submissionId: String
  taxInfo: TaxInfo
  title: String

  # Based on artwork location and status, verify that partner needs VAT exemption approval from Artsy.
  vatExemptApprovalRequired: Boolean

  # Based on artwork location verify that VAT info for the partner is complete.
  vatRequirementComplete: Boolean

  # The visibility level of the artwork
  visibilityLevel: Visibility

  # If the category is video, then it returns the href for the (youtube/vimeo) video, otherwise returns the website from CMS
  website: String

  # The width as expressed by the original input metric
  width: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  widthCm: Float
}

enum ArtworkAggregation {
  ARTIST
  ARTIST_NATIONALITY
  ARTIST_SERIES
  ATTRIBUTION_CLASS
  COLOR
  DIMENSION_RANGE
  FOLLOWED_ARTISTS
  GALLERY
  INSTITUTION
  LOCATION_CITY
  MAJOR_PERIOD
  MATERIALS_TERMS
  MEDIUM
  MERCHANDISABLE_ARTISTS
  PARTNER
  PARTNER_CITY
  PERIOD
  PRICE_RANGE
  SIMPLE_PRICE_HISTOGRAM
  TOTAL
}

enum ArtworkAttributionClassType {
  LIMITED_EDITION
  OPEN_EDITION
  UNIQUE
  UNKNOWN_EDITION
}

type ArtworkCondition {
  description: String
  displayText: String
  value: String
}

enum ArtworkConditionEnumType {
  EXCELLENT
  FAIR
  GOOD
  VERY_GOOD
}

# A connection to a list of items.
type ArtworkConnection implements ArtworkConnectionInterface {
  # A list of edges.
  edges: [ArtworkEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

interface ArtworkConnectionInterface {
  edges: [ArtworkEdgeInterface]
  pageCursors: PageCursors!
  pageInfo: PageInfo!
}

type ArtworkConsignmentSubmission {
  # Action label asks the user to poseed with the submission.
  actionLabel: String

  # Button label visible to the user.
  buttonLabel: String
  displayText: String @deprecated(reason: "Prefer `stateLabel` field.")
  externalID: String
  inProgress: Boolean
  internalID: String
  isSold: Boolean

  # Submission state.
  state: ArtworkConsignmentSubmissionState!

  # More information about the submission state.
  stateHelpMessage: String

  # Submission state label visible to the user.
  stateLabel: String
  stateLabelColor: String
}

# A connection to a list of items.
type ArtworkConsignmentSubmissionConnection {
  # A list of edges.
  edges: [ArtworkConsignmentSubmissionEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type ArtworkConsignmentSubmissionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ArtworkConsignmentSubmission
}

enum ArtworkConsignmentSubmissionState {
  APPROVED
  CLOSED
  DRAFT
  HOLD
  PUBLISHED
  REJECTED
  RESUBMITTED
  SUBMITTED
}

union ArtworkContext = Fair | Sale | Show

# A specific grid.
interface ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# An edge in a connection.
type ArtworkEdge implements ArtworkEdgeInterface {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

interface ArtworkEdgeInterface {
  cursor: String
  node: Artwork
}

# An error type, potentially containing a partial artwork response
type ArtworkError {
  artwork: PartialArtwork
  requestError: RequestError
}

union ArtworkFigures = Image | Video

union ArtworkFilterFacet = Gene | Tag

union ArtworkHighlight = Article | Show

enum ArtworkImportSource {
  CONVECTION
  MY_COLLECTION
}

type ArtworkInfoRow {
  # Additional details about given attribute
  details: String

  # Label for information row
  label: String
}

# An inquiry on an Artwork
type ArtworkInquiry {
  artwork: Artwork!

  # A globally unique ID.
  id: ID!
  impulseConversationID: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type ArtworkInquiryConnection {
  # A list of edges.
  edges: [ArtworkInquiryEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ArtworkInquiryEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ArtworkInquiry
}

type ArtworkLayer {
  # A connection of artworks from a Layer.
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  cached: Int
  description: String
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String
  type: String
}

# Collection of fields that describe medium type, such as _Painting_. (This field is also commonly referred to as just "medium", but should not be confused with the artwork attribute called `medium`.)
type ArtworkMedium {
  # The medium gene that corresponds to this medium type. Used for filtering purposes on our frontend, e.g. in artwork grids.
  filterGene: Gene

  # Long descriptive phrase
  longDescription: String

  # Shortest form of medium type display
  name: String
}

type ArtworkMeta {
  description(limit: Int = 155): String
  image: String
  share: String
  title: String
}

type ArtworkMutationDeleteSuccess {
  success: Boolean
}

type ArtworkMutationFailure {
  mutationError: GravityMutationError
}

union ArtworkMutationType = ArtworkMutationDeleteSuccess | ArtworkMutationFailure

union ArtworkOrEditionSetType = Artwork | EditionSet

# Insights may not be available for all Artwork Connections due to potential performance issues
type ArtworkPriceInsights {
  annualLotsSold: Int
  annualValueSoldCents: FormattedNumber

  # The annual value of the work sold "in USD "
  annualValueSoldDisplayText: String
  artistId: String
  averageSalePriceDisplayText(
    # Passes in to numeral, such as `'0.00'`
    format: String = ""
  ): String
  demandRank: Float

  # The demand rank display text of the artist and medium
  demandRankDisplayText: String

  # Return weather the artist medium is in high demand
  isHighDemand: Boolean
  lastAuctionResultDate: String
  liquidityRankDisplayText(
    # Return the liquidity rank in a formatted way (Low, medium, high or very high)
    format: String = ""
  ): String
  medianSaleOverEstimatePercentage: Float
  medianSalePriceDisplayText(
    # Passes in to numeral, such as `'0.00'`
    format: String = ""
  ): String
  medium: String
  sellThroughRate: Float
}

type ArtworkPublishedNotificationItem {
  artists: [Artist!]!
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
}

union ArtworkResult = Artwork | ArtworkError

type ArtworkSavedSearch {
  # Based on the artworks attributes (usually considered for saved searches).
  suggestedArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
}

enum ArtworkSignatureTypeEnum {
  # The artwork is hand signed by the artist
  HAND_SIGNED_BY_ARTIST

  # The artwork is not signed
  NOT_SIGNED

  # The artwork has another type of signature
  OTHER

  # The artwork is signed in the plate
  SIGNED_IN_PLATE

  # The artwork is stamped by the artist's estate
  STAMPED_BY_ARTIST_ESTATE

  # The artwork has a sticker label
  STICKER_LABEL
}

enum ArtworkSizes {
  LARGE
  MEDIUM
  SMALL
}

enum ArtworkSorts {
  AVAILABILITY_ASC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
  ICONICITY_DESC
  LAST_OFFERABLE_ACTIVITY_AT_DESC
  LAST_SAVED_AT_DESC
  MERCHANDISABILITY_DESC
  PARTNER_UPDATED_AT_DESC
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
  RECENT_SAVES_COUNT_DESC
  TITLE_ASC
  TITLE_DESC
}

type ArtworkVersion implements Node {
  # The names for the artists related to this Artwork Version
  artistNames: String

  # The artists related to this Artwork Version
  artists: [Artist]

  # The Artwork Version attribution class
  attributionClass: AttributionClass

  # Artwork condition description
  condition_description: String

  # The Artwork Version formatted date
  date: String

  # The Image id
  defaultImageID: String

  # The Artwork Version dimensions formatted for different units
  dimensions: dimensions

  # A globally unique ID.
  id: ID!

  # The image representing the Artwork Version
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # The Artwork Version medium
  medium: String

  # Artwork provenance
  provenance: String

  # Artwork title
  title: String
}

# The results for one of the requested aggregations
type ArtworksAggregationResults {
  counts: [AggregationCount]
  slice: ArtworkAggregation
}

type ArtworksCollectionsBatchUpdateCounts {
  addedToCollections: Int
  artworks: Int
  removedFromCollections: Int
}

type ArtworksCollectionsBatchUpdateFailure {
  mutationError: GravityMutationError
}

input ArtworksCollectionsBatchUpdateInput {
  # Collection ids. To which collections to add artworks.
  addToCollectionIDs: [String!]

  # Artwork ids or slugs.
  artworkIDs: [String!]!
  clientMutationId: String

  # Collection ids. From which collections to remove artworks.
  removeFromCollectionIDs: [String!]
}

type ArtworksCollectionsBatchUpdatePayload {
  clientMutationId: String
  responseOrError: ArtworksCollectionsBatchUpdateResponseOrError
}

union ArtworksCollectionsBatchUpdateResponseOrError =
    ArtworksCollectionsBatchUpdateFailure
  | ArtworksCollectionsBatchUpdateSuccess

type ArtworksCollectionsBatchUpdateSuccess {
  addedToCollections: [Collection]
  counts: ArtworksCollectionsBatchUpdateCounts
  removedFromCollections: [Collection]
}

# An artwork rail section in the home view
type ArtworksRailHomeViewSection implements GenericHomeViewSection & Node {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection

  # The component that is prescribed for this section
  component: HomeViewComponent

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

enum AssetType {
  ADDITIONAL_FILE
  IMAGE
}

# Fields of an attachment (currently from Radiation)
type Attachment {
  # Content type of file.
  contentType: String!

  # URL of attachment.
  downloadURL: String!

  # File name.
  fileName: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# Collection of fields that describe attribution class
type AttributionClass {
  # A globally unique ID.
  id: ID!
  info: String @deprecated(reason: "Prefer `shortDescription`")

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Long description (can include multiple sentences) for attribution class
  longDescription: String

  # Shortest form of attribution class display
  name: String

  # Short descriptive phrase for attribution class without punctuation as array of strings
  shortArrayDescription: [String]

  # Short descriptive phrase for attribution class without punctuation
  shortDescription: String
}

type AuctionArtworkGrid implements ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# Collector signals on a biddable auction lot
type AuctionCollectorSignals {
  # Bid count
  bidCount: Int!

  # Live bidding has started on this lot's auction
  liveBiddingStarted: Boolean!

  # Auction live bidding start time
  liveStartAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Pending auction lot end time for bidding
  lotClosesAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Lot watcher count
  lotWatcherCount: Int!

  # Lot bidding period extended due to last-minute bids
  onlineBiddingExtended: Boolean!

  # Pending auction registration end time
  registrationEndsAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
}

# In centimeters.
type AuctionLotDimensions {
  depth: Float
  height: Float
  width: Float
}

type AuctionLotEstimate {
  display: String
  high: Float
  low: Float
}

type AuctionLotImages {
  larger: Image
  thumbnail: Image
}

type AuctionLotPerformance {
  # Percentage performance over mid-estimate
  mid: String
}

type AuctionResult implements Node {
  # Be careful when querying for artist data within a connection as it can lead to performance issues.
  artist: Artist
  artistID: String!
  boughtIn: Boolean
  categoryText: String

  # Comparable auction results
  comparableAuctionResults(
    after: String
    before: String
    first: Int
    last: Int
  ): AuctionResultConnection
  currency: String
  date(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  dateText: String
  description: String
  dimensionText: String
  dimensions: AuctionLotDimensions
  estimate: AuctionLotEstimate
  externalURL: String

  # A globally unique ID.
  id: ID!
  images: AuctionLotImages

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isInArtsyAuction: Boolean!
  isUpcoming: Boolean
  location: String
  lotNumber: String
  mediumText: String
  organization: String
  performance: AuctionLotPerformance
  priceRealized: AuctionResultPriceRealized
  saleDate(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  saleDateText: String
  saleTitle: String
  slug: String
  title: String
}

# A connection to a list of items.
type AuctionResultConnection {
  aggregations: [AuctionResultsAggregationType]
  createdYearRange: YearRange

  # A list of edges.
  edges: [AuctionResultEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type AuctionResultEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: AuctionResult
}

type AuctionResultPriceRealized {
  cents: Float
  centsUSD: Float
  display(
    # Passes in to numeral, such as `'0.00'`
    format: String = ""
  ): String
  displayUSD(
    # Passes in to numeral, such as `'0.00'`
    format: String = ""
  ): String
}

enum AuctionResultSorts {
  DATE_ASC
  DATE_DESC
  ESTIMATE_AND_DATE_DESC
  PRICE_AND_DATE_DESC
}

enum AuctionResultsAggregation {
  CURRENCIES_COUNT
  LOTS_BY_CREATED_YEAR
  LOTS_BY_SALE_YEAR
  SIMPLE_PRICE_HISTOGRAM
}

# The results for one of the requested aggregations
type AuctionResultsAggregationType {
  counts: [AggregationCount]
  slice: AuctionResultsAggregation
}

# An auction lot result
type AuctionResultsByArtists {
  artistId: String
  boughtIn: Boolean!
  categoryText: String
  currency: String
  date: ISO8601DateTime
  dateText: String
  depthCm: Int
  description: String
  diameterCm: Int
  dimensionText: String
  externalUrl: String
  hammerPriceCents: BigInt
  hammerPriceCentsUsd: BigInt
  heightCm: Int
  highEstimateCents: BigInt
  highEstimateCentsUsd: BigInt
  id: ID!
  location: String
  lotNumber: String
  lowEstimateCents: BigInt
  lowEstimateCentsUsd: BigInt
  mediumText: String
  organization: String
  priceRealizedCents: BigInt
  priceRealizedCentsUsd: BigInt
  saleDate: String
  saleDateText: String
  saleOverEstimatePercentage: Float
  saleTitle: String
  title: String
  widthCm: Int
}

# The connection type for AuctionResultsByArtists.
type AuctionResultsByArtistsConnection {
  # A list of edges.
  edges: [AuctionResultsByArtistsEdge]

  # A list of nodes.
  nodes: [AuctionResultsByArtists]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type AuctionResultsByArtistsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AuctionResultsByArtists
}

enum AuctionResultsState {
  ALL
  PAST
  UPCOMING
}

enum AuctionState {
  CLOSED
  OPEN
  UPCOMING
}

type AuctionsArtsyBidder {
  id: ID!
  paddleNumber: ID!
  userId: ID
}

# an online (Artsy) bidder, or an offline bidder in the auction
union AuctionsBidder = AuctionsArtsyBidder | AuctionsOfflineBidder

# DateTime is a scalar value that represents an ISO8601 formatted date and time.
scalar AuctionsDateTime

# A permanent schedule of increments to use in for upcoming asking prices for a lot.
type AuctionsIncrementPolicy {
  changes: [AuctionsIncrementPolicyChange!]!
  createdAt: AuctionsDateTime!

  # Generate a list of asking prices across a given range.
  enumerate(
    from: Long = 0

    # Defines treatment of off-increment `from` values.
    nextIncrementRule: AuctionsNextIncrementRule = SnapToPresetIncrements
    until: Long = 0
  ): [AuctionsMoney!]!
  groupTag: ID!
  id: ID!
  initialIncrementCents: Long!
  subgroupTag: ID!
}

# Change thresholds and amounts for IncrementPolicy.
type AuctionsIncrementPolicyChange {
  increment: AuctionsMoney!
  incrementCents: Long!
  threshold: AuctionsMoney!
  thresholdCents: Long!
}

# A change in increment amount, to take effect at the given threshold.
input AuctionsIncrementPolicyChangeInput {
  incrementCents: Long!
  thresholdCents: Long!
}

# A groupTag and list of IncrementPolicySubgroups
type AuctionsIncrementPolicyGroup {
  groupTag: ID!
  subgroupTags: [ID!]!
  subgroups: [AuctionsIncrementPolicySubgroup!]!
}

type AuctionsIncrementPolicySubgroup {
  group: AuctionsIncrementPolicyGroup!
  revisions: [AuctionsIncrementPolicy!]!
  subgroupTag: ID!
}

# A user's position on a lot
type AuctionsLotStanding implements AuctionsNode {
  # The ID of an object
  id: ID!

  # whether this user has the leading bid
  isHighestBidder: Boolean!

  # The current leading bid on the lot, whether it is winning or not
  leadingBidAmount: AuctionsMoney!

  # Current lot state
  lot: AuctionsLotState!

  # Current lot state
  lotState: AuctionsLotState! @deprecated(reason: "prefer `lot`")
  rawId: String!
  saleArtwork: SaleArtwork
}

# A connection to a list of items.
type AuctionsLotStandingConnection {
  # A list of edges.
  edges: [AuctionsLotStandingEdge]

  # Information to aid in pagination.
  pageInfo: AuctionsPageInfo!
}

# An edge in a connection.
type AuctionsLotStandingEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AuctionsLotStanding!
}

# The state of a lot
type AuctionsLotState {
  # total number of actual bids placed by users on the lot
  bidCount: Int!

  # current high bid recognized on the live auction floor
  floorSellingPrice: Money

  # selling price, in minor unit, on the live auction floor
  floorSellingPriceCents: Long

  # The bidder currently winning the live floor portion of the auction
  floorWinningBidder: AuctionsBidder

  # The Gravity Lot ID.
  id: ID!

  # The Gravity Lot ID.
  internalID: ID!
  onlineAskingPrice: Money

  # asking price, in minor unit, for online bidders
  onlineAskingPriceCents: Long!

  # The bidder currently winning the online portion of the auction
  onlineSellingToBidder: AuctionsBidder

  # The current reserve status for the lot
  reserveStatus: AuctionsReserveStatus!

  # The Gravity Sale ID.
  saleId: ID!

  # current high bid
  sellingPrice: Money

  # current bid amount in minor unit, whether reserve is met or not
  sellingPriceCents: Long!

  # Whether the lot is sold, for sale or passed
  soldStatus: AuctionsSoldStatus!
}

# Represents currency units and formatting
type AuctionsMoney {
  # Formatted string version of currency amount
  displayAmount(
    # The decimal separator.
    decimalSeparator: String = "."

    # Number of decimal places for the currency.
    fractionalDigits: Int = 2

    # The 1000s separator.
    groupingSeparator: String = ","

    # Whether to show the fractional units.
    showFractionalDigits: Boolean = true
  ): String!
  units: Long!
}

# A draft schedule of increments to use in for upcoming asking prices for a lot.
type AuctionsNewIncrementPolicy {
  changes: [AuctionsIncrementPolicyChange!]!

  # A listing of increments by tier
  enumeratedIncrements: [[AuctionsMoney!]!]!
  groupTag: ID!
  id: ID
  initialIncrementCents: Long!

  # The maximum percentage change between increments (~10% is typical).
  maxPercentChange: Float!

  # The minimum percentage change between increments (~4% is typical).
  minPercentChange: Float!

  # A listing of increments by tier
  prettyPrintedIncrements(
    # Number of decimal places for the currency.
    fractionalDigits: Int = 2
  ): [String!]!
  subgroupTag: ID!

  # Any non-fatal warnings to check before committing the increment policy.
  warnings: [String!]!
}

input AuctionsNewIncrementPolicyInput {
  changes: [AuctionsIncrementPolicyChangeInput!]!
  groupTag: ID!
  id: ID
  initialIncrementCents: Long!
  subgroupTag: ID!
}

enum AuctionsNextIncrementRule {
  AddToPastValue
  SnapToPresetIncrements
}

# An object with an ID
interface AuctionsNode {
  # The id of the object.
  id: ID!
}

# An offline bidder (in the auction room)
type AuctionsOfflineBidder {
  singletonDummyField: String
}

# Information about pagination in a connection.
type AuctionsPageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

enum AuctionsReserveStatus {
  NoReserve
  ReserveMet
  ReserveNotMet
}

# The state of a sale
type AuctionsSaleState {
  # Users not allowed to participate in the sale
  bannedUsers: [AuctionsUser!]!

  # The current lot on block.
  currentLot: AuctionsLotState

  # The Gravity Sale ID.
  id: ID!

  # The Gravity Sale ID.
  internalID: ID!

  # Lot ids that had an Artsy bid that was the highest bid on the lot but did not win
  lotIdsWithHigherArtsyBidNotWon: [String!]!

  # Lot ids that had an Artsy bid that was the same max bid as the hammer price on the lot but did not win
  lotIdsWithSameArtsyBidNotWon: [String!]!

  # Lot ids without a FairWarning event
  lotIdsWithoutFairWarning: [String!]!

  # Lot ids without a FinalCall event
  lotIdsWithoutFinalCall: [String!]!

  # The lots belonging to this sale.
  lots: [AuctionsLotState!]!

  # Passed lot ids with bids from Artsy bidders
  passedLotIdsWithArtsyBids: [String!]!

  # Re-opened lots ids
  reopenedLotIds: [String!]!

  # Total Artsy GMV for the sale
  totalSoldGMVCents: Long!
}

enum AuctionsSoldStatus {
  ForSale
  Passed
  Sold
}

# An Artsy User
type AuctionsUser implements AuctionsNode {
  # The ID of an object
  id: ID!

  # The user's gravity id
  internalID: ID!
  rawId: String!

  # The user's id
  userId: ID!
}

enum AuthenticationProvider {
  APPLE
  FACEBOOK
  GOOGLE
}

enum AuthenticationStatus {
  INVALID
  LOGGED_IN
  LOGGED_OUT
}

type AuthenticationType {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  provider: AuthenticationProvider!
  uid: String!
}

type Author {
  bio(format: Format): String

  # A globally unique ID.
  id: ID!
  image: Image
  initials(length: Int = 3): String

  # A type-specific ID.
  internalID: ID!
  name: String
  twitterHandle: String
}

# Backup Two-Factor Authentication factor
type BackupSecondFactor implements SecondFactor {
  code: String!
  createdAt: ISO8601DateTime!
  disabledAt: ISO8601DateTime
  enabled: Boolean!
  enabledAt: ISO8601DateTime
  internalID: ID!
  kind: SecondFactorKind!
  updatedAt: ISO8601DateTime!
}

type BackupSecondFactors {
  secondFactors: [BackupSecondFactor!]!
}

# A list of backup second factors or errors
union BackupSecondFactorsOrErrorsUnion = BackupSecondFactors | Errors

type BankAccount {
  # Name on the bank account
  accountHolderName: String

  # Bank name
  bankName: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Last four characters of the account identifier
  last4: String!

  # Bank account type
  type: BankAccountTypes!
}

# A connection to a list of items.
type BankAccountConnection {
  # A list of edges.
  edges: [BankAccountEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type BankAccountEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: BankAccount
}

type BankAccountMutationFailure {
  mutationError: GravityMutationError
}

type BankAccountMutationSuccess {
  bankAccount: BankAccount
  bankAccountEdge: BankAccountEdge
}

union BankAccountMutationType = BankAccountMutationFailure | BankAccountMutationSuccess

enum BankAccountTypes {
  SEPA_DEBIT
  US_BANK_ACCOUNT
}

type BidIncrement {
  amount: Int
  from: Int
  to: Int
}

type BidIncrementsFormatted {
  cents: Float
  display: String
}

type Bidder implements Node {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  pin: String
  qualifiedForBidding: Boolean
  sale: Sale
  user: User
}

type BidderPosition {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  highestBid: HighestBid

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActive: Boolean
  isRetracted: Boolean
  isWinning: Boolean
  isWithBidMax: Boolean
  maxBid: BidderPositionMaxBid
  processedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  saleArtwork: SaleArtwork
  suggestedNextBid: BidderPositionSuggestedNextBid
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
}

input BidderPositionInput {
  artworkID: String!
  clientMutationId: String
  maxBidAmountCents: Float!
  saleID: String!
}

type BidderPositionMaxBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type BidderPositionPayload {
  clientMutationId: String
  result: BidderPositionResult
}

type BidderPositionResult {
  messageDescriptionMD: String
  messageHeader: String
  position: BidderPosition
  rawError: String
  status: String!
}

type BidderPositionSuggestedNextBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

# Represents non-fractional signed whole numeric values. Since the value may
# exceed the size of a 32-bit integer, it's encoded as a string.
scalar BigInt

type BulkUpdatePartnerArtworksMutationFailure {
  mutationError: GravityMutationError
}

input BulkUpdatePartnerArtworksMutationInput {
  # Whether Artsy domestic shipping should be enabled
  artsyShippingDomestic: Boolean

  # Whether Artsy international shipping should be enabled
  artsyShippingInternational: Boolean
  clientMutationId: String

  # ID of the partner
  id: String!

  # The partner location ID to assign
  location: String
}

type BulkUpdatePartnerArtworksMutationPayload {
  bulkUpdatePartnerArtworksOrError: BulkUpdatePartnerArtworksMutationType
  clientMutationId: String
}

type BulkUpdatePartnerArtworksMutationSuccess {
  skippedPartnerArtworks: BulkUpdatePartnerArtworksResponse
  updatedPartnerArtworks: BulkUpdatePartnerArtworksResponse
}

union BulkUpdatePartnerArtworksMutationType =
    BulkUpdatePartnerArtworksMutationFailure
  | BulkUpdatePartnerArtworksMutationSuccess

type BulkUpdatePartnerArtworksResponse {
  count: Int
  ids: [String]
}

type BuyersPremium {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  percent: Float
}

type CalculatedCost {
  bidAmount: Money
  buyersPremium: Money
  subtotal: Money
}

# Market Price Insights Calendar year
type CalendarYearMarketPriceInsights {
  artistId: ID
  artistName: String
  averageSalePrice: BigInt
  createdAt: ISO8601DateTime
  id: ID!
  lotsSold: BigInt
  medianSalePrice: BigInt
  medium: String
  updatedAt: ISO8601DateTime
  valueSold: BigInt
  year: String!
}

# Price Insights Calendar year
type CalendarYearPriceInsights {
  calendarYearMarketPriceInsights: [CalendarYearMarketPriceInsights!]
  medium: String!
}

# Autogenerated input type of CaptureHold
input CaptureHoldInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Globally unique ID for the hold.
  inventoryHoldId: ID!

  # Globally unique ID for the requester of the hold. Ex. Exchange Order ID.
  referenceId: String!
}

# Autogenerated return type of CaptureHold
type CaptureHoldPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  holdOrError: InventoryHoldOrErrorUnion!
}

type CareerHighlight implements Node {
  artist: Artist!
  collected: Boolean!
  group: Boolean!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  partner: Partner!
  solo: Boolean!
  venue: String!
}

type CausalityLotState {
  bidCount: Int
  floorSellingPrice: Money
  floorSellingPriceCents: Int
  internalID: String
  onlineAskingPrice: Money
  onlineAskingPriceCents: Int
  reserveStatus: String
  saleId: String
  sellingPrice: Money
  sellingPriceCents: Int
  soldStatus: String
}

type CertificateOfAuthenticityDetails {
  coaByAuthenticatingBody: Boolean
  coaByGallery: Boolean
}

type Channel {
  # A connection of articles related to a partner.
  articlesConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: ArticleSorts
  ): ArticleConnection

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID.
  internalID: ID!
  links: [ChannelLink!]!
  name: String!
  slug: String
  tagline: String
  type: ChannelType!
}

type ChannelLink {
  text: String!
  url: String!
}

enum ChannelType {
  Editorial
  Support
  Team
}

type City {
  coordinates: LatLng
  fairsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: FairSorts
    status: EventStatus
  ): FairConnection
  fullName: String!
  name: String!
  showsConnection(
    after: String
    before: String

    # Only used when status is CLOSING_SOON or UPCOMING. Number of days used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int

    # Whether to include local discovery stubs
    includeStubShows: Boolean
    last: Int
    page: Int

    # Filter shows by partner type
    partnerType: PartnerShowPartnerType
    size: Int
    sort: ShowSorts

    # Filter shows by chronological event status
    status: EventStatus = CURRENT
  ): ShowConnection
  slug: String!
  sponsoredContent: CitySponsoredContent
}

type CitySponsoredContent {
  artGuideUrl: String
  featuredShows: [Show]
  introText: String
  showsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: ShowSorts
    status: EventStatus
  ): ShowConnection
}

# A collection of artworks
type Collection {
  artworksConnection(
    after: String
    before: String
    first: Int
    forSale: Boolean
    last: Int
    page: Int

    # In USD Dollars
    priceMax: Int

    # In USD Dollars
    priceMin: Int
    sort: CollectionArtworkSorts = SAVED_AT_DESC
  ): ArtworkConnection

  # Number of artworks associated with this collection.
  artworksCount(
    # Only count visible artworks
    onlyVisible: Boolean = false
  ): Int!

  # True if this is the default collection for this user, i.e. the default Saved Artwork collection.
  default: Boolean!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Checking whether artwork is included in collection
  isSavedArtwork(artworkID: String!): Boolean!

  # Name of the collection. Has a predictable value for 'standard' collections such as Saved Artwork, My Collection, etc. Can be provided by user otherwise.
  name: String!

  # True if this collection represents artworks explicitly saved by the user, false otherwise.
  saves: Boolean!
  shareableWithPartners: Boolean!
}

enum CollectionArtworkSorts {
  POSITION_ASC
  POSITION_DESC
  SAVED_AT_ASC
  SAVED_AT_DESC
}

enum CollectionSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A connection to a list of items.
type CollectionsConnection {
  # A list of edges.
  edges: [CollectionsEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type CollectionsEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Collection
}

type CollectorProfileType implements Node {
  artsyUserSince(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  bio: String
  collectedArtworksCount: Int!
  collectorLevel: Int
  companyName: String
  companyWebsite: String
  confirmedBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  email: String
  emailConfirmed: Boolean
    @deprecated(reason: "emailConfirmed is going to be removed, use isEmailConfirmed instead")
  firstNameLastInitial: String
  followedArtistsCount: Int!
  icon: Image

  # A globally unique ID.
  id: ID!
  identityVerified: Boolean
    @deprecated(reason: "identityVerified is going to be removed, use isIdentityVerified instead")
  initials(length: Int = 3): String
  inquiryRequestsCount: Int!
  institutionalAffiliations: String
  intents: [String]
  interestsConnection(after: String, before: String, first: Int, last: Int): UserInterestConnection

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActiveBidder: Boolean
  isActiveInquirer: Boolean
  isEmailConfirmed: Boolean
  isIdentityVerified: Boolean
  isProfileComplete: Boolean
  lastUpdatePromptAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  location: MyLocation
  loyaltyApplicantAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  name: String

  # Collector's position with relevant institutions
  otherRelevantPositions: String
  owner: User!

  # User ID of the collector profile's owner
  ownerID: ID!

  # Holds information about the engagement a collector profile has with a given partner
  partnerEngagement(
    # The ID of the partner to check for engagement
    partnerID: ID!
  ): PartnerEngagement
  privacy: String
  profession: String
  professionalBuyerAppliedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  professionalBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  savedArtworksCount: Int!
  selfReportedPurchases: String

  # An artwork-specific paragraph describing the collector.
  summaryParagraph(
    # This can be specified, and is injected in a conversation context for convenience.
    artworkID: String
  ): String
  totalBidsCount: Int!
  userInterests: [UserInterest]!
    @deprecated(reason: "Use \"owner#interestsConnection\" field instead.")
}

# A connection to a list of items.
type CollectorProfileTypeConnection {
  # A list of edges.
  edges: [CollectorProfileTypeEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type CollectorProfileTypeEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: CollectorProfileType
}

type CollectorProfileUpdatePromptNotificationItem {
  collectorProfile: CollectorProfileType!
  me: Me!
}

type CollectorResume {
  buyerActivity: CommerceBuyerActivity
  collectorProfile: CollectorProfileType!

  # The Collector follows the Gallery profile
  isCollectorFollowingPartner: Boolean!

  # non-bnmo Collector's purchase history
  purchases: purchases

  # Collector's ID used to stitch buyerActivity with the Exchange schema
  userId: String!
}

# Collector signals available to the artwork
type CollectorSignals {
  auction: AuctionCollectorSignals

  # Bid count on lots open for bidding
  bidCount: Int @deprecated(reason: "Use nested field in `auction` instead")

  # Live bidding has started on this lot's auction
  liveBiddingStarted: Boolean @deprecated(reason: "Use nested field in `auction` instead")

  # Auction live bidding start time
  liveStartAt: String @deprecated(reason: "Use nested field in `auction` instead")

  # Pending auction lot end time for bidding
  lotClosesAt: String @deprecated(reason: "Use nested field in `auction` instead")

  # Lot watcher count on lots open for bidding
  lotWatcherCount: Int @deprecated(reason: "Use nested field in `auction` instead")

  # Auction lot bidding period extended due to last-minute bids
  onlineBiddingExtended: Boolean @deprecated(reason: "Use nested field in `auction` instead")

  # Partner offer available to collector
  partnerOffer: PartnerOfferToCollector

  # Pending auction registration end time
  registrationEndsAt: String @deprecated(reason: "Use nested field in `auction` instead")
}

# Represents either an action or a potential failure
union CommerceActionOrFailureUnion = CommerceOrderRequiresAction | CommerceOrderWithMutationFailure

# Autogenerated input type of AddInitialOfferToOrder
input CommerceAddInitialOfferToOrderInput {
  amountCents: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  note: String
  orderId: ID!
}

# Autogenerated return type of AddInitialOfferToOrder.
type CommerceAddInitialOfferToOrderPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# An generic error type for mutations
type CommerceApplicationError {
  # Code of this error
  code: String!

  # What caused the error
  data: String

  # Type of this error
  type: String!
}

# Autogenerated input type of ApproveOrder
input CommerceApproveOrderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  shippingContact: CommerceShippingContactAttributes
}

# Autogenerated return type of ApproveOrder.
type CommerceApproveOrderPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Bank account balance
type CommerceBankAccountBalance {
  balanceCents: Int
  currencyCode: String
}

type CommerceBuyOrder implements CommerceOrder {
  # Whether Artsy collects taxes (e.g., sales tax or VAT) on this order.
  artsyCollectsTaxes: Boolean
  artsyRemitsTaxes: Boolean
  artsyTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  artsyTotalCents: Int
  artworkDetails: String
  availablePaymentMethods: [CommercePaymentMethodEnum!]!
  bankAccountId: String
  buyer: CommerceOrderPartyUnion!
  buyerDetails: OrderParty
  buyerPhoneNumber: String
  buyerPhoneNumberCountryCode: String
  buyerProfile: CollectorProfileType
  buyerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  buyerTotalCents: Int
  code: String!
  commissionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  commissionFeeCents: Int
  commissionRate: Float
  conditionsOfSale: String
  conversation: Conversation
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  creditCard: CreditCard
  creditCardId: String
  currencyCode: String!
  displayCommissionRate: String
  displayState: CommerceOrderDisplayStateEnum!
  id: ID!
  impulseConversationId: String
  internalID: ID!
  itemsTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # Item total in cents, for Offer Orders this field reflects current offer
  itemsTotalCents: Int
  lastApprovedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastSubmittedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastTransactionFailed: Boolean
  lastTransactionFailureCode: String
  lineItems(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceLineItemConnection
  mode: CommerceOrderModeEnum
  orderHistory: [CommerceOrderEventUnion!]!
  orderUpdateState: String
  paymentMethod: CommercePaymentMethodEnum
  paymentMethodDetails: PaymentMethodUnion
  requestedFulfillment: CommerceRequestedFulfillmentUnion

  # Whether the buyer needs to complete identity verification to make this purchase.
  requireIdentityVerification: Boolean!
  seller: CommerceOrderPartyUnion!
  sellerDetails: OrderParty
  sellerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  sellerTotalCents: Int
  shippingRadius: String
  shippingTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  shippingTotalCents: Int
  source: CommerceOrderSourceEnum!
  state: CommerceOrderStateEnum!
  stateExpiresAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  stateReason: String
  stateUpdatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  taxTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  taxTotalCents: Int
  taxTypes: [CommerceTaxTypeEnum!]!
  totalListPrice(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  totalListPriceCents: Int!
  transactionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  transactionFeeCents: Int
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# Autogenerated input type of BuyerAcceptOffer
input CommerceBuyerAcceptOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!
}

# Autogenerated return type of BuyerAcceptOffer.
type CommerceBuyerAcceptOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Buyer Activity for Collector Profile
type CommerceBuyerActivity {
  totalPurchases: Int!
}

# Autogenerated input type of BuyerCounterOffer
input CommerceBuyerCounterOfferInput {
  amountCents: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  note: String
  offerId: ID!
}

# Autogenerated return type of BuyerCounterOffer.
type CommerceBuyerCounterOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

enum CommerceBuyerOfferActionEnum {
  # Buyer's offer is accepted and final
  OFFER_ACCEPTED

  # Buyer's offer accepted, needs to confirm tax and shipping
  OFFER_ACCEPTED_CONFIRM_NEEDED

  # Buyer received a counter offer
  OFFER_RECEIVED

  # Buyer received a counter, offer needs to confirm tax and shipping
  OFFER_RECEIVED_CONFIRM_NEEDED

  # Buyer's payment failed
  PAYMENT_FAILED

  # Provisional offer is accepted and tax/shipping confirmed
  PROVISIONAL_OFFER_ACCEPTED
}

# Autogenerated input type of BuyerRejectOffer
input CommerceBuyerRejectOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!
  rejectReason: CommerceCancelReasonTypeEnum
}

# Autogenerated return type of BuyerRejectOffer.
type CommerceBuyerRejectOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

enum CommerceCancelReasonTypeEnum {
  # cancelation reason is: admin_canceled
  ADMIN_CANCELED

  # cancelation reason is: admin_failed_review
  ADMIN_FAILED_REVIEW

  # cancelation reason is: buyer_lapsed
  BUYER_LAPSED

  # cancelation reason is: buyer_rejected
  BUYER_REJECTED

  # cancelation reason is: funds_not_received
  FUNDS_NOT_RECEIVED

  # cancelation reason is: seller_lapsed
  SELLER_LAPSED

  # cancelation reason is: seller_rejected
  SELLER_REJECTED

  # cancelation reason is: seller_rejected_artwork_unavailable
  SELLER_REJECTED_ARTWORK_UNAVAILABLE

  # cancelation reason is: seller_rejected_offer_too_low
  SELLER_REJECTED_OFFER_TOO_LOW

  # cancelation reason is: seller_rejected_other
  SELLER_REJECTED_OTHER

  # cancelation reason is: seller_rejected_shipping_unavailable
  SELLER_REJECTED_SHIPPING_UNAVAILABLE
}

# Autogenerated input type of ConfirmFulfillment
input CommerceConfirmFulfillmentInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of ConfirmFulfillment.
type CommerceConfirmFulfillmentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of ConfirmPickup
input CommerceConfirmPickupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of ConfirmPickup.
type CommerceConfirmPickupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of CreateBankDebitSetupForOrder
input CommerceCreateBankDebitSetupForOrderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of CreateBankDebitSetupForOrder.
type CommerceCreateBankDebitSetupForOrderPayload {
  # A union of action data and failure
  actionOrError: CommerceActionOrFailureUnion!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateInquiryOfferOrderWithArtwork
input CommerceCreateInquiryOfferOrderWithArtworkInput {
  # Artwork Id
  artworkId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # EditionSet Id
  editionSetId: String

  # When set to false, we will create a new order. Otherwise if current user has
  # submitted orders on same artwork/edition with same quantity, we will return that
  findActiveOrCreate: Boolean = true

  # Impulse conversation id corresponding to an order.
  impulseConversationId: String!

  # Number of items in the line item, default is 1
  quantity: Int
}

# Autogenerated return type of CreateInquiryOfferOrderWithArtwork.
type CommerceCreateInquiryOfferOrderWithArtworkPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure. If find_active_or_create is not false, it will
  # return existing submitted order for current user if exists, otherwise it will
  # return newly created order
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of CreateInquiryOrderWithArtwork
input CommerceCreateInquiryOrderWithArtworkInput {
  # Artwork Id
  artworkId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # EditionSet Id
  editionSetId: String

  # Impulse conversation id corresponding to an order.
  impulseConversationId: String!

  # Number of items in the line item
  quantity: Int
}

# Autogenerated return type of CreateInquiryOrderWithArtwork.
type CommerceCreateInquiryOrderWithArtworkPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of CreateOfferOrderWithArtwork
input CommerceCreateOfferOrderWithArtworkInput {
  # Artwork Id
  artworkId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # EditionSet Id
  editionSetId: String

  # When set to false, we will create a new order. Otherwise if current user has
  # submitted orders on same artwork/edition with same quantity, we will return that
  findActiveOrCreate: Boolean = true

  # PartnerOffer Id
  partnerOfferId: String

  # Number of items in the line item, default is 1
  quantity: Int
}

# Autogenerated return type of CreateOfferOrderWithArtwork.
type CommerceCreateOfferOrderWithArtworkPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure. If find_active_or_create is not false, it will
  # return existing submitted order for current user if exists, otherwise it will
  # return newly created order
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of CreateOrderWithArtwork
input CommerceCreateOrderWithArtworkInput {
  # Artwork Id
  artworkId: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # EditionSet Id
  editionSetId: String

  # Number of items in the line item
  quantity: Int
}

# Autogenerated return type of CreateOrderWithArtwork.
type CommerceCreateOrderWithArtworkPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of CreatePartnerOfferOrder
input CommerceCreatePartnerOfferOrderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # EditionSet Id
  editionSetId: String

  # Impulse conversation id corresponding to an order.
  impulseConversationId: String

  # PartnerOffer Id
  partnerOfferId: String!

  # Number of items in the line item
  quantity: Int
}

# Autogenerated return type of CreatePartnerOfferOrder.
type CommerceCreatePartnerOfferOrderPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Date in YYYY-MM-DD format
scalar CommerceDate

# An ISO 8601 datetime
scalar CommerceDateTime

enum CommerceEeiFormStatusEnum {
  # approved
  APPROVED

  # cleared
  CLEARED

  # pending
  PENDING

  # rejected
  REJECTED

  # submitted
  SUBMITTED
}

interface CommerceEventInterface {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# Autogenerated input type of FixFailedPayment
input CommerceFixFailedPaymentInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  creditCardId: String!
  offerId: ID
  orderId: ID
}

# Autogenerated return type of FixFailedPayment.
type CommerceFixFailedPaymentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of FulfillAtOnce
input CommerceFulfillAtOnceInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  fulfillment: CommerceFulfillmentAttributes!
  id: ID!
}

# Autogenerated return type of FulfillAtOnce.
type CommerceFulfillAtOncePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# A Fulfillment for an order
type CommerceFulfillment {
  courier: String!
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  estimatedDelivery(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  id: ID!
  internalID: ID!
  notes: String
  trackingId: String
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# Attributes of a Fulfillment
input CommerceFulfillmentAttributes {
  courier: String!
  estimatedDelivery: CommerceDate
  notes: String
  trackingId: String
}

# The connection type for Fulfillment.
type CommerceFulfillmentConnection {
  # A list of edges.
  edges: [CommerceFulfillmentEdge]

  # A list of nodes.
  nodes: [CommerceFulfillment]

  # Information to aid in pagination.
  pageInfo: CommercePageInfo!
}

# An edge in a connection.
type CommerceFulfillmentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CommerceFulfillment
}

# A Line Item
type CommerceLineItem {
  artwork: Artwork
  artworkId: String!
  artworkOrEditionSet: ArtworkOrEditionSetType
  artworkVersion: ArtworkVersion
  artworkVersionId: String!
  commissionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  commissionFeeCents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  editionSetId: String
  fulfillments(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceFulfillmentConnection
  id: ID!
  internalID: ID!
  listPrice(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  listPriceCents: Int!
  order: CommerceOrder!
  priceCents: Int! @deprecated(reason: "switch to use listPriceCents")
  quantity: Int!
  selectedShippingQuote: CommerceShippingQuote
  shipment: CommerceShipment
  shippingQuoteOptions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceShippingQuoteConnection
  shippingTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  shippingTotalCents: Int
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# The connection type for LineItem.
type CommerceLineItemConnection {
  # A list of edges.
  edges: [CommerceLineItemEdge]

  # A list of nodes.
  nodes: [CommerceLineItem]

  # Information to aid in pagination.
  pageInfo: CommercePageInfo!
}

# An edge in a connection.
type CommerceLineItemEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CommerceLineItem
}

# An Offer
type CommerceOffer {
  amount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  amountCents: Int!
  buyerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  buyerTotalCents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  creatorId: String!
  currencyCode: String!

  # True when this offer fills in the missing fees from the previous one
  definesTotal: Boolean!
  from: CommerceOrderPartyUnion!
  fromDetails: OrderParty
  fromParticipant: CommerceOrderParticipantEnum

  # True when a all the fees (shipping/tax) were calculated for the offer
  hasDefiniteTotal: Boolean!
  id: ID!
  internalID: ID!
  note: String

  # Only false when previous offer has the same amount.
  offerAmountChanged: Boolean!
  order: CommerceOrder!
  respondsTo: CommerceOffer
  shippingTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  shippingTotalCents: Int
  submittedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  taxTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  taxTotalCents: Int
}

# The connection type for Offer.
type CommerceOfferConnection {
  # A list of edges.
  edges: [CommerceOfferEdge]

  # A list of nodes.
  nodes: [CommerceOffer]

  # Information to aid in pagination.
  pageInfo: CommercePageInfo!
}

# An edge in a connection.
type CommerceOfferEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CommerceOffer
}

type CommerceOfferOrder implements CommerceOrder {
  # Whether Artsy collects taxes (e.g., sales tax or VAT) on this order.
  artsyCollectsTaxes: Boolean
  artsyRemitsTaxes: Boolean
  artsyTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  artsyTotalCents: Int
  artworkDetails: String
  availablePaymentMethods: [CommercePaymentMethodEnum!]!
  awaitingResponseFrom: CommerceOrderParticipantEnum
  bankAccountId: String
  buyer: CommerceOrderPartyUnion!

  # Type of action buyer needs to perform in response to the offer
  buyerAction: CommerceBuyerOfferActionEnum
  buyerDetails: OrderParty
  buyerPhoneNumber: String
  buyerPhoneNumberCountryCode: String
  buyerProfile: CollectorProfileType
  buyerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  buyerTotalCents: Int
  code: String!
  commissionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  commissionFeeCents: Int
  commissionRate: Float
  conditionsOfSale: String
  conversation: Conversation
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  creditCard: CreditCard
  creditCardId: String
  currencyCode: String!
  displayCommissionRate: String
  displayState: CommerceOrderDisplayStateEnum!
  id: ID!
  impulseConversationId: String
  internalID: ID!
  isInquiryOrder: Boolean!
  itemsTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # Item total in cents, for Offer Orders this field reflects current offer
  itemsTotalCents: Int
  lastApprovedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Last submitted offer
  lastOffer: CommerceOffer
  lastSubmittedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastTransactionFailed: Boolean
  lastTransactionFailureCode: String
  lineItems(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceLineItemConnection
  mode: CommerceOrderModeEnum
  myLastOffer: CommerceOffer
  offerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  offers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int
    fromId: String
    fromType: String

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceOfferConnection
  orderHistory: [CommerceOrderEventUnion!]!
  orderUpdateState: String
  paymentMethod: CommercePaymentMethodEnum
  paymentMethodDetails: PaymentMethodUnion
  requestedFulfillment: CommerceRequestedFulfillmentUnion

  # Whether the buyer needs to complete identity verification to make this purchase.
  requireIdentityVerification: Boolean!
  seller: CommerceOrderPartyUnion!
  sellerDetails: OrderParty
  sellerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  sellerTotalCents: Int
  shippingRadius: String
  shippingTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  shippingTotalCents: Int
  source: CommerceOrderSourceEnum!
  state: CommerceOrderStateEnum!
  stateExpiresAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  stateReason: String
  stateUpdatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  taxTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  taxTotalCents: Int
  taxTypes: [CommerceTaxTypeEnum!]!
  totalListPrice(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  totalListPriceCents: Int!
  transactionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  transactionFeeCents: Int
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

type CommerceOfferSubmittedEvent implements CommerceEventInterface {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  offer: CommerceOffer!
}

# Order
interface CommerceOrder {
  # Whether Artsy collects taxes (e.g., sales tax or VAT) on this order.
  artsyCollectsTaxes: Boolean
  artsyRemitsTaxes: Boolean
  artsyTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  artsyTotalCents: Int
  artworkDetails: String
  availablePaymentMethods: [CommercePaymentMethodEnum!]!
  bankAccountId: String
  buyer: CommerceOrderPartyUnion!
  buyerDetails: OrderParty
  buyerPhoneNumber: String
  buyerPhoneNumberCountryCode: String
  buyerProfile: CollectorProfileType
  buyerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  buyerTotalCents: Int
  code: String!
  commissionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  commissionFeeCents: Int
  commissionRate: Float
  conditionsOfSale: String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  creditCard: CreditCard
  creditCardId: String
  currencyCode: String!
  displayCommissionRate: String
  displayState: CommerceOrderDisplayStateEnum!
  id: ID!
  impulseConversationId: String
  internalID: ID!
  itemsTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # Item total in cents, for Offer Orders this field reflects current offer
  itemsTotalCents: Int
  lastApprovedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastSubmittedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  lastTransactionFailed: Boolean
  lastTransactionFailureCode: String
  lineItems(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommerceLineItemConnection
  mode: CommerceOrderModeEnum
  orderHistory: [CommerceOrderEventUnion!]!
  orderUpdateState: String
  paymentMethod: CommercePaymentMethodEnum
  paymentMethodDetails: PaymentMethodUnion
  requestedFulfillment: CommerceRequestedFulfillmentUnion

  # Whether the buyer needs to complete identity verification to make this purchase.
  requireIdentityVerification: Boolean!
  seller: CommerceOrderPartyUnion!
  sellerDetails: OrderParty
  sellerTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  sellerTotalCents: Int
  shippingRadius: String
  shippingTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  shippingTotalCents: Int
  source: CommerceOrderSourceEnum!
  state: CommerceOrderStateEnum!
  stateExpiresAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  stateReason: String
  stateUpdatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  taxTotal(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  taxTotalCents: Int
  taxTypes: [CommerceTaxTypeEnum!]!
  totalListPrice(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  totalListPriceCents: Int!
  transactionFee(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  transactionFeeCents: Int
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# Order Action data
type CommerceOrderActionData {
  clientSecret: String!
}

# Fields to sort by
enum CommerceOrderConnectionSortEnum {
  # Sort by the timestamp the state of the order expires at in ascending order
  STATE_EXPIRES_AT_ASC

  # Sort by the timestamp the state of the order expires at in descending order
  STATE_EXPIRES_AT_DESC

  # Sort by the timestamp the state of order was last updated in ascending order
  STATE_UPDATED_AT_ASC

  # Sort by the timestamp the state of order was last updated in descending order
  STATE_UPDATED_AT_DESC

  # Sort by the timestamp the order was last updated in ascending order
  UPDATED_AT_ASC

  # Sort by the timestamp the order was last updated in descending order
  UPDATED_AT_DESC
}

# The connection type for Order.
type CommerceOrderConnectionWithTotalCount {
  # A list of edges.
  edges: [CommerceOrderEdge]

  # A list of nodes.
  nodes: [CommerceOrder]
  pageCursors: CommercePageCursors

  # Information to aid in pagination.
  pageInfo: CommercePageInfo!
  totalCount: Int
  totalPages: Int
}

enum CommerceOrderDisplayStateEnum {
  # order is abandoned by buyer and never submitted
  ABANDONED

  # order is approved by seller
  APPROVED

  # order is canceled
  CANCELED

  # order is fulfilled by seller
  FULFILLED

  # order has been collected and is with shipper
  IN_TRANSIT

  # order is still pending submission by buyer
  PENDING

  # order is approved but not yet sent out
  PROCESSING

  # order approval is processing and will be updated when complete
  PROCESSING_APPROVAL

  # order is refunded after being approved or fulfilled
  REFUNDED

  # order is submitted by buyer
  SUBMITTED
}

# An edge in a connection.
type CommerceOrderEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CommerceOrder
}

# Represents either a state change or new offer
union CommerceOrderEventUnion = CommerceOfferSubmittedEvent | CommerceOrderStateChangedEvent

enum CommerceOrderFulfillmentTypeEnum {
  # fulfillment type is: pickup
  PICKUP

  # fulfillment type is: ship
  SHIP

  # fulfillment type is: ship_arta
  SHIP_ARTA
}

enum CommerceOrderModeEnum {
  # Buy Order
  BUY

  # Offer Order
  OFFER
}

# Represents either a resolved Order or a potential failure
union CommerceOrderOrFailureUnion =
    CommerceOrderRequiresAction
  | CommerceOrderWithMutationFailure
  | CommerceOrderWithMutationSuccess

enum CommerceOrderParticipantEnum {
  # Participant on the buyer side
  BUYER

  # Participant on the seller side
  SELLER
}

# Represents either a partner or a user
union CommerceOrderPartyUnion = CommercePartner | CommerceUser

# Data reflecting actions required
type CommerceOrderRequiresAction {
  # Data related to action needed
  actionData: CommerceOrderActionData!
}

enum CommerceOrderSourceEnum {
  # The order was originated on the artwork page
  artwork_page

  # The order was originated on a conversation
  inquiry

  # The order was originated from a partner offer
  partner_offer

  # The order was originated from a private sale
  private_sale
}

type CommerceOrderStateChangedEvent implements CommerceEventInterface {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  orderUpdateState: String
  state: CommerceOrderStateEnum!
  stateReason: String
}

enum CommerceOrderStateEnum {
  # order is abandoned by buyer and never submitted
  ABANDONED

  # order is approved by seller
  APPROVED

  # order is canceled
  CANCELED

  # order is fulfilled by seller
  FULFILLED

  # order is undergoing review by Artsy admins
  IN_REVIEW

  # order is still pending submission by buyer
  PENDING

  # order approval is processing and will be updated when complete
  PROCESSING_APPROVAL

  # order is refunded after being approved or fulfilled
  REFUNDED

  # order is submitted by buyer
  SUBMITTED
}

# An error response for changes to an order
type CommerceOrderWithMutationFailure {
  error: CommerceApplicationError!
}

# A successfully returned order type
type CommerceOrderWithMutationSuccess {
  order: CommerceOrder!
}

type CommercePageCursor {
  # first cursor on the page
  cursor: String!

  # is this the current page?
  isCurrent: Boolean!

  # page number out of totalPages
  page: Int!
}

type CommercePageCursors {
  around: [CommercePageCursor!]!

  # optional, may be included in field around
  first: CommercePageCursor

  # optional, may be included in field around
  last: CommercePageCursor
  previous: CommercePageCursor
}

# Information about pagination in a connection.
type CommercePageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

type CommercePartner {
  id: String!
  type: String!
}

enum CommercePaymentMethodEnum {
  # Credit Card
  CREDIT_CARD

  # SEPA
  SEPA_DEBIT

  # US Bank Account
  US_BANK_ACCOUNT

  # Wire Transfer
  WIRE_TRANSFER
}

type CommercePickup {
  fulfillmentType: String!
  phoneNumber: String
}

# Represents either a shipping information or pickup
union CommerceRequestedFulfillmentUnion = CommercePickup | CommerceShip | CommerceShipArta

# Autogenerated input type of SelectShippingOption
input CommerceSelectShippingOptionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  selectedShippingQuoteId: ID!
}

# Autogenerated return type of SelectShippingOption.
type CommerceSelectShippingOptionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SellerAcceptOffer
input CommerceSellerAcceptOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!
  shippingContact: CommerceShippingContactAttributes
}

# Autogenerated return type of SellerAcceptOffer.
type CommerceSellerAcceptOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SellerAcceptProvisionalOffer
input CommerceSellerAcceptProvisionalOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!

  # Shipping info belonging to this specific order. It overrides the defined shipping costs of the artwork.
  shippingTotalCents: Int
}

# Autogenerated return type of SellerAcceptProvisionalOffer.
type CommerceSellerAcceptProvisionalOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SellerCounterOffer
input CommerceSellerCounterOfferInput {
  amountCents: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  note: String
  offerId: ID!
  shippingContact: CommerceShippingContactAttributes

  # Shipping info belonging to this specific order. It overrides the defined shipping costs of the artwork.
  shippingTotalCents: Int
}

# Autogenerated return type of SellerCounterOffer.
type CommerceSellerCounterOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SellerRejectOffer
input CommerceSellerRejectOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!
  rejectReason: CommerceCancelReasonTypeEnum
}

# Autogenerated return type of SellerRejectOffer.
type CommerceSellerRejectOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SetPaymentByStripeIntent
input CommerceSetPaymentByStripeIntentInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  oneTimeUse: Boolean = false
  setupIntentId: String!
}

# Autogenerated return type of SetPaymentByStripeIntent.
type CommerceSetPaymentByStripeIntentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SetPayment
input CommerceSetPaymentInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  paymentMethod: CommercePaymentMethodEnum!
  paymentMethodId: String
}

# Autogenerated return type of SetPayment.
type CommerceSetPaymentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SetShipping
input CommerceSetShippingInput {
  addressVerifiedBy: CommerceShippingAddressVerifiedByEnum

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  fulfillmentType: CommerceOrderFulfillmentTypeEnum!
  id: ID!
  phoneNumber: String
  phoneNumberCountryCode: String
  shipping: CommerceShippingAttributes
}

# Autogenerated return type of SetShipping.
type CommerceSetShippingPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

type CommerceShip {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  name: String
  phoneNumber: String
  postalCode: String
  region: String
}

type CommerceShipArta {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  name: String
  phoneNumber: String
  postalCode: String
  region: String
}

# A shipment
type CommerceShipment {
  bookedAt: String
  carrierName: String
  contactEmail: String
  contactName: String
  contactPhone: String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  deliveryEnd(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  deliveryStart(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  deliveryWindowModifier: String
  eeiFormStatus: CommerceEeiFormStatusEnum
  estimatedDeliveryWindow: String
  estimatedPickupWindow: String
  id: ID!
  labelUrl: String
  pickupEnd(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  pickupStart(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  pickupWindowModifier: String
  priceCents: Int!
  priceCurrency: String!
  status: String
  trackingNumber: String
  trackingUrl: String
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

enum CommerceShippingAddressVerifiedByEnum {
  # Address was verified by ARTSY
  ARTSY

  # Address was verified by the user
  USER
}

# Shipping information
input CommerceShippingAttributes {
  addressLine1: String
  addressLine2: String
  city: String
  country: String
  name: String
  phoneNumber: String
  postalCode: String
  region: String
}

# Shipping contact information
input CommerceShippingContactAttributes {
  email: String!
  name: String!
  phone: String!
}

# A shipping quote
type CommerceShippingQuote {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
  currencyCode: String!
  displayName: String!
  id: ID!
  isSelected: Boolean!
  name: String
  price(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  priceCents: Int!
  priceCurrency: String!
  tier: String!
  typeName: String!
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String!
}

# The connection type for ShippingQuote.
type CommerceShippingQuoteConnection {
  # A list of edges.
  edges: [CommerceShippingQuoteEdge]

  # A list of nodes.
  nodes: [CommerceShippingQuote]

  # Information to aid in pagination.
  pageInfo: CommercePageInfo!
}

# An edge in a connection.
type CommerceShippingQuoteEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CommerceShippingQuote
}

# Autogenerated input type of SubmitOrder
input CommerceSubmitOrderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of SubmitOrder.
type CommerceSubmitOrderPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SubmitOrderWithOffer
input CommerceSubmitOrderWithOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  confirmedSetupIntentId: String
  offerId: ID!
}

# Autogenerated return type of SubmitOrderWithOffer.
type CommerceSubmitOrderWithOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

# Autogenerated input type of SubmitPendingOffer
input CommerceSubmitPendingOfferInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  offerId: ID!
}

# Autogenerated return type of SubmitPendingOffer.
type CommerceSubmitPendingOfferPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

enum CommerceTaxTypeEnum {
  # U.S. sales tax.
  SALES_TAX

  # Value-added tax.
  VAT
}

# Autogenerated input type of UpdateImpulseConversationId
input CommerceUpdateImpulseConversationIdInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  impulseConversationId: String!
  orderId: ID!
}

# Autogenerated return type of UpdateImpulseConversationId.
type CommerceUpdateImpulseConversationIdPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # A union of success/failure
  orderOrError: CommerceOrderOrFailureUnion!
}

type CommerceUser {
  id: String!
}

type ConditionReportRequest {
  internalID: ID!
  saleArtworkID: ID
  userID: ID
}

# Autogenerated input type of ConfirmPassword
input ConfirmPasswordInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # User password to confirm.
  password: String!
}

# Autogenerated return type of ConfirmPassword
type ConfirmPasswordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  valid: Boolean!
}

# Consignment
type Consignment {
  currency: String

  # Uniq ID for this consignment
  id: ID!
  internalID: ID
  saleDate: String
  saleName: String
  salePriceCents: Int
  state: ConsignmentState
  submission: ConsignmentSubmission!
  submissionID: ID
  submissionId: ID!
}

enum ConsignmentAttributionClass {
  LIMITED_EDITION
  OPEN_EDITION
  UNIQUE
  UNKNOWN_EDITION
}

# The connection type for Consignment.
type ConsignmentConnection {
  # A list of edges.
  edges: [ConsignmentEdge]

  # A list of nodes.
  nodes: [Consignment]
  pageCursors: ConsignmentPageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type ConsignmentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Consignment
}

type ConsignmentInquiry {
  # Email of inquirer
  email: String!

  # id of the ConsignmentInquiry
  internalID: Int!

  # Message of the inquirer
  message: String!

  # Name of the inquirer
  name: String!

  # Phone number of the inquirer
  phoneNumber: String

  # An optional email from a member of the Collector Services team to whom the request was sent
  recipientEmail: String

  # gravity user id if user is logged in
  userId: String
}

type ConsignmentInquiryMutationError {
  error: String
  message: String!
  statusCode: Int
  type: String
}

type ConsignmentInquiryMutationFailure {
  mutationError: ConsignmentInquiryMutationError
}

type ConsignmentInquiryMutationSuccess {
  consignmentInquiry: ConsignmentInquiry
}

# Consignment Offer
type ConsignmentOffer {
  commissionPercentWhole: Int
  createdAt: ISO8601DateTime
  createdById: ID
  currency: String
  deadlineToConsign: String
  highEstimateAmount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  highEstimateCents: Int

  # Uniq ID for this offer
  id: ID!
  insuranceInfo: String
  lowEstimateAmount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  lowEstimateCents: Int
  notes: String
  offerType: String
  otherFeesInfo: String
  partnerInfo: String
  photographyInfo: String
  saleDate: String
  saleLocation: String
  saleName: String
  shippingInfo: String
  startingBidCents: Int
  state: String
  submission: ConsignmentSubmission!
}

# The connection type for Offer.
type ConsignmentOfferConnection {
  # A list of edges.
  edges: [ConsignmentOfferEdge]

  # A list of nodes.
  nodes: [ConsignmentOffer]
  pageCursors: ConsignmentPageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type ConsignmentOfferEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: ConsignmentOffer
}

enum ConsignmentOfferSort {
  # sort by commission_percent in ascending order
  COMMISSION_PERCENT_ASC

  # sort by commission_percent in descending order
  COMMISSION_PERCENT_DESC

  # sort by consigned_at in ascending order
  CONSIGNED_AT_ASC

  # sort by consigned_at in descending order
  CONSIGNED_AT_DESC

  # sort by created_at in ascending order
  CREATED_AT_ASC

  # sort by created_at in descending order
  CREATED_AT_DESC

  # sort by created_by_id in ascending order
  CREATED_BY_ID_ASC

  # sort by created_by_id in descending order
  CREATED_BY_ID_DESC

  # sort by currency in ascending order
  CURRENCY_ASC

  # sort by currency in descending order
  CURRENCY_DESC

  # sort by deadline_to_consign in ascending order
  DEADLINE_TO_CONSIGN_ASC

  # sort by deadline_to_consign in descending order
  DEADLINE_TO_CONSIGN_DESC

  # sort by high_estimate_cents in ascending order
  HIGH_ESTIMATE_CENTS_ASC

  # sort by high_estimate_cents in descending order
  HIGH_ESTIMATE_CENTS_DESC

  # sort by id in ascending order
  ID_ASC

  # sort by id in descending order
  ID_DESC

  # sort by insurance_info in ascending order
  INSURANCE_INFO_ASC

  # sort by insurance_info in descending order
  INSURANCE_INFO_DESC

  # sort by low_estimate_cents in ascending order
  LOW_ESTIMATE_CENTS_ASC

  # sort by low_estimate_cents in descending order
  LOW_ESTIMATE_CENTS_DESC

  # sort by notes in ascending order
  NOTES_ASC

  # sort by notes in descending order
  NOTES_DESC

  # sort by offer_responses_count in ascending order
  OFFER_RESPONSES_COUNT_ASC

  # sort by offer_responses_count in descending order
  OFFER_RESPONSES_COUNT_DESC

  # sort by offer_type in ascending order
  OFFER_TYPE_ASC

  # sort by offer_type in descending order
  OFFER_TYPE_DESC

  # sort by other_fees_info in ascending order
  OTHER_FEES_INFO_ASC

  # sort by other_fees_info in descending order
  OTHER_FEES_INFO_DESC

  # sort by override_email in ascending order
  OVERRIDE_EMAIL_ASC

  # sort by override_email in descending order
  OVERRIDE_EMAIL_DESC

  # sort by partner_info in ascending order
  PARTNER_INFO_ASC

  # sort by partner_info in descending order
  PARTNER_INFO_DESC

  # sort by partner_submission_id in ascending order
  PARTNER_SUBMISSION_ID_ASC

  # sort by partner_submission_id in descending order
  PARTNER_SUBMISSION_ID_DESC

  # sort by photography_info in ascending order
  PHOTOGRAPHY_INFO_ASC

  # sort by photography_info in descending order
  PHOTOGRAPHY_INFO_DESC

  # sort by price_cents in ascending order
  PRICE_CENTS_ASC

  # sort by price_cents in descending order
  PRICE_CENTS_DESC

  # sort by reference_id in ascending order
  REFERENCE_ID_ASC

  # sort by reference_id in descending order
  REFERENCE_ID_DESC

  # sort by rejected_at in ascending order
  REJECTED_AT_ASC

  # sort by rejected_at in descending order
  REJECTED_AT_DESC

  # sort by rejected_by in ascending order
  REJECTED_BY_ASC

  # sort by rejected_by in descending order
  REJECTED_BY_DESC

  # sort by rejection_note in ascending order
  REJECTION_NOTE_ASC

  # sort by rejection_note in descending order
  REJECTION_NOTE_DESC

  # sort by rejection_reason in ascending order
  REJECTION_REASON_ASC

  # sort by rejection_reason in descending order
  REJECTION_REASON_DESC

  # sort by review_started_at in ascending order
  REVIEW_STARTED_AT_ASC

  # sort by review_started_at in descending order
  REVIEW_STARTED_AT_DESC

  # sort by sale_date in ascending order
  SALE_DATE_ASC

  # sort by sale_date in descending order
  SALE_DATE_DESC

  # sort by sale_location in ascending order
  SALE_LOCATION_ASC

  # sort by sale_location in descending order
  SALE_LOCATION_DESC

  # sort by sale_name in ascending order
  SALE_NAME_ASC

  # sort by sale_name in descending order
  SALE_NAME_DESC

  # sort by sale_period_end in ascending order
  SALE_PERIOD_END_ASC

  # sort by sale_period_end in descending order
  SALE_PERIOD_END_DESC

  # sort by sale_period_start in ascending order
  SALE_PERIOD_START_ASC

  # sort by sale_period_start in descending order
  SALE_PERIOD_START_DESC

  # sort by sent_at in ascending order
  SENT_AT_ASC

  # sort by sent_at in descending order
  SENT_AT_DESC

  # sort by sent_by in ascending order
  SENT_BY_ASC

  # sort by sent_by in descending order
  SENT_BY_DESC

  # sort by shipping_info in ascending order
  SHIPPING_INFO_ASC

  # sort by shipping_info in descending order
  SHIPPING_INFO_DESC

  # sort by starting_bid_cents in ascending order
  STARTING_BID_CENTS_ASC

  # sort by starting_bid_cents in descending order
  STARTING_BID_CENTS_DESC

  # sort by state in ascending order
  STATE_ASC

  # sort by state in descending order
  STATE_DESC

  # sort by submission_id in ascending order
  SUBMISSION_ID_ASC

  # sort by submission_id in descending order
  SUBMISSION_ID_DESC

  # sort by updated_at in ascending order
  UPDATED_AT_ASC

  # sort by updated_at in descending order
  UPDATED_AT_DESC
}

type ConsignmentPageCursor {
  # first cursor on the page
  cursor: String!

  # is this the current page?
  isCurrent: Boolean!

  # page number out of totalPages
  page: Int!
}

type ConsignmentPageCursors {
  around: [ConsignmentPageCursor!]!

  # optional, may be included in field around
  first: ConsignmentPageCursor

  # optional, may be included in field around
  last: ConsignmentPageCursor
  previous: ConsignmentPageCursor
}

enum ConsignmentSort {
  # sort by accepted_offer_id in ascending order
  ACCEPTED_OFFER_ID_ASC

  # sort by accepted_offer_id in descending order
  ACCEPTED_OFFER_ID_DESC

  # sort by artsy_commission_percent in ascending order
  ARTSY_COMMISSION_PERCENT_ASC

  # sort by artsy_commission_percent in descending order
  ARTSY_COMMISSION_PERCENT_DESC

  # sort by canceled_reason in ascending order
  CANCELED_REASON_ASC

  # sort by canceled_reason in descending order
  CANCELED_REASON_DESC

  # sort by created_at in ascending order
  CREATED_AT_ASC

  # sort by created_at in descending order
  CREATED_AT_DESC

  # sort by currency in ascending order
  CURRENCY_ASC

  # sort by currency in descending order
  CURRENCY_DESC

  # sort by id in ascending order
  ID_ASC

  # sort by id in descending order
  ID_DESC

  # sort by invoice_number in ascending order
  INVOICE_NUMBER_ASC

  # sort by invoice_number in descending order
  INVOICE_NUMBER_DESC

  # sort by notes in ascending order
  NOTES_ASC

  # sort by notes in descending order
  NOTES_DESC

  # sort by notified_at in ascending order
  NOTIFIED_AT_ASC

  # sort by notified_at in descending order
  NOTIFIED_AT_DESC

  # sort by partner_commission_percent in ascending order
  PARTNER_COMMISSION_PERCENT_ASC

  # sort by partner_commission_percent in descending order
  PARTNER_COMMISSION_PERCENT_DESC

  # sort by partner_id in ascending order
  PARTNER_ID_ASC

  # sort by partner_id in descending order
  PARTNER_ID_DESC

  # sort by partner_invoiced_at in ascending order
  PARTNER_INVOICED_AT_ASC

  # sort by partner_invoiced_at in descending order
  PARTNER_INVOICED_AT_DESC

  # sort by partner_paid_at in ascending order
  PARTNER_PAID_AT_ASC

  # sort by partner_paid_at in descending order
  PARTNER_PAID_AT_DESC

  # sort by reference_id in ascending order
  REFERENCE_ID_ASC

  # sort by reference_id in descending order
  REFERENCE_ID_DESC

  # sort by sale_date in ascending order
  SALE_DATE_ASC

  # sort by sale_date in descending order
  SALE_DATE_DESC

  # sort by sale_location in ascending order
  SALE_LOCATION_ASC

  # sort by sale_location in descending order
  SALE_LOCATION_DESC

  # sort by sale_lot_number in ascending order
  SALE_LOT_NUMBER_ASC

  # sort by sale_lot_number in descending order
  SALE_LOT_NUMBER_DESC

  # sort by sale_name in ascending order
  SALE_NAME_ASC

  # sort by sale_name in descending order
  SALE_NAME_DESC

  # sort by sale_price_cents in ascending order
  SALE_PRICE_CENTS_ASC

  # sort by sale_price_cents in descending order
  SALE_PRICE_CENTS_DESC

  # sort by state in ascending order
  STATE_ASC

  # sort by state in descending order
  STATE_DESC

  # sort by submission_id in ascending order
  SUBMISSION_ID_ASC

  # sort by submission_id in descending order
  SUBMISSION_ID_DESC

  # sort by updated_at in ascending order
  UPDATED_AT_ASC

  # sort by updated_at in descending order
  UPDATED_AT_DESC
}

enum ConsignmentState {
  BOUGHT_IN
  CANCELLED
  OPEN
  SOLD
}

# Consignment Submission
type ConsignmentSubmission {
  additionalInfo: String
  artist: Artist
  artistId: String!
  assets(assetType: [AssetType!] = []): [ConsignmentSubmissionCategoryAsset]
  attributionClass: ConsignmentAttributionClass
  authenticityCertificate: Boolean
  category: String
  createdAt: ISO8601DateTime
  currency: String
  depth: String
  dimensionsMetric: String
  edition: String
  editionNumber: String
  editionSize: String

  # UUID visible to users
  externalId: ID!
  height: String

  # Uniq ID for this submission
  id: ID!
  internalID: ID
  locationAddress: String
  locationAddress2: String
  locationCity: String
  locationCountry: String
  locationCountryCode: String
  locationPostalCode: String
  locationState: String
  medium: String
  minimumPriceDollars: Int
  myCollectionArtwork: Artwork
  myCollectionArtworkID: String
  offers(gravityPartnerId: ID!): [ConsignmentOffer!]!
  primaryImage: ConsignmentSubmissionCategoryAsset
  provenance: String
  publishedAt: ISO8601DateTime
  rejectionReason: String
  saleState: String
  signature: Boolean
  source: ConsignmentSubmissionSource

  # If this artwork exists in Gravity, its ID
  sourceArtworkID: String
  state: ConsignmentSubmissionStateAggregation
  title: String
  userAgent: String
  userEmail: String
  userId: String!
  userName: String
  userPhone: String
  userPhoneNumber: PhoneNumberType
  utmMedium: String
  utmSource: String
  utmTerm: String
  width: String
  year: String
}

enum ConsignmentSubmissionCategoryAggregation {
  ARCHITECTURE
  DESIGN_DECORATIVE_ART
  DRAWING_COLLAGE_OR_OTHER_WORK_ON_PAPER
  FASHION_DESIGN_AND_WEARABLE_ART
  INSTALLATION
  JEWELRY
  MIXED_MEDIA
  OTHER
  PAINTING
  PERFORMANCE_ART
  PHOTOGRAPHY
  PRINT
  SCULPTURE
  TEXTILE_ARTS
  VIDEO_FILM_ANIMATION
}

# Submission Asset
type ConsignmentSubmissionCategoryAsset {
  # type of this Asset
  assetType: String!

  # path to document
  documentPath: String

  # original image name
  filename: String

  # gemini token for asset
  geminiToken: String

  # Uniq ID for this asset
  id: ID!

  # known image urls
  imageUrls: JSON
  s3Bucket: String
  s3Path: String
  size: String
  submissionID: ID
  submissionId: ID!
}

# The connection type for Submission.
type ConsignmentSubmissionConnection {
  # A list of edges.
  edges: [SubmissionEdge]

  # A list of nodes.
  nodes: [ConsignmentSubmission]
  pageCursors: ConsignmentPageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

enum ConsignmentSubmissionSort {
  # sort by additional_info in ascending order
  ADDITIONAL_INFO_ASC

  # sort by additional_info in descending order
  ADDITIONAL_INFO_DESC

  # sort by admin_id in ascending order
  ADMIN_ID_ASC

  # sort by admin_id in descending order
  ADMIN_ID_DESC

  # sort by admin_receipt_sent_at in ascending order
  ADMIN_RECEIPT_SENT_AT_ASC

  # sort by admin_receipt_sent_at in descending order
  ADMIN_RECEIPT_SENT_AT_DESC

  # sort by approved_at in ascending order
  APPROVED_AT_ASC

  # sort by approved_at in descending order
  APPROVED_AT_DESC

  # sort by approved_by in ascending order
  APPROVED_BY_ASC

  # sort by approved_by in descending order
  APPROVED_BY_DESC

  # sort by artist_id in ascending order
  ARTIST_ID_ASC

  # sort by artist_id in descending order
  ARTIST_ID_DESC

  # sort by artist_proofs in ascending order
  ARTIST_PROOFS_ASC

  # sort by artist_proofs in descending order
  ARTIST_PROOFS_DESC

  # sort by artist_score in ascending order
  ARTIST_SCORE_ASC

  # sort by artist_score in descending order
  ARTIST_SCORE_DESC

  # sort by assigned_to in ascending order
  ASSIGNED_TO_ASC

  # sort by assigned_to in descending order
  ASSIGNED_TO_DESC

  # sort by attribution_class in ascending order
  ATTRIBUTION_CLASS_ASC

  # sort by attribution_class in descending order
  ATTRIBUTION_CLASS_DESC

  # sort by auction_score in ascending order
  AUCTION_SCORE_ASC

  # sort by auction_score in descending order
  AUCTION_SCORE_DESC

  # sort by authenticity_certificate in ascending order
  AUTHENTICITY_CERTIFICATE_ASC

  # sort by authenticity_certificate in descending order
  AUTHENTICITY_CERTIFICATE_DESC

  # sort by cataloguer in ascending order
  CATALOGUER_ASC

  # sort by cataloguer in descending order
  CATALOGUER_DESC

  # sort by category in ascending order
  CATEGORY_ASC

  # sort by category in descending order
  CATEGORY_DESC

  # sort by coa_by_authenticating_body in ascending order
  COA_BY_AUTHENTICATING_BODY_ASC

  # sort by coa_by_authenticating_body in descending order
  COA_BY_AUTHENTICATING_BODY_DESC

  # sort by coa_by_gallery in ascending order
  COA_BY_GALLERY_ASC

  # sort by coa_by_gallery in descending order
  COA_BY_GALLERY_DESC

  # sort by condition_report in ascending order
  CONDITION_REPORT_ASC

  # sort by condition_report in descending order
  CONDITION_REPORT_DESC

  # sort by consigned_partner_submission_id in ascending order
  CONSIGNED_PARTNER_SUBMISSION_ID_ASC

  # sort by consigned_partner_submission_id in descending order
  CONSIGNED_PARTNER_SUBMISSION_ID_DESC

  # sort by created_at in ascending order
  CREATED_AT_ASC

  # sort by created_at in descending order
  CREATED_AT_DESC

  # sort by currency in ascending order
  CURRENCY_ASC

  # sort by currency in descending order
  CURRENCY_DESC

  # sort by deadline_to_sell in ascending order
  DEADLINE_TO_SELL_ASC

  # sort by deadline_to_sell in descending order
  DEADLINE_TO_SELL_DESC

  # sort by deleted_at in ascending order
  DELETED_AT_ASC

  # sort by deleted_at in descending order
  DELETED_AT_DESC

  # sort by depth in ascending order
  DEPTH_ASC

  # sort by depth in descending order
  DEPTH_DESC

  # sort by dimensions_metric in ascending order
  DIMENSIONS_METRIC_ASC

  # sort by dimensions_metric in descending order
  DIMENSIONS_METRIC_DESC

  # sort by edition in ascending order
  EDITION_ASC

  # sort by edition in descending order
  EDITION_DESC

  # sort by edition_number in ascending order
  EDITION_NUMBER_ASC

  # sort by edition_number in descending order
  EDITION_NUMBER_DESC

  # sort by edition_size in ascending order
  EDITION_SIZE_ASC

  # sort by edition_size in descending order
  EDITION_SIZE_DESC

  # sort by exhibition in ascending order
  EXHIBITION_ASC

  # sort by exhibition in descending order
  EXHIBITION_DESC

  # sort by ext_user_id in ascending order
  EXT_USER_ID_ASC

  # sort by ext_user_id in descending order
  EXT_USER_ID_DESC

  # sort by height in ascending order
  HEIGHT_ASC

  # sort by height in descending order
  HEIGHT_DESC

  # sort by id in ascending order
  ID_ASC

  # sort by id in descending order
  ID_DESC

  # sort by literature in ascending order
  LITERATURE_ASC

  # sort by literature in descending order
  LITERATURE_DESC

  # sort by location_address2 in ascending order
  LOCATION_ADDRESS2_ASC

  # sort by location_address2 in descending order
  LOCATION_ADDRESS2_DESC

  # sort by location_address in ascending order
  LOCATION_ADDRESS_ASC

  # sort by location_address in descending order
  LOCATION_ADDRESS_DESC

  # sort by location_city in ascending order
  LOCATION_CITY_ASC

  # sort by location_city in descending order
  LOCATION_CITY_DESC

  # sort by location_country in ascending order
  LOCATION_COUNTRY_ASC

  # sort by location_country_code in ascending order
  LOCATION_COUNTRY_CODE_ASC

  # sort by location_country_code in descending order
  LOCATION_COUNTRY_CODE_DESC

  # sort by location_country in descending order
  LOCATION_COUNTRY_DESC

  # sort by location_postal_code in ascending order
  LOCATION_POSTAL_CODE_ASC

  # sort by location_postal_code in descending order
  LOCATION_POSTAL_CODE_DESC

  # sort by location_state in ascending order
  LOCATION_STATE_ASC

  # sort by location_state in descending order
  LOCATION_STATE_DESC

  # sort by medium in ascending order
  MEDIUM_ASC

  # sort by medium in descending order
  MEDIUM_DESC

  # sort by minimum_price_cents in ascending order
  MINIMUM_PRICE_CENTS_ASC

  # sort by minimum_price_cents in descending order
  MINIMUM_PRICE_CENTS_DESC

  # sort by my_collection_artwork_id in ascending order
  MY_COLLECTION_ARTWORK_ID_ASC

  # sort by my_collection_artwork_id in descending order
  MY_COLLECTION_ARTWORK_ID_DESC

  # sort by offers_count in ascending order
  OFFERS_COUNT_ASC

  # sort by offers_count in descending order
  OFFERS_COUNT_DESC

  # sort by primary_image_id in ascending order
  PRIMARY_IMAGE_ID_ASC

  # sort by primary_image_id in descending order
  PRIMARY_IMAGE_ID_DESC

  # sort by provenance in ascending order
  PROVENANCE_ASC

  # sort by provenance in descending order
  PROVENANCE_DESC

  # sort by published_at in ascending order
  PUBLISHED_AT_ASC

  # sort by published_at in descending order
  PUBLISHED_AT_DESC

  # sort by publisher in ascending order
  PUBLISHER_ASC

  # sort by publisher in descending order
  PUBLISHER_DESC

  # sort by qualified in ascending order
  QUALIFIED_ASC

  # sort by qualified in descending order
  QUALIFIED_DESC

  # sort by receipt_sent_at in ascending order
  RECEIPT_SENT_AT_ASC

  # sort by receipt_sent_at in descending order
  RECEIPT_SENT_AT_DESC

  # sort by rejected_at in ascending order
  REJECTED_AT_ASC

  # sort by rejected_at in descending order
  REJECTED_AT_DESC

  # sort by rejected_by in ascending order
  REJECTED_BY_ASC

  # sort by rejected_by in descending order
  REJECTED_BY_DESC

  # sort by rejection_reason in ascending order
  REJECTION_REASON_ASC

  # sort by rejection_reason in descending order
  REJECTION_REASON_DESC

  # sort by reminders_sent_count in ascending order
  REMINDERS_SENT_COUNT_ASC

  # sort by reminders_sent_count in descending order
  REMINDERS_SENT_COUNT_DESC

  # sort by session_id in ascending order
  SESSION_ID_ASC

  # sort by session_id in descending order
  SESSION_ID_DESC

  # sort by signature in ascending order
  SIGNATURE_ASC

  # sort by signature in descending order
  SIGNATURE_DESC

  # sort by signature_detail in ascending order
  SIGNATURE_DETAIL_ASC

  # sort by signature_detail in descending order
  SIGNATURE_DETAIL_DESC

  # sort by source_artwork_id in ascending order
  SOURCE_ARTWORK_ID_ASC

  # sort by source_artwork_id in descending order
  SOURCE_ARTWORK_ID_DESC

  # sort by source in ascending order
  SOURCE_ASC

  # sort by source in descending order
  SOURCE_DESC

  # sort by state in ascending order
  STATE_ASC

  # sort by state in descending order
  STATE_DESC

  # sort by title in ascending order
  TITLE_ASC

  # sort by title in descending order
  TITLE_DESC

  # sort by updated_at in ascending order
  UPDATED_AT_ASC

  # sort by updated_at in descending order
  UPDATED_AT_DESC

  # sort by user_agent in ascending order
  USER_AGENT_ASC

  # sort by user_agent in descending order
  USER_AGENT_DESC

  # sort by user_email in ascending order
  USER_EMAIL_ASC

  # sort by user_email in descending order
  USER_EMAIL_DESC

  # sort by user_id in ascending order
  USER_ID_ASC

  # sort by user_id in descending order
  USER_ID_DESC

  # sort by user_name in ascending order
  USER_NAME_ASC

  # sort by user_name in descending order
  USER_NAME_DESC

  # sort by user_phone in ascending order
  USER_PHONE_ASC

  # sort by user_phone in descending order
  USER_PHONE_DESC

  # sort by utm_medium in ascending order
  UTM_MEDIUM_ASC

  # sort by utm_medium in descending order
  UTM_MEDIUM_DESC

  # sort by utm_source in ascending order
  UTM_SOURCE_ASC

  # sort by utm_source in descending order
  UTM_SOURCE_DESC

  # sort by utm_term in ascending order
  UTM_TERM_ASC

  # sort by utm_term in descending order
  UTM_TERM_DESC

  # sort by uuid in ascending order
  UUID_ASC

  # sort by uuid in descending order
  UUID_DESC

  # sort by width in ascending order
  WIDTH_ASC

  # sort by width in descending order
  WIDTH_DESC

  # sort by year in ascending order
  YEAR_ASC

  # sort by year in descending order
  YEAR_DESC
}

enum ConsignmentSubmissionSource {
  ADMIN
  APP_INBOUND
  MY_COLLECTION
  PARTNER
  WEB_INBOUND
}

# Enum with all available submission states
enum ConsignmentSubmissionStateAggregation {
  APPROVED
  CLOSED
  DRAFT
  HOLD
  PUBLISHED
  REJECTED
  RESUBMITTED
  SUBMITTED
}

type ConvectionService {
  geminiTemplateKey: String!
}

# A conversation.
type Conversation implements Node {
  # Only the artworks discussed in the conversation.
  artworks: [Artwork]
  buyerOutcome: String
  buyerOutcomeAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  collectorInterestsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): UserInterestConnection

  # The collector profile of the user who initiated the conversation. Do not use this field for Partners
  collectorResume: CollectorResume
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  deletedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  dismissedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # The participant who initiated the conversation
  from: ConversationInitiator!
  fromLastViewedMessageID: String

  # The collector profile of the user who initiated the conversation
  fromProfile: CollectorProfileType @deprecated(reason: "Use `collectorResume` instead")

  # The user who initiated the conversation
  fromUser: User
    @deprecated(reason: "Will be inaccessible to partners in future versions. Prefer fromProfile.")

  # A globally unique ID.
  id: ID!
  initialMessage: String!
    @deprecated(
      reason: "This field is no longer required. Prefer the first message from the MessageConnection."
    )

  # Gravity inquiry id.
  inquiryID: String

  # The inquiry request associated with the conversation.
  inquiryRequest: PartnerInquiryRequest

  # An optional type-specific ID.
  internalID: ID

  # True if user/conversation initiator is a recipient.
  isLastMessageToUser: Boolean

  # The artworks and/or partner shows discussed in the conversation.
  items: [ConversationItem]

  # This is a snippet of text from the last message.
  lastMessage: String
  lastMessageAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Impulse id of the last message.
  lastMessageID: String
    @deprecated(
      reason: "Prefer querying `messagesConnection(last:1) { edges { node { internalID } } }`"
    )

  # A connection for all messages in a single conversation
  messages(after: String, before: String, first: Int, last: Int, sort: sort): MessageConnection
    @deprecated(reason: "Prefer messagesConnection")

  # A connection for all messages and events in a single conversation
  messagesAndConversationEventsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): MessageOrConversationEventTypeConnection

  # A connection for all messages in a single conversation
  messagesConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: sort
  ): MessageConnection
  orderConnection(
    after: String
    before: String
    first: Int
    last: Int
    participantType: CommerceOrderParticipantEnum
    sellerId: ID
    state: CommerceOrderStateEnum
    states: [CommerceOrderStateEnum!]
  ): CommerceOrderConnectionWithTotalCount

  # The participant(s) responding to the conversation
  to: ConversationResponder!
  toLastViewedMessageID: String

  # True if there is an unread message by the Collector(from).
  unread: Boolean @deprecated(reason: "Use `unreadByCollector` instead")

  # True if there is an unread message by the Collector(from).
  unreadByCollector: Boolean

  # True if there is an unread message by the Partner(to).
  unreadByPartner: Boolean
}

# A connection to a list of items.
type ConversationConnection {
  # A list of edges.
  edges: [ConversationEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalUnreadCount: Int
}

# An edge in a connection.
type ConversationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Conversation
}

# An event (such as a submitted offer) in a conversation.
type ConversationEvent implements Node {
  # Text for this event, formatted for the buyer.
  buyerBody: String
  eventKey: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Text for this event, formatted for the seller.
  sellerBody: String
}

# The participant who started the conversation, currently always a User
type ConversationInitiator {
  email: String!

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # The type of participant, e.g. Partner or User
  type: String!
}

type ConversationItem {
  item: ConversationItemType

  # The actual, non-snapshotted artwork
  liveArtwork: ConversationItemType
  permalink: String
  title: String
}

union ConversationItemType = Artwork | Show

input ConversationMessageAttachmentInput {
  id: String
  name: String!
  size: String
  type: String!
  url: String!
}

# The participant responding to the conversation, currently always a Partner
type ConversationResponder {
  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # An array of Impulse IDs that correspond to all email addresses that messages should be sent to
  replyToImpulseIDs: [String]!

  # The type of participant, e.g. Partner or User
  type: String!
}

enum ConversationsInputMode {
  PARTNER
  USER
}

type CreateAccountRequestMutationFailure {
  mutationError: GravityMutationError
}

input CreateAccountRequestMutationInput {
  # Type of account request.
  action: String
  clientMutationId: String

  # Email to associate with message.
  email: String

  # Name to associate with message.
  name: String

  # Message to be sent.
  notes: String!

  # Used when logged in.
  userID: String
}

type CreateAccountRequestMutationPayload {
  accountRequestOrError: CreateAccountRequestMutationType
  clientMutationId: String
}

type CreateAccountRequestMutationSuccess {
  accountRequest: AccountRequest
}

union CreateAccountRequestMutationType =
    CreateAccountRequestMutationFailure
  | CreateAccountRequestMutationSuccess

type CreateAlertFailure {
  mutationError: GravityMutationError
}

union CreateAlertResponseOrError = CreateAlertFailure | CreateAlertSuccess

type CreateAlertSuccess {
  alert: Alert
  me: Me!
}

# Autogenerated input type of CreateAndSendBackupSecondFactor
input CreateAndSendBackupSecondFactorInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userID: ID!
}

# Autogenerated return type of CreateAndSendBackupSecondFactor
type CreateAndSendBackupSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  factor: BackupSecondFactor!
}

# Autogenerated input type of CreateAppSecondFactor
input CreateAppSecondFactorInput {
  attributes: AppSecondFactorAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
}

# Autogenerated return type of CreateAppSecondFactor
type CreateAppSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: AppSecondFactorOrErrorsUnion!
}

type CreateArtistFailure {
  mutationError: GravityMutationError
}

input CreateArtistMutationInput {
  birthday: String
  clientMutationId: String
  deathday: String
  displayName: String!
  firstName: String
  isPersonalArtist: Boolean
  lastName: String
  middleName: String
  nationality: String
}

type CreateArtistMutationPayload {
  # Success or Error, where on success Artist is returned
  artistOrError: CreateArtistSuccessOrErrorType
  clientMutationId: String
}

type CreateArtistSuccess {
  artist: Artist
}

union CreateArtistSuccessOrErrorType = CreateArtistFailure | CreateArtistSuccess

# Autogenerated input type of CreateBackupSecondFactors
input CreateBackupSecondFactorsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
}

# Autogenerated return type of CreateBackupSecondFactors
type CreateBackupSecondFactorsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorsOrErrors: BackupSecondFactorsOrErrorsUnion!
}

# Autogenerated input type of CreateBankDebitSetup
input CreateBankDebitSetupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  paymentMethodTypes: [String!]!
}

# Autogenerated return type of CreateBankDebitSetup
type CreateBankDebitSetupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  clientSecret: String!
}

input CreateBidderInput {
  clientMutationId: String
  saleID: String!
}

type CreateBidderPayload {
  bidder: Bidder
  clientMutationId: String
}

type CreateCareerHighlightFailure {
  mutationError: GravityMutationError
}

input CreateCareerHighlightInput {
  artistId: String!
  clientMutationId: String
  collected: Boolean
  group: Boolean
  partnerId: String!
  solo: Boolean
}

type CreateCareerHighlightPayload {
  # On success: the created Artist Career Highlight.
  careerHighlightOrError: CreateCareerHighlightSuccessResponseOrError
  clientMutationId: String
}

type CreateCareerHighlightSuccess {
  careerHighlight: CareerHighlight
}

union CreateCareerHighlightSuccessResponseOrError =
    CreateCareerHighlightFailure
  | CreateCareerHighlightSuccess

type CreateCollectionFailure {
  mutationError: GravityMutationError
}

union CreateCollectionResponseOrError = CreateCollectionFailure | CreateCollectionSuccess

type CreateCollectionSuccess {
  collection: Collection
}

input CreateConsignmentInquiryMutationInput {
  clientMutationId: String
  email: String!
  message: String!
  name: String!
  phoneNumber: String
  recipientEmail: String
  userId: String
}

type CreateConsignmentInquiryMutationPayload {
  clientMutationId: String
  consignmentInquiryOrError: CreateConsignmentInquiryMutationType
}

union CreateConsignmentInquiryMutationType =
    ConsignmentInquiryMutationFailure
  | ConsignmentInquiryMutationSuccess

type CreateFeatureFailure {
  mutationError: GravityMutationError
}

input CreateFeatureMutationInput {
  active: Boolean!
  callout: String
  clientMutationId: String
  description: String
  layout: FeatureLayouts
  name: String!
  sourceBucket: String
  sourceKey: String
  subheadline: String
}

type CreateFeatureMutationPayload {
  clientMutationId: String
  featureOrError: createFeatureResponseOrError
}

type CreateFeatureSuccess {
  feature: Feature
}

type CreateFeaturedLinkFailure {
  mutationError: GravityMutationError
}

input CreateFeaturedLinkMutationInput {
  clientMutationId: String
  description: String
  href: String!
  sourceBucket: String
  sourceKey: String
  subtitle: String
  title: String!
}

type CreateFeaturedLinkMutationPayload {
  clientMutationId: String
  featuredLinkOrError: CreateFeaturedLinkResponseOrError
}

union CreateFeaturedLinkResponseOrError = CreateFeaturedLinkFailure | CreateFeaturedLinkSuccess

type CreateFeaturedLinkSuccess {
  featuredLink: FeaturedLink
}

input CreateGeminiEntryForAssetInput {
  clientMutationId: String

  # Additional JSON data to pass through gemini, should definitely contain an `id` and a `_type`
  metadata: JSON!

  # The S3 bucket where the file was uploaded
  sourceBucket: String!

  # The path to the file
  sourceKey: String!

  # The template key, this is `name` in the asset request
  templateKey: String!
}

type CreateGeminiEntryForAssetPayload {
  asset: GeminiEntry
  clientMutationId: String
}

input CreateHeroUnitLinkInput {
  text: String!
  url: String!
}

input CreateHeroUnitMutationInput {
  body: String!
  clientMutationId: String
  credit: String
  endAt: String
  imageUrl: String
  label: String
  link: CreateHeroUnitLinkInput!
  position: Int
  startAt: String
  title: String!
}

type CreateHeroUnitMutationPayload {
  clientMutationId: String

  # On success: the hero unit created.
  heroUnitOrError: createHeroUnitResponseOrError
}

input CreateIdentityVerificationOverrideMutationInput {
  clientMutationId: String

  # The identity verification ID
  identityVerificationID: String!

  # The reason for the identity verification override
  reason: String!

  # The state of the identity verification override
  state: String!
}

type CreateIdentityVerificationOverrideMutationPayload {
  clientMutationId: String

  # On success: an identity verification with overrides
  createIdentityVerificationOverrideResponseOrError: CreateIdentityVerificationOverrideResponseOrError
}

union CreateIdentityVerificationOverrideResponseOrError =
    IdentityVerificationOverrideMutationFailure
  | IdentityVerificationOverrideMutationSuccess

# Autogenerated input type of CreateImage
input CreateImageInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The S3 url for the image to be processed
  src: String!

  # The Gemini template key that tells us which image versions we want to generate during processing
  templateKey: String!
}

# Autogenerated return type of CreateImage
type CreateImagePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  image: ARImage!
}

# Autogenerated input type of CreateOfferMutation
input CreateOfferMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  commissionPercentWhole: Int!
  createdById: String
  currency: String
  deadlineToConsign: String
  gravityPartnerId: String!
  highEstimateDollars: Int
  insuranceInfo: String
  lowEstimateDollars: Int
  notes: String
  offerType: String
  otherFeesInfo: String
  partnerInfo: String
  photographyInfo: String
  saleDate: Date
  saleLocation: String
  saleName: String
  shippingInfo: String
  startingBidDollars: Int
  state: String
  submissionId: ID!
}

# Autogenerated return type of CreateOfferMutation
type CreateOfferMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consignmentOffer: ConsignmentOffer
}

# Autogenerated input type of CreateOfferResponseMutation
input CreateOfferResponseMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comments: String
  intendedState: IntendedState!
  offerId: ID!
  phoneNumber: String
  rejectionReason: String
}

# Autogenerated return type of CreateOfferResponseMutation
type CreateOfferResponseMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consignmentOfferResponse: OfferResponse
}

input CreateOrderedSetMutationInput {
  clientMutationId: String
  description: String
  internalName: String
  itemId: String
  itemIds: [String]
  itemType: String!
  key: String!
  layout: OrderedSetLayouts
  name: String
  ownerType: String
  published: Boolean
}

type CreateOrderedSetMutationPayload {
  clientMutationId: String

  # On success: the ordered set created.
  orderedSetOrError: createOrderedSetResponseOrError
}

type CreatePageFailure {
  mutationError: GravityMutationError
}

input CreatePageMutationInput {
  clientMutationId: String
  content: String!
  name: String!
  published: Boolean!
}

type CreatePageMutationPayload {
  clientMutationId: String
  pageOrError: CreatePageResponseOrError
}

union CreatePageResponseOrError = CreatePageFailure | CreatePageSuccess

type CreatePageSuccess {
  page: Page
}

type CreateSaleAgreementFailure {
  mutationError: GravityMutationError
}

input CreateSaleAgreementMutationInput {
  clientMutationId: String
  content: String!
  displayEndAt: String
  displayStartAt: String
  published: Boolean!
  saleId: String!
  status: SaleAgreementStatus!
}

type CreateSaleAgreementMutationPayload {
  clientMutationId: String
  saleAgreementOrError: CreateSaleAgreementResponseOrError
}

union CreateSaleAgreementResponseOrError = CreateSaleAgreementFailure | CreateSaleAgreementSuccess

type CreateSaleAgreementSuccess {
  saleAgreement: SaleAgreement
}

# Autogenerated input type of CreateSavedSearch
input CreateSavedSearchInput {
  attributes: SearchCriteriaAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userAlertSettings: UserAlertSettingsInput
}

# Autogenerated return type of CreateSavedSearch
type CreateSavedSearchPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
  savedSearchOrErrors: SearchCriteriaOrErrorsUnion!
}

# Autogenerated input type of CreateSmsSecondFactor
input CreateSmsSecondFactorInput {
  attributes: SmsSecondFactorAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
}

# Autogenerated return type of CreateSmsSecondFactor
type CreateSmsSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: SmsSecondFactorOrErrorsUnion!
}

# Autogenerated input type of CreateSubmissionMutation
input CreateSubmissionMutationInput {
  additionalInfo: String
  artistID: String!
  attributionClass: ConsignmentAttributionClass
  authenticityCertificate: Boolean
  category: ConsignmentSubmissionCategoryAggregation

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  coaByAuthenticatingBody: Boolean
  coaByGallery: Boolean
  currency: String
  depth: String
  dimensionsMetric: String
  edition: Boolean
  editionNumber: String

  # Deprecated: Use edition_size_formatted field instead
  editionSize: Int
  editionSizeFormatted: String
  height: String
  locationAddress: String
  locationAddress2: String
  locationCity: String
  locationCountry: String
  locationCountryCode: String
  locationPostalCode: String
  locationState: String
  medium: String
  minimumPriceDollars: Int
  myCollectionArtworkID: String
  provenance: String
  sessionID: String
  signature: Boolean
  source: ConsignmentSubmissionSource

  # If this artwork exists in Gravity, its ID
  sourceArtworkID: String
  state: ConsignmentSubmissionStateAggregation
  title: String
  userAgent: String
  userEmail: String
  userName: String
  userPhone: String
  utmMedium: String
  utmSource: String
  utmTerm: String
  width: String
  year: String
}

# Autogenerated return type of CreateSubmissionMutation
type CreateSubmissionMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consignmentSubmission: ConsignmentSubmission
}

# Autogenerated input type of CreateUserAddress
input CreateUserAddressInput {
  attributes: UserAddressAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateUserAddress
type CreateUserAddressPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
  userAddressOrErrors: UserAddressOrErrorsUnion!
}

type CreateUserInterestFailure {
  mutationError: GravityMutationError
}

input CreateUserInterestForUserInput {
  # Optional body for a note.
  body: String
  category: UserInterestCategory!
  clientMutationId: String
  interestId: String!
  interestType: UserInterestInterestType!
  ownerType: UserInterestOwnerType!
  userId: String!
}

type CreateUserInterestForUserPayload {
  clientMutationId: String

  # On success: UserInterest, User. On failure: MutationError.
  userInterestOrError: createUserInterestForUserResponseOrError
}

input CreateUserInterestMutationInput {
  anonymousSessionId: String

  # Optional body for note
  body: String
  category: UserInterestCategory!
  clientMutationId: String
  interestId: String!
  interestType: UserInterestInterestType!
  private: Boolean
  sessionID: String
}

type CreateUserInterestMutationPayload {
  clientMutationId: String
  me: Me!
  userInterest: UserInterest!
}

input CreateUserInterestsMutationInput {
  clientMutationId: String
  userInterests: [UserInterestInput!]!
}

type CreateUserInterestsMutationPayload {
  clientMutationId: String
  me: Me!
  userInterestsOrErrors: [UserInterestOrError!]!
}

type CreateUserSaleProfileFailure {
  mutationError: GravityMutationError
}

input CreateUserSaleProfileMutationInput {
  addressLine1: String
  addressLine2: String
  city: String
  clientMutationId: String
  country: String
  requireBidderApproval: Boolean
  state: String
  userId: String!
  zip: String
}

type CreateUserSaleProfileMutationPayload {
  clientMutationId: String

  # On success: the user sale profile created.
  userSaleProfileOrError: CreateUserSaleProfileResponseOrError
}

union CreateUserSaleProfileResponseOrError =
    CreateUserSaleProfileFailure
  | CreateUserSaleProfileSuccess

type CreateUserSaleProfileSuccess {
  userSaleProfile: UserSaleProfile
}

type CreateVerifiedRepresentativeFailure {
  mutationError: GravityMutationError
}

input CreateVerifiedRepresentativeInput {
  artistId: String!
  clientMutationId: String
  partnerId: String!
}

type CreateVerifiedRepresentativePayload {
  clientMutationId: String

  # On success: the created Verified Representative.
  verifiedRepresentativeOrError: CreateVerifiedRepresentativeResponseOrError
}

union CreateVerifiedRepresentativeResponseOrError =
    CreateVerifiedRepresentativeFailure
  | CreateVerifiedRepresentativeSuccess

type CreateVerifiedRepresentativeSuccess {
  verifiedRepresentative: VerifiedRepresentative
}

# Autogenerated input type of CreateViewingRoom
input CreateViewingRoomInput {
  attributes: ViewingRoomAttributes

  # Main text
  body: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # End datetime
  endAt: ISO8601DateTime
  image: ARImageInput

  # Introduction
  introStatement: String
  partnerID: String

  # Partner Id
  partnerId: String

  # Pullquote
  pullQuote: String

  # Start datetime
  startAt: ISO8601DateTime

  # Timezone
  timeZone: String

  # Title
  title: String
}

# Autogenerated return type of CreateViewingRoom
type CreateViewingRoomPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomOrErrors: ViewingRoomOrErrorsUnion!
}

# An asset which is assigned to a consignment submission
type Credentials {
  # The key to use with S3.
  credentials: String!

  # The s3 policy document for your request
  policyDocument: S3PolicyDocumentType!

  # A base64 encoded version of the S3 policy
  policyEncoded: String!

  # The signature for your asset.
  signature: String!
}

type CreditCard {
  # Brand of credit card
  brand: String!

  # Billing address city
  city: String

  # Billing address country code
  country: String

  # Credit card's expiration month
  expirationMonth: Int!

  # Credit card's expiration year
  expirationYear: Int!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Last four digits on the credit card
  lastDigits: String!

  # Name on the credit card
  name: String

  # Billing address postal code
  postalCode: String

  # Billing address state
  state: String

  # Billing address street1
  street1: String

  # Billing address street2
  street2: String
}

# A connection to a list of items.
type CreditCardConnection {
  # A list of edges.
  edges: [CreditCardEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CreditCardEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: CreditCard
}

input CreditCardInput {
  clientMutationId: String
  oneTimeUse: Boolean = false
  token: String!
}

type CreditCardMutationFailure {
  mutationError: GravityMutationError
}

type CreditCardMutationSuccess {
  creditCard: CreditCard
  creditCardEdge: CreditCardEdge
}

union CreditCardMutationType = CreditCardMutationFailure | CreditCardMutationSuccess

type CreditCardPayload {
  clientMutationId: String
  creditCardOrError: CreditCardMutationType
  me: Me
}

type CroppedImageUrl {
  height: Int!
  src: String!
  srcSet: String!
  url: String!
  width: Int!
}

enum CurrencyPreference {
  EUR
  GBP
  USD
}

type CurrentEvent {
  # Location and date of the event if available
  details: String
  event: UnderlyingCurrentEvent!

  # Link to the event
  href: String
  image: Image

  # Name of the event
  name: String

  # Name of the partner associated to the event
  partner: String

  # The state of the event
  status: String
}

# Date in YYYY-MM-DD format
scalar Date

type DaySchedule {
  dayOfWeek: String
  endTime: Int
  startTime: Int
}

type DeepZoom {
  Image: DeepZoomImage
}

type DeepZoomImage {
  Format: String
  Overlap: Int
  Size: DeepZoomImageSize
  TileSize: Int
  Url: String
  xmlns: String
}

type DeepZoomImageSize {
  Height: Int
  Width: Int
}

input DeleteAccountInput {
  clientMutationId: String

  # Reason for deleting the account.
  explanation: String

  # Password.
  password: String

  # Referrer location
  url: String
}

type DeleteAccountPayload {
  clientMutationId: String
  userAccountOrError: AccountMutationType
}

type DeleteAlertFailure {
  mutationError: GravityMutationError
}

union DeleteAlertResponseOrError = DeleteAlertFailure | DeleteAlertSuccess

type DeleteAlertSuccess {
  alert: Alert
}

type DeleteArtistFailure {
  mutationError: GravityMutationError
}

input DeleteArtistInput {
  clientMutationId: String
  id: String!
}

type DeleteArtistPayload {
  # Success or Error, on success the deleted Artist is returned
  artistOrError: DeleteArtistSuccessOrErrorType
  clientMutationId: String
}

type DeleteArtistSuccess {
  artist: Artist
}

union DeleteArtistSuccessOrErrorType = DeleteArtistFailure | DeleteArtistSuccess

input DeleteArtworkImageInput {
  artworkID: String!
  clientMutationId: String
  imageID: String!
}

type DeleteArtworkImagePayload {
  artworkOrError: ArtworkMutationType
  clientMutationId: String
}

input DeleteBankAccountInput {
  clientMutationId: String
  id: String!
}

type DeleteBankAccountPayload {
  bankAccountOrError: BankAccountMutationType
  clientMutationId: String
  me: Me
}

type DeleteCareerHighlightFailure {
  mutationError: GravityMutationError
}

input DeleteCareerHighlightInput {
  clientMutationId: String
  id: String!
}

type DeleteCareerHighlightPayload {
  # On success: the deleted Artist Career Highlight is returned
  careerHighlightOrError: DeleteCareerHighlightSuccessOrErrorType
  clientMutationId: String
}

type DeleteCareerHighlightSuccess {
  careerHighlight: CareerHighlight
}

union DeleteCareerHighlightSuccessOrErrorType =
    DeleteCareerHighlightFailure
  | DeleteCareerHighlightSuccess

type DeleteCollectionFailure {
  mutationError: GravityMutationError
}

union DeleteCollectionResponseOrError = DeleteCollectionFailure | DeleteCollectionSuccess

type DeleteCollectionSuccess {
  collection: Collection
}

type DeleteConversationFailure {
  mutationError: GravityMutationError
}

input DeleteConversationMutationInput {
  clientMutationId: String

  # The id of the conversation to be deleted.
  id: String!
}

type DeleteConversationMutationPayload {
  clientMutationId: String

  # On success: the conversation that was soft deleted.
  conversationOrError: DeleteConversationResponseOrError
}

union DeleteConversationResponseOrError = DeleteConversationFailure | DeleteConversationSuccess

type DeleteConversationSuccess {
  conversation: Conversation
}

input DeleteCreditCardInput {
  clientMutationId: String
  id: String!
}

type DeleteCreditCardPayload {
  clientMutationId: String
  creditCardOrError: CreditCardMutationType
  me: Me
}

type DeleteFeatureFailure {
  mutationError: GravityMutationError
}

input DeleteFeatureMutationInput {
  clientMutationId: String
  id: String!
}

type DeleteFeatureMutationPayload {
  clientMutationId: String
  featureOrError: DeleteFeatureResponseOrError
}

union DeleteFeatureResponseOrError = DeleteFeatureFailure | DeleteFeatureSuccess

type DeleteFeatureSuccess {
  feature: Feature
}

type DeleteFeaturedLinkFailure {
  mutationError: GravityMutationError
}

input DeleteFeaturedLinkMutationInput {
  clientMutationId: String
  id: String!
}

type DeleteFeaturedLinkMutationPayload {
  clientMutationId: String
  featuredLinkOrError: DeleteFeaturedLinkResponseOrError
}

union DeleteFeaturedLinkResponseOrError = DeleteFeaturedLinkFailure | DeleteFeaturedLinkSuccess

type DeleteFeaturedLinkSuccess {
  featuredLink: FeaturedLink
}

type DeletePageFailure {
  mutationError: GravityMutationError
}

input DeletePageMutationInput {
  clientMutationId: String
  id: String!
}

type DeletePageMutationPayload {
  clientMutationId: String
  pageOrError: DeletePageResponseOrError
}

union DeletePageResponseOrError = DeletePageFailure | DeletePageSuccess

type DeletePageSuccess {
  page: Page
}

# Autogenerated input type of DeleteUserAddress
input DeleteUserAddressInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userAddressID: ID!
}

# Autogenerated return type of DeleteUserAddress
type DeleteUserAddressPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
  userAddressOrErrors: UserAddressOrErrorsUnion!
}

type DeleteUserFailure {
  mutationError: GravityMutationError
}

input DeleteUserIconInput {
  clientMutationId: String
}

type DeleteUserIconPayload {
  clientMutationId: String
  iconOrError: UserIconDeletionMutationType
}

input DeleteUserInput {
  clientMutationId: String
  id: String!
}

type DeleteUserInterestFailure {
  mutationError: GravityMutationError
}

input DeleteUserInterestForUserInput {
  clientMutationId: String

  # The ID of the UserInterest to delete.
  id: String!

  # An optional ID of a User.
  userId: String
}

type DeleteUserInterestForUserPayload {
  clientMutationId: String

  # On success: UserInterest and optionally a User. On failure: MutationError.
  userInterestOrError: deleteUserInterestForUserResponseOrError
}

input DeleteUserInterestMutationInput {
  anonymousSessionId: String
  clientMutationId: String

  # Either the `id` or the `interest_id` of a user interest
  id: String!
  sessionID: String
}

type DeleteUserInterestMutationPayload {
  clientMutationId: String
  me: Me!
  userInterest: UserInterest!
}

union DeleteUserInterestOrErrorType = DeleteUserInterestFailure | UserInterest

input DeleteUserInterestsMutationInput {
  clientMutationId: String
  ids: [String!]!
}

type DeleteUserInterestsMutationPayload {
  clientMutationId: String
  me: Me!
  userInterestsOrErrors: [DeleteUserInterestOrErrorType!]!
}

type DeleteUserPayload {
  clientMutationId: String

  # On success: a deleted User
  userOrError: DeleteUserResponseOrError
}

union DeleteUserResponseOrError = DeleteUserFailure | DeleteUserSuccess

type DeleteUserSuccess {
  user: User
}

type DeleteVerifiedRepresentativeFailure {
  mutationError: GravityMutationError
}

input DeleteVerifiedRepresentativeMutationInput {
  clientMutationId: String
  id: String!
}

type DeleteVerifiedRepresentativeMutationPayload {
  clientMutationId: String

  # On success: the deleted Verified Representative.
  verifiedRepresentativeOrError: DeleteVerifiedRepresentativeResponseOrError
}

union DeleteVerifiedRepresentativeResponseOrError =
    DeleteVerifiedRepresentativeFailure
  | DeleteVerifiedRepresentativeSuccess

type DeleteVerifiedRepresentativeSuccess {
  verifiedRepresentative: VerifiedRepresentative
}

# Autogenerated input type of DeleteViewingRoom
input DeleteViewingRoomInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomID: ID!
}

# Autogenerated return type of DeleteViewingRoom
type DeleteViewingRoomPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoom: ViewingRoom!
}

# Autogenerated input type of DeliverSecondFactor
input DeliverSecondFactorInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorID: ID!
}

# Autogenerated return type of DeliverSecondFactor
type DeliverSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: SecondFactorOrErrorsUnion!
}

# Fields of a delivery (currently from Radiation)
type Delivery {
  bouncedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  clickedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  deliveredAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Masked email w/ display name.
  fullTransformedEmail: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  openedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
}

type Department {
  id: ID!
  jobs: [Job!]!
  name: String!
}

type Device {
  # E.g., net.artsy.artsy
  appId: String!

  # Unique ID for this device
  id: ID!

  # Name of the device
  name: String!

  # Either android or ios
  platform: String!

  # If device is beta/dev or prod.
  production: Boolean!

  # The device token
  token: String!
}

# Autogenerated input type of DisableSavedSearch
input DisableSavedSearchInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # search criteria id
  searchCriteriaID: String!
}

# Autogenerated return type of DisableSavedSearch
type DisableSavedSearchPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  savedSearchOrErrors: SearchCriteriaOrErrorsUnion!
}

# Autogenerated input type of DisableSecondFactor
input DisableSecondFactorInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
  secondFactorID: ID!
}

# Autogenerated return type of DisableSecondFactor
type DisableSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: SecondFactorOrErrorsUnion!
}

input DislikeArtworkInput {
  artworkID: String!
  clientMutationId: String
  remove: Boolean!
}

type DislikeArtworkPayload {
  artwork: Artwork
  clientMutationId: String
  me: Me!
}

type DoNotUseThisPartner {
  displayName: String
  display_name: String @deprecated(reason: "Use displayName")
  givenName: String
  given_name: String @deprecated(reason: "Use givenName")
  id: ID!
  relativeSize: Int
  relative_size: Int @deprecated(reason: "Use relativeSize")
  slug: String
  subscriptionState: String
  subscription_state: String @deprecated(reason: "Use subscriptionState")
}

input EditableLocation {
  # First line of an address
  address: String

  # Second line of an address
  address2: String

  # The city the location is based in
  city: String

  # The optional location coordinates. [lat, lng]
  coordinates: [Float!]

  # The county the location is based in
  country: String

  # The county code of the location is based in
  countryCode: String

  # Postal code for a string
  postalCode: String

  # The (optional) name of the state for location
  state: String

  # The (optional) state code of the state for location
  stateCode: String

  # An optional display string for the location
  summary: String
}

type EditionSet implements Sellable {
  dimensions: dimensions
  displayPriceRange: Boolean
  editionOf: String

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  heightCm: Float

  # A globally unique ID.
  id: ID!

  # Price for internal partner display, requires partner access
  internalDisplayPrice: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isAcquireable: Boolean
  isForSale: Boolean
  isOfferable: Boolean
  isOfferableFromInquiry: Boolean
  isSold: Boolean
  listPrice: ListPrice
  price: String
  priceListed: Money
  saleMessage: String

  # size bucket assigned to an artwork based on its dimensions
  sizeBucket: String

  # score assigned to an artwork based on its dimensions
  sizeScore: Float

  # If you need to render artwork dimensions as a string, prefer the `Artwork#dimensions` field
  widthCm: Float
}

enum EditionSetSorts {
  PRICE_ASC
}

# Autogenerated input type of EnableSecondFactor
input EnableSecondFactorInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  code: String!
  password: String!
  secondFactorID: ID!
}

# Autogenerated return type of EnableSecondFactor
type EnableSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  recoveryCodes: [String!]
  secondFactorOrErrors: SecondFactorOrErrorsUnion!
}

input EndSaleInput {
  clientMutationId: String
  saleID: String
}

type EndSalePayload {
  clientMutationId: String
  sale: Sale
}

interface EntityWithFilterArtworksConnectionInterface {
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A globally unique ID.
  id: ID!
}

# A user-readable error
type Error {
  # Error code
  code: String!

  # Extra data about error.
  data: JSON

  # A description of the error
  message: String!

  # Which input value this error came from
  path: [String!]
}

# A user-readable list of errors
type Errors {
  # List of Errors.
  errors: [Error!]!
}

enum EventStatus {
  # Load all shows
  ALL

  # End date is in the past
  CLOSED

  # End date is in near future
  CLOSING_SOON

  # Start date or end date is in the future
  CURRENT

  # Start date is in the past and end date is in the future
  RUNNING

  # Special filtering option which is used to show running and upcoming shows
  RUNNING_AND_UPCOMING

  # Start date is in the future
  UPCOMING
}

enum ExhibitionPeriodFormat {
  # Long formatted period e.g. February 25 â€“ May 24, 2015
  LONG

  # Short formatted period e.g. Feb 25 - May 24, 2015
  SHORT
}

type External {
  auctionHouses(size: Int, term: String): [ExternalAuctionHouse!]!
  fairs(size: Int, term: String): [ExternalFair!]!
  galleries(
    # Limit results to only galleries on Artsy
    artsyOnly: Boolean = true
    size: Int
    term: String
  ): [ExternalGallery!]!
}

type ExternalAuctionHouse {
  city: String
  country: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String!
}

type ExternalFair {
  city: String
  country: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String!
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
}

type ExternalGallery {
  city: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String!
  partner: Partner
  region: String
}

type ExternalPartner {
  city: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String
}

type Fair implements EntityWithFilterArtworksConnectionInterface & Node {
  about(format: Format): String
  activeStartAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  articlesConnection(
    after: String
    before: String
    first: Int

    # Get only articles with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean
    last: Int
    page: Int
    size: Int
    sort: ArticleSorts
  ): ArticleConnection
  artistsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Sorts for artists in a fair
    sort: FairArtistSorts
  ): ArtistConnection
  bannerSize: String
  cached: Int
  contact(format: Format): String
  counts: FairCounts
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A formatted description of the start to end dates
  exhibitionPeriod(
    # Formatting option to apply to exhibition period
    format: ExhibitionPeriodFormat = LONG
  ): String

  # The exhibitors with booths in this fair with letter.
  exhibitorsGroupedByName: [FairExhibitorsGroup]

  # Suggested filters for associated artworks
  featuredKeywords: [String!]!

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  followedContent: FollowedContent

  # A formatted description of when the fair starts or closes or if it is closed
  formattedOpeningHours: String
  hasFullFeature: Boolean
  hasHomepageSection: Boolean
  hasLargeBanner: Boolean
  hasListing: Boolean
  hours(format: Format): String
  href: String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Are we currently in the fair's active period?
  isActive: Boolean
  isPublished: Boolean
  links(format: Format): String
  location: Location
  marketingCollectionSlugs: [String]!
  marketingCollections(size: Int): [MarketingCollection]!
  mobileImage: Image
  name: String
  organizer: FairOrganizer
  profile: Profile

  # This connection only supports forward pagination. We're replacing Relay's default cursor with one from Gravity.
  showsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int

    # Number of artworks to return
    section: String

    # Sorts for shows in a fair
    sort: ShowSorts
    totalCount: Boolean = false
  ): ShowConnection

  # A slug ID.
  slug: ID!
  sponsoredContent: FairSponsoredContent
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  summary(format: Format): String
  tagline: String
  tickets(format: Format): String
  ticketsLink: String
}

enum FairArtistSorts {
  NAME_ASC
  NAME_DESC
}

# A connection to a list of items.
type FairConnection {
  # A list of edges.
  edges: [FairEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type FairCounts {
  artists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partners(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type FairEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Fair
}

type FairExhibitor {
  # Exhibitor name
  name: String
  partner: Partner

  # Exhibitors _id
  partnerID: String

  # Partner default profile id
  profileID: String

  # A slug ID.
  slug: ID!
}

type FairExhibitorsGroup {
  # The exhibitor data.
  exhibitors: [FairExhibitor]

  # Letter exhibitors group belongs to
  letter: String
}

type FairOrganizer {
  about(format: Format): String

  # A connection of articles related to a partner.
  articlesConnection(
    after: String
    before: String
    first: Int

    # Get only articles with with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean
    last: Int
    page: Int
    sort: ArticleSorts
  ): ArticleConnection
  fairsConnection(
    after: String
    before: String
    first: Int
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean
    last: Int
    sort: FairSorts
    status: EventStatus
  ): FairConnection

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String
  profile: Profile
  profileID: ID

  # A slug ID.
  slug: ID!
  website: String
}

enum FairSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  START_AT_ASC
  START_AT_DESC
}

type FairSponsoredContent {
  activationText: String
  pressReleaseUrl: String
}

# Fairs rail section
type FairsRailHomeViewSection implements GenericHomeViewSection & Node {
  # The component that is prescribed for this section
  component: HomeViewComponent
  fairsConnection(after: String, before: String, first: Int, last: Int): FairConnection

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A Feature
type Feature {
  callout(format: Format): String
  description(format: Format): String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActive: Boolean!
  layout: FeatureLayouts!
  meta: FeatureMeta!
  name: String!

  # Features are composed of sets, which are themselves composed of items of various types
  setsConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: OrderedSetSorts = KEY_ASC
  ): OrderedSetConnection

  # A slug ID.
  slug: ID!
  subheadline(format: Format): String
}

# A connection to a list of items.
type FeatureConnection {
  # A list of edges.
  edges: [FeatureEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type FeatureEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Feature
}

type FeatureFlag {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  description: String
  environments: [FeatureFlagEnvironments]

  # A globally unique ID.
  id: ID!
  impressionData: Boolean!
  lastSeenAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  name: String!
  project: String!
  stale: Boolean!
  type: String!
  variants: [FeatureFlagVariantType]
}

type FeatureFlagEnvironments {
  enabled: Boolean!
  name: String!
}

input FeatureFlagStrategyInput {
  rollOut: Int = 100
  strategyType: FeatureFlagStrategyType
}

enum FeatureFlagStrategyType {
  # Simple on/off flag
  DEFAULT

  # For A/B tests, where you can specify a percentage of users to be served a variant
  FLEXIBLE_ROLLOUT
}

enum FeatureFlagToggleType {
  EXPERIMENT
  RELEASE
}

input FeatureFlagVariantInputName {
  name: String!
  stickiness: String = "sessionId"
  weight: Int!
  weightType: FeatureFlagVariantWeightType
}

type FeatureFlagVariantType {
  name: String
  stickiness: String
  weight: Int
  weightType: String
}

enum FeatureFlagVariantWeightType {
  VARIABLE
}

enum FeatureFlagsSortBy {
  CREATED_AT
  NAME
}

enum FeatureLayouts {
  DEFAULT
  FULL
}

# Meta-tag related fields for Features
type FeatureMeta {
  description: String!
  image: String
  name: String!
}

enum FeatureSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
}

# An illustrated link chosen to highlight a Gene from a given GeneFamily
type FeaturedGeneLink {
  href: String!
  image: Image
  internalID: String!
  title: String!
}

type FeaturedLink {
  description(format: Format): String

  # Parses the `href` to get the underlying entity
  entity: FeaturedLinkEntity
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  subtitle(format: Format): String
  title: String
}

# A connection to a list of items.
type FeaturedLinkConnection {
  # A list of edges.
  edges: [FeaturedLinkEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type FeaturedLinkEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FeaturedLink
}

union FeaturedLinkEntity = Artist | Gene | Partner

type Feedback {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Feedback message
  message: String!
}

type FieldErrorResults {
  message: String!
  name: String!
}

# A connection to a list of items.
type FilterArtworksConnection implements ArtworkConnectionInterface & Node {
  # Returns aggregation counts for the given filter query.
  aggregations: [ArtworksAggregationResults]
  counts: FilterArtworksCounts

  # A list of edges.
  edges: [FilterArtworksEdge]
  facet: ArtworkFilterFacet

  # Artwork results.
  hits: [Artwork] @deprecated(reason: "Prefer to use `edges`. [Will be removed in v2]")

  # The ID of the object.
  id: ID!

  # Returns a list of merchandisable artists sorted by merch score.
  merchandisableArtists(
    # The number of artists to return
    size: Int = 12
  ): [Artist]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type FilterArtworksCounts {
  followedArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  total(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type FilterArtworksEdge implements ArtworkEdgeInterface {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

input FilterArtworksInput {
  acquireable: Boolean
  additionalGeneIDs: [String]
  after: String
  aggregationPartnerCities: [String]
  aggregations: [ArtworkAggregation]
  artistID: String
  artistIDs: [String]
  artistNationalities: [String]
  artistSeriesID: String
  artistSeriesIDs: [String]
  atAuction: Boolean
  attributionClass: [String]
  before: String
  color: String
  colors: [String]
  dimensionRange: String
  excludeArtworkIDs: [String]
  extraAggregationGeneIDs: [String]
  first: Int
  forSale: Boolean
  geneID: String
  geneIDs: [String]
  height: String
  includeArtworksByFollowedArtists: Boolean
  includeMediumFilterInAggregation: Boolean
  inquireableOnly: Boolean
  keyword: String

  # When true, will only return exact keyword match
  keywordMatchExact: Boolean
  last: Int
  locationCities: [String]
  majorPeriods: [String]

  # When true, will only return `marketable` works (not nude or provocative).
  marketable: Boolean
  marketingCollectionID: String
  materialsTerms: [String]

  # A string from the list of allocations, or * to denote all mediums
  medium: String
  offerable: Boolean
  page: Int
  partnerCities: [String]
  partnerID: ID
  partnerIDs: [String]
  period: String
  periods: [String]
  priceRange: String
  saleID: ID
  size: Int

  # Filter results by Artwork sizes
  sizes: [ArtworkSizes]
  sort: String
  tagID: String
  width: String
}

type FilterPartners {
  aggregations: [PartnersAggregationResults]
  hits: [Partner]
  total: Int
}

type FilterSaleArtworksCounts {
  followedArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  total(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type FollowArtist {
  artist: Artist
  auto: Boolean

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type FollowArtistConnection {
  # A list of edges.
  edges: [FollowArtistEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type FollowArtistCounts {
  artists: Int
}

# An edge in a connection.
type FollowArtistEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowArtist
}

input FollowArtistInput {
  artistID: String!
  clientMutationId: String
  unfollow: Boolean = false
}

type FollowArtistPayload {
  artist: Artist
  clientMutationId: String
  me: Me!

  # Popular artists
  popularArtists(
    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # If true, will exclude followed artists for the user
    excludeFollowedArtists: Boolean

    # Number of results to return
    size: Int
  ): [Artist]
}

type FollowArtists {
  artists: [Artist]
  counts: FollowArtistCounts
}

type FollowGene {
  gene: Gene

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# A connection to a list of items.
type FollowGeneConnection {
  # A list of edges.
  edges: [FollowGeneEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type FollowGeneEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowGene
}

input FollowGeneInput {
  clientMutationId: String
  geneID: String
  unfollow: Boolean = false
}

type FollowGenePayload {
  clientMutationId: String
  gene: Gene
}

input FollowProfileInput {
  clientMutationId: String
  profileID: String
  unfollow: Boolean = false
}

type FollowProfilePayload {
  clientMutationId: String
  me: Me!
  profile: Profile
}

input FollowShowInput {
  clientMutationId: String
  partnerShowID: String
  unfollow: Boolean = false
}

type FollowShowPayload {
  clientMutationId: String
  show: Show
}

type FollowedArtistsArtworksGroup implements Node {
  artists: String
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  publishedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  summary: String
}

# A connection to a list of items.
type FollowedArtistsArtworksGroupConnection {
  # A list of edges.
  edges: [FollowedArtistsArtworksGroupEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedArtistsArtworksGroupEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowedArtistsArtworksGroup
}

type FollowedContent {
  artists: [Artist]
  galleries: [Partner]
}

# A connection to a list of items.
type FollowedFairConnection {
  # A list of edges.
  edges: [FollowedFairEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedFairEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Fair
}

# A connection to a list of items.
type FollowedGalleryConnection {
  # A list of edges.
  edges: [FollowedGalleryEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedGalleryEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Partner
}

type FollowedProfile {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  profile: Profile!
}

# A connection to a list of items.
type FollowedProfileConnection {
  # A list of edges.
  edges: [FollowedProfileEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type FollowedProfileEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: FollowedProfile
}

# A connection to a list of items.
type FollowedShowConnection {
  # A list of edges.
  edges: [FollowedShowEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowedShowEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Show
}

type FollowsAndSaves {
  # A Connection of followed artists by current user
  artistsConnection(
    after: String
    before: String
    fairID: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): FollowArtistConnection
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    private: Boolean = false
    size: Int
    sort: CollectionArtworkSorts = POSITION_DESC
  ): SavedArtworksConnection

  # A list of published artworks by followed artists (grouped by date and artists).
  bundledArtworksByArtistConnection(
    after: String
    before: String
    first: Int
    forSale: Boolean
    last: Int
    sort: ArtworkSorts
  ): FollowedArtistsArtworksGroupConnection

  # A list of the current userâ€™s currently followed fair profiles
  fairsConnection(after: String, before: String, first: Int, last: Int): FollowedFairConnection

  # A list of the current userâ€™s currently followed gallery profiles
  galleriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowedGalleryConnection

  # A list of the current userâ€™s inquiry requests
  genesConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): FollowGeneConnection

  # A list of the current userâ€™s currently followed partner profiles
  profilesConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): FollowedProfileConnection

  # A list of the current userâ€™s currently followed shows
  showsConnection(
    after: String
    before: String

    # A string representing one of the supported cities
    city: String

    # Number of days which will be used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int
    last: Int
    status: EventStatus
  ): FollowedShowConnection
}

enum Format {
  HTML
  MARKDOWN
  PLAIN
}

type FormattedDaySchedules {
  days: String
  hours: String
}

# The `FormattedNumber` type represents a number that can optionally be returnedas a formatted String. It does not try to coerce the type.
scalar FormattedNumber

# An entry from gemini
type GeminiEntry {
  # The token that represents the gemini entry.
  token: String!
}

type Gene implements Node & Searchable {
  artistsConnection(after: String, before: String, first: Int, last: Int): ArtistConnection
  cached: Int
  description(format: Format): String
  displayLabel: String
  displayName: String

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isFollowed: Boolean
  isPublished: Boolean
  meta: GeneMeta!
  mode: String
  name: String

  # A list of genes similar to the specified gene
  similar(
    after: String
    before: String

    # Array of gene ids (not slugs) to exclude, may result in all genes being excluded.
    excludeGeneIDs: [String]
    first: Int
    last: Int
  ): GeneConnection

  # A slug ID.
  slug: ID!
  trendingArtists(sample: Int): [Artist]
}

# A connection to a list of items.
type GeneConnection {
  # A list of edges.
  edges: [GeneEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type GeneEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Gene
}

# A user-facing thematic grouping of Genes
type GeneFamily {
  featuredGeneLinks: [FeaturedGeneLink]
  genes: [Gene]

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String!

  # A slug ID.
  slug: ID!
}

# A connection to a list of items.
type GeneFamilyConnection {
  # A list of edges.
  edges: [GeneFamilyEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type GeneFamilyEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: GeneFamily
}

# Meta tags for Gene pages
type GeneMeta {
  description: String!
}

# Abstract interface shared by every kind of home view section
interface GenericHomeViewSection {
  # The component that is prescribed for this section
  component: HomeViewComponent

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

type GravityMutationError {
  detail: String
  error: String
  fieldErrors: [FieldErrorResults]
  message: String!
  statusCode: Int
  type: String
}

# A Hero Unit
type HeroUnit {
  # Main Hero Unit content.
  body: String!
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Optional image credit line.
  credit: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # The main image for the Hero Unit.
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Optional label for above the title.
  label: String
  link: HeroUnitLink!

  # Dictates the order of the Hero Units.
  position: Int
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # The main headline for the Hero Unit.
  title: String!
}

# A connection to a list of items.
type HeroUnitConnection {
  # A list of edges.
  edges: [HeroUnitEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type HeroUnitEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: HeroUnit
}

type HeroUnitLink {
  # Text for the CTA of the Hero Unit.
  text: String!

  # URL for the CTA of the Hero Unit.
  url: String!
}

# Hero units rail section
type HeroUnitsHomeViewSection implements GenericHomeViewSection & Node {
  # The component that is prescribed for this section
  component: HomeViewComponent
  heroUnitsConnection(after: String, before: String, first: Int, last: Int): HeroUnitConnection

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

type HighestBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  display: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isCancelled: Boolean
  number: Int
}

type Highlights {
  # List of curated genes that are broad collecting. (Meant for e.g. suggestions in on-boarding.)
  broadCollectingGenes: [Gene]

  # Popular artists
  popularArtists(
    # Exclude these ids from results, may result in all artists being excluded.
    excludeArtistIDs: [String]

    # If true, will exclude followed artists for the user
    excludeFollowedArtists: Boolean

    # Number of results to return
    size: Int
  ): [Artist]
}

# Autogenerated input type of HoldInventory
input HoldInventoryInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  expiresInSeconds: Int
  items: [InventoryHoldItemAttributes!]!

  # Globally unique ID for the requester of this hold. Ex. Exchange Order ID.
  referenceId: String!
}

# Autogenerated return type of HoldInventory
type HoldInventoryPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  holdOrErrors: InventoryHoldOrErrorsUnion!
}

type HomePage {
  # Single artist module to show on the home screen.
  artistModule(
    # Module identifier.
    key: HomePageArtistModuleTypes
  ): HomePageArtistModule

  # Artist modules to show on the home screen
  artistModules: [HomePageArtistModule]

  # Single artwork module to show on the home screen
  artworkModule(
    # ID of followed artist to target for related artist rails
    followedArtistID: String

    # ID of generic gene rail to target
    id: String

    # Module key
    key: HomePageArtworkModuleTypes

    # ID of related artist to target for related artist rails
    relatedArtistID: String
  ): HomePageArtworkModule

  # Artwork modules to show on the home screen
  artworkModules(
    # Exclude certain modules
    exclude: [HomePageArtworkModuleTypes] = []

    # Include certain modules and return these modules only
    include: [HomePageArtworkModuleTypes]

    # Maximum number of followed genes to return, disable with a negative number
    maxFollowedGeneRails: Int = 1

    # Maximum number of modules to return, disable limit with a negative number
    maxRails: Int = 8

    # The preferred order of modules, defaults to order returned by Gravity
    order: [HomePageArtworkModuleTypes]
  ): [HomePageArtworkModule]
  fairsModule: HomePageFairsModule

  # A list of enabled hero units to show on the requested platform
  heroUnits(platform: HomePageHeroUnitPlatform!): [HomePageHeroUnit]
  marketingCollectionsModule: HomePageMarketingCollectionsModule
  onboardingModule: HomePageMyCollectionOnboardingModule
  salesModule: HomePageSalesModule
}

type HomePageArtistModule implements Node {
  # A globally unique ID.
  id: ID!

  # Module identifier.
  key: String
  results: [Artist]
}

enum HomePageArtistModuleTypes {
  # The curated trending artists.
  CURATED_TRENDING

  # The most searched for artists.
  POPULAR

  # Artists recommended for the specific user.
  SUGGESTED

  # The trending artists.
  TRENDING
}

type HomePageArtworkModule implements Node {
  context: HomePageArtworkModuleContext

  # A globally unique ID.
  id: ID!
  isDisplayable: Boolean
  key: String
  params: HomePageModulesParams
  results: [Artwork]
  title: String
}

union HomePageArtworkModuleContext =
    Fair
  | FollowArtists
  | Gene
  | HomePageFollowedArtistArtworkModule
  | HomePageRelatedArtistArtworkModule
  | Sale
  | TrendingArtists

enum HomePageArtworkModuleTypes {
  ACTIVE_BIDS
  CURRENT_FAIRS
  FOLLOWED_ARTIST
  FOLLOWED_ARTISTS
  FOLLOWED_GALLERIES
  FOLLOWED_GENES
  GENERIC_GENES
  LIVE_AUCTIONS
  POPULAR_ARTISTS
  RECENTLY_VIEWED_WORKS
  RECOMMENDED_WORKS
  RELATED_ARTISTS
  SAVED_WORKS
  SIMILAR_TO_RECENTLY_VIEWED
  SIMILAR_TO_SAVED_WORKS
}

type HomePageFairsModule {
  results: [Fair]!
}

type HomePageFollowedArtistArtworkModule {
  artist: Artist
}

type HomePageHeroUnit {
  # The image to show, on desktop this defaults to the wide version.
  backgroundImageURL(version: HomePageHeroUnitImageVersion): String
  cached: Int
  creditLine: String
  heading: String
  href: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  linkText: String
  mode: HomePageHeroUnitMode

  # A slug ID.
  slug: ID!
  subtitle: String
  title: String
  titleImageURL(retina: Boolean): String
}

enum HomePageHeroUnitImageVersion {
  NARROW
  WIDE
}

enum HomePageHeroUnitMode {
  CENTERED_DARK
  CENTERED_LIGHT
  LEFT_DARK
  LEFT_LIGHT
  RIGHT_DARK
  RIGHT_LIGHT
}

enum HomePageHeroUnitPlatform {
  DESKTOP
  MARTSY
  MOBILE
}

type HomePageMarketingCollectionsModule {
  results: [MarketingCollection]!
}

type HomePageModulesParams {
  followedArtistID: ID
  geneID: String

  # An optional type-specific ID.
  internalID: ID
  medium: String
  priceRange: String
  relatedArtistID: ID
}

type HomePageMyCollectionOnboardingModule {
  showMyCollectionCard: Boolean!
  showSWACard: Boolean!
}

type HomePageRelatedArtistArtworkModule {
  artist: Artist
  basedOn: Artist
}

type HomePageSalesModule {
  results: [Sale]!
}

# Experimental schema for new home view
type HomeView {
  # A home view section
  section(
    # The ID of the section
    id: String!
  ): HomeViewSection
  sectionsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): HomeViewSectionConnection!
}

# A component specification
type HomeViewComponent {
  # A background image for this section
  backgroundImageURL(version: HomeViewComponentBackgroundImageURLVersion): String

  # A description for this section
  description: String

  # A screen to navigate to when this component is clicked
  href: String

  # A display title for this section
  title: String

  # How this component should be rendered
  type: String
}

enum HomeViewComponentBackgroundImageURLVersion {
  NARROW
  WIDE
}

union HomeViewSection =
    ArticlesRailHomeViewSection
  | ArtistsRailHomeViewSection
  | ArtworksRailHomeViewSection
  | FairsRailHomeViewSection
  | HeroUnitsHomeViewSection
  | MarketingCollectionsRailHomeViewSection

# A connection to a list of items.
type HomeViewSectionConnection {
  # A list of edges.
  edges: [HomeViewSectionEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type HomeViewSectionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: HomeViewSection
}

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

type IdentityVerification {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Email of the identity verification's owner
  email: String

  # A globally unique ID.
  id: ID!

  # ID of the admin or user (self) that initiated this IDV request
  initiatorID: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  invitationExpiresAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Name of the identity verification's owner
  name: String

  # ID of the order the user was placing when this IDV request was created
  orderID: String

  # The overrides associated with an identity verification
  overrides: [IdentityVerificationOverride]

  # Page URL sent to the identify verification's owner
  pageURL: String

  # ID of the auction the user was registering for when this IDV request was created
  saleID: String

  # The scan references (i.e., results) associated with an identity verification
  scanReferences: [IdentityVerificationScanReference]

  # Where the identity verification is in its lifecycle
  state: String!

  # User ID of the identity verification's owner
  userID: String
}

# A connection to a list of items.
type IdentityVerificationConnection {
  # A list of edges.
  edges: [IdentityVerificationEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type IdentityVerificationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: IdentityVerification
}

type IdentityVerificationEmail {
  created_at(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Email of the identity verification's owner
  email: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Name of the identity verification's owner
  name: String

  # Identity verification lifecycle state
  state: String!
  updated_at(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # User ID of the identity verification's owner
  userID: String
}

type IdentityVerificationEmailMutationFailureType {
  mutationError: GravityMutationError
}

type IdentityVerificationEmailMutationSuccessType {
  identityVerification: IdentityVerification
  identityVerificationEmail: IdentityVerificationEmail
    @deprecated(reason: "use identityVerification instead")
}

union IdentityVerificationEmailMutationType =
    IdentityVerificationEmailMutationFailureType
  | IdentityVerificationEmailMutationSuccessType

type IdentityVerificationOverride {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  creator: User

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Overridden state
  newState: String!

  # Un-overridden state
  oldState: String!
  reason: String!

  # User ID of the override's creator
  userID: String
}

type IdentityVerificationOverrideMutationFailure {
  mutationError: GravityMutationError
}

type IdentityVerificationOverrideMutationSuccess {
  identityVerification: IdentityVerification
}

type IdentityVerificationScanReference {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  extractedFirstName: String
  extractedIdFailReason: String
  extractedLastName: String
  extractedSimilarityFailReason: String
  finishedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  jumioID: String!
  result: String
}

type Image {
  aspectRatio: Float!

  # Blurhash code for the image
  blurhash: String
  blurhashDataURL(width: Int = 64): String
  caption: String
  cropped(
    height: Int!

    # Value from 0-100; [1x, 2x]
    quality: [Int!]

    # Version to utilize in order of preference
    version: [String]
    width: Int!
  ): CroppedImageUrl
  deepZoom: DeepZoom
  height: Int
  href: String
  imageURL: String
  imageVersions: [String]

  # An optional type-specific ID.
  internalID: ID
  isDefault: Boolean
  isZoomable: Boolean
  maxTiledHeight: Int
  maxTiledWidth: Int
  orientation: String
  originalHeight: Int
  originalWidth: Int

  # Value to use when `padding-bottom` for fluid image placeholders
  placeholder: String

  # Order position of the image, within the images array of the artwork. (1-indexed)
  position: Int
  resized(
    height: Int

    # Value from 0-100; [1x, 2x]
    quality: [Int!]

    # Version to utilize in order of preference
    version: [String]
    width: Int
  ): ResizedImageUrl
  tileBaseURL: String
  tileFormat: String
  tileSize: Int
  title: String
  url(version: [String]): String
  versions: [String]
  width: Int
}

type ImageURLs {
  normalized: String
}

type InputAddress {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  postalCode: String!
  region: String
}

type InputAddressFields {
  address: InputAddress
  lines: [String]
}

type InquirerCollectorProfile {
  artsyUserSince(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  bio: String
  collectedArtworksCount: Int!
  collectorLevel: Int
  companyName: String
  companyWebsite: String
  confirmedBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  email: String
  emailConfirmed: Boolean
    @deprecated(reason: "emailConfirmed is going to be removed, use isEmailConfirmed instead")
  firstNameLastInitial: String
  followedArtistsCount: Int!

  # The Collector follows the Gallery profile
  hasPartnerFollow: Boolean
  icon: Image

  # A globally unique ID.
  id: ID!
  identityVerified: Boolean
    @deprecated(reason: "identityVerified is going to be removed, use isIdentityVerified instead")
  initials(length: Int = 3): String
  inquiryRequestsCount: Int!
  institutionalAffiliations: String
  intents: [String]
  interestsConnection(after: String, before: String, first: Int, last: Int): UserInterestConnection

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isActiveBidder: Boolean
  isActiveInquirer: Boolean
  isEmailConfirmed: Boolean
  isIdentityVerified: Boolean
  isProfileComplete: Boolean
  lastUpdatePromptAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  location: MyLocation
  loyaltyApplicantAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  name: String

  # Collector's position with relevant institutions
  otherRelevantPositions: String
  owner: User!

  # User ID of the collector profile's owner
  ownerID: ID!

  # Holds information about the engagement a collector profile has with a given partner
  partnerEngagement(
    # The ID of the partner to check for engagement
    partnerID: ID!
  ): PartnerEngagement
  privacy: String
  profession: String
  professionalBuyerAppliedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  professionalBuyerAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  savedArtworksCount: Int!
  selfReportedPurchases: String

  # An artwork-specific paragraph describing the collector.
  summaryParagraph(
    # This can be specified, and is injected in a conversation context for convenience.
    artworkID: String
  ): String
  totalBidsCount: Int!
  userInterests: [UserInterest]!
    @deprecated(reason: "Use \"owner#interestsConnection\" field instead.")
}

union InquiryItemType = Artwork | Show

type InquiryQuestion {
  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  question: String!
}

input InquiryQuestionInput {
  details: String
  questionID: String!
}

# A request to inquire on an artwork
type InquiryRequest {
  contactGallery: Boolean

  # A globally unique ID.
  id: ID!
  inquireable: InquiryItemType
  inquirer: User

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  questions: [String]
  shippingLocation: Location
}

enum IntendedState {
  ACCEPTED
  REJECTED
  REVIEW
}

enum Intents {
  BUY_ART_AND_DESIGN
  FIND_ART_EXHIBITS
  LEARN_ABOUT_ART
  READ_ART_MARKET_NEWS
  RESEARCH_ART_PRICES
  SELL_ART_AND_DESIGN
}

type InventoryHold {
  capturedAt: String
  id: ID!
  items(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): InventoryHoldItemConnection
  referenceId: String!
}

type InventoryHoldItem {
  artworkId: String!
  editionSetId: String
  id: ID!
  quantity: Int!
}

# Attributes for creating or updating an inventory hold item
input InventoryHoldItemAttributes {
  # ID of the artwork
  artworkId: String!

  # ID of edition set
  editionSetId: String
  quantity: Int!
}

# The connection type for InventoryHoldItem.
type InventoryHoldItemConnection {
  # A list of edges.
  edges: [InventoryHoldItemEdge]

  # A list of nodes.
  nodes: [InventoryHoldItem]

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Total count of matching nodes, before pagination
  totalCount: Int!
}

# An edge in a connection.
type InventoryHoldItemEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: InventoryHoldItem
}

# A hold or error object
union InventoryHoldOrErrorUnion = Error | InventoryHold

# A hold or error object
union InventoryHoldOrErrorsUnion = Errors | InventoryHold

# Fields of an invoice (currently from Lewitt)
type Invoice implements Node {
  # A globally unique ID.
  id: ID!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # A type-specific ID likely used as a database ID.
  internalID: ID!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Lewitt's invoice id.
  lewittInvoiceID: String!
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Link to public checkout page.
  paymentURL: String
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # Current state of invoice.
  state: InvoiceState
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )

  # A formatted price with various currency formatting options.
  total(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
    @deprecated(
      reason: "Payment Request was deprecated. The type was kept for legacy client support. [Will be removed in v2]"
    )
}

enum InvoiceState {
  PAID
  REFUNDED
  UNPAID
  VOID
}

# Represents untyped JSON
scalar JSON

type Job {
  # HTML of job listing
  content: String!

  # The url of the job listing on Greenhouse
  externalURL: String!
  id: ID!
  location: String!
  title: String!
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
}

type LatLng {
  lat: Float
  lng: Float
}

enum LengthUnitPreference {
  CM
  IN
}

input LinkAuthenticationMutationInput {
  # Unique Apple user id. **Required** for Apple authentication.
  appleUid: String
  clientMutationId: String

  # User email, only used for Apple authentication.
  email: String

  # JWT used for Apple authentication.
  idToken: String

  # User name, only used for Apple authentication.
  name: String

  # An OAuth token.
  oauthToken: String!

  # A 3rd party account provider, such as facebook or apple.
  provider: AuthenticationProvider!
}

type LinkAuthenticationMutationPayload {
  clientMutationId: String
  me: Me!
}

union ListPrice = Money | PriceRange

enum LiveAuctionRole {
  OPERATOR
  PARTICIPANT
}

type Location {
  address: String
  address2: String
  cached: Int
  city: String
  coordinates: LatLng
  country: String

  # Alternate Markdown-supporting free text representation of a location's opening hours
  dayScheduleText: String
  daySchedules: [DaySchedule]
  display: String
  displayCountry: String
  euShippingLocation: Boolean

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!

  # Union returning opening hours in formatted structure or a string
  openingHours: OpeningHoursUnion
  phone: String
  postalCode: String
  state: String
  summary: String
}

# A connection to a list of items.
type LocationConnection {
  # A list of edges.
  edges: [LocationEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type LocationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Location
}

scalar Long

# A lot in an auction containing merged SaleArtwork and LotState data, stitched from causality.
type Lot implements Node {
  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  lot: AuctionsLotState

  # The watched saleArtwork object.
  saleArtwork: SaleArtwork

  # A slug ID.
  slug: ID!
}

# A connection to a list of items.
type LotConnection {
  # A list of edges.
  edges: [LotEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type LotEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Lot
}

type LotStanding {
  # Your bid if it is currently winning
  activeBid: BidderPosition
  bidder: Bidder

  # You are winning and reserve is met
  isHighestBidder: Boolean

  # You are the leading bidder without regard to reserve
  isLeadingBidder: Boolean

  # Your most recent bidâ€”which is not necessarily winning (may be higher or lower)
  mostRecentBid: BidderPosition
  sale: Sale
  saleArtwork: SaleArtwork
}

type MarkAllNotificationsAsReadFailure {
  mutationError: GravityMutationError
}

input MarkAllNotificationsAsReadInput {
  clientMutationId: String
}

type MarkAllNotificationsAsReadPayload {
  clientMutationId: String
  responseOrError: MarkAllNotificationsAsReadResponseOrError
}

union MarkAllNotificationsAsReadResponseOrError =
    MarkAllNotificationsAsReadFailure
  | MarkAllNotificationsAsReadSuccess

type MarkAllNotificationsAsReadSuccess {
  me: Me!
  success: Boolean
}

type MarkNotificationAsReadFailure {
  mutationError: GravityMutationError
}

input MarkNotificationAsReadInput {
  clientMutationId: String
  id: String!
}

type MarkNotificationAsReadPayload {
  clientMutationId: String
  responseOrError: MarkNotificationAsReadResponseOrError
}

union MarkNotificationAsReadResponseOrError =
    MarkNotificationAsReadFailure
  | MarkNotificationAsReadSuccess

type MarkNotificationAsReadSuccess {
  me: Me!
  success: Boolean
}

type MarkNotificationsAsSeenFailure {
  mutationError: GravityMutationError
}

input MarkNotificationsAsSeenInput {
  clientMutationId: String

  # Until what point of time notifications were seen. ISO8601 standard-formatted string.
  until: String!
}

type MarkNotificationsAsSeenPayload {
  clientMutationId: String
  responseOrError: MarkNotificationsAsSeenResponseOrError
}

union MarkNotificationsAsSeenResponseOrError =
    MarkNotificationsAsSeenFailure
  | MarkNotificationsAsSeenSuccess

type MarkNotificationsAsSeenSuccess {
  me: Me!
  success: Boolean
}

type MarkdownContent {
  content(format: Format): String
}

# Market Price Insights
type MarketPriceInsights {
  annualLotsSold: Int
  annualValueSoldCents: BigInt
  artistId: ID
  artistName: String
  artsyQInventory: Int
  createdAt: ISO8601DateTime
  demandRank: Float
  demandTrend: Float
  highRangeCents: BigInt
  id: ID!
  largeHighRangeCents: BigInt
  largeLowRangeCents: BigInt
  largeMidRangeCents: BigInt
  lastAuctionResultDate: ISO8601DateTime
  liquidityRank: Float
  lotsSoldLast12Months: Int
  lotsSoldLast24Months: Int
  lotsSoldLast36Months: Int
  lotsSoldLast48Months: Int
  lotsSoldLast60Months: Int
  lotsSoldLast72Months: Int
  lotsSoldLast84Months: Int
  lotsSoldLast96Months: Int
  lowRangeCents: BigInt
  medianSaleOverEstimatePercentage: Int
  medianSalePriceLast36Months: BigInt
  medianSalePriceLast96Months: BigInt
  medianSaleToEstimateRatio: Float
  medium: String
  mediumHighRangeCents: BigInt
  mediumLowRangeCents: BigInt
  mediumMidRangeCents: BigInt
  midRangeCents: BigInt
  sellThroughRate: Float
  smallHighRangeCents: BigInt
  smallLowRangeCents: BigInt
  smallMidRangeCents: BigInt
  updatedAt: ISO8601DateTime
}

# The connection type for MarketPriceInsights.
type MarketPriceInsightsConnection {
  # A list of edges.
  edges: [MarketPriceInsightsEdge]

  # A list of nodes.
  nodes: [MarketPriceInsights]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type MarketPriceInsightsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: MarketPriceInsights
}

type MarketingCollection {
  artworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  category: String!
  createdAt: ISO8601DateTime!
  credit: String

  # HTML description, derived from the markdown description
  description: String
  descriptionMarkdown: String
  featuredArtistExclusionIds: [String!]!
  headerImage: String

  # Unique ID for this marketing collection
  id: ID!

  # Unique ID for this marketing collection
  internalID: ID!

  # Returns true if this collection has linked collections with members
  isDepartment: Boolean!
  isFeaturedArtistContent: Boolean!
  linkedCollections: [MarketingCollectionGroup!]!
  priceGuidance: Float
  query: MarketingCollectionQuery!

  # Returns collections by the same artist if more than 4 exist, otherwise returns collections from the same category
  relatedCollections(size: Int = 10): [MarketingCollection!]!

  # ID of an artwork with highest merchandis ability
  representativeArtworkID: String

  # Show featured artists section in header. Defaults to true
  showFeaturedArtists: Boolean!

  # Show artworks rail in header. Defaults to true
  showHeaderArtworksRail: Boolean!
  slug: String!
  thumbnail: String @deprecated(reason: "If querying via Metaphysics use thumbnailImage instead.")
  thumbnailImage: Image
  title: String!
  updatedAt: ISO8601DateTime!
}

type MarketingCollectionCategory {
  collections: [MarketingCollection!]!
  name: String!
}

# A connection to a list of items.
type MarketingCollectionConnection {
  # A list of edges.
  edges: [MarketingCollectionEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type MarketingCollectionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: MarketingCollection
}

type MarketingCollectionGroup {
  groupType: MarketingCollectionGroupTypeEnum!
  internalID: ID!
  members: [MarketingCollection!]!
  name: String!
}

enum MarketingCollectionGroupTypeEnum {
  # Artist-focused collections, not to be confused with actual ArtistSeries
  ArtistSeries
  FeaturedCollections
  OtherCollections
}

type MarketingCollectionQuery {
  artistIDs: [String!]
  geneIDs: [String!]

  # Is always null, will be eliminated later
  id: ID

  # Is always null, will be eliminated later
  internalID: ID
  keyword: String
  tagID: String
}

# A marketing collections rail section in the home view
type MarketingCollectionsRailHomeViewSection implements GenericHomeViewSection & Node {
  # The component that is prescribed for this section
  component: HomeViewComponent

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  marketingCollectionsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): MarketingCollectionConnection
}

union Match =
    Article
  | Artist
  | Artwork
  | Fair
  | Feature
  | Gene
  | Page
  | Profile
  | Sale
  | Show
  | Tag

# A connection to a list of items.
type MatchConnection {
  # A list of edges.
  edges: [MatchEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type MatchEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Match
}

type Me implements Node {
  addressConnection(after: String, before: String, first: Int, last: Int): UserAddressConnection
  alert(id: String!): Alert
  alertsConnection(
    after: String
    attributes: PreviewSavedSearchAttributes
    before: String
    first: Int
    last: Int
    sort: AlertsConnectionSortEnum
  ): AlertConnection!

  # A connection of artist recommendations for the current user.
  artistRecommendations(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
  ): ArtistConnection

  # A list of the current userâ€™s inquiry requests
  artworkInquiriesConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkInquiryConnection

  # A connection of artwork recommendations for the current user.
  artworkRecommendations(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
  ): ArtworkConnection

  # A list of the auction results by followed artists
  auctionResultsByFollowedArtists(
    after: String

    # Allow auction results with empty created date values
    allowEmptyCreatedDates: Boolean = true
    before: String

    # Filter auction results by category (medium)
    categories: [String]

    # Filter auction results by earliest created at year
    earliestCreatedYear: Int
    first: Int
    last: Int

    # Filter auction results by latest created at year
    latestCreatedYear: Int

    # Filter auction results by organizations
    organizations: [String]

    # When true, will only return records for allowed artists.
    recordsTrusted: Boolean = false

    # Filter auction results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: AuctionResultSorts

    # State of the returned auction results (can be past, upcoming, or all)
    state: AuctionResultsState = ALL
  ): AuctionResultConnection
  auctionsLotStandingConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): AuctionsLotStandingConnection!

  # A list of authenticated external services
  authentications: [AuthenticationType!]!

  # A list of the current user's bank accounts
  bankAccounts(
    after: String
    before: String
    first: Int
    last: Int
    type: BankAccountTypes
  ): BankAccountConnection

  # Returns a single bidder position
  bidderPosition(id: String!): BidderPositionResult

  # A list of the current user's bidder positions
  bidderPositions(
    # Only the bidder positions on a specific artwork
    artworkID: String

    # Only the most recent bidder positions per artwork.
    current: Boolean

    # Only the bidder positions for a specific auction
    saleID: String
  ): [BidderPosition]

  # The current user's status relating to bids on artworks
  bidderStatus(artworkID: String!, saleID: String!): LotStanding

  # A list of the current userâ€™s bidder registrations
  bidders(
    # Limit results to bidders in active auctions
    active: Boolean

    # The slug or ID of a Sale
    saleID: String
  ): [Bidder]
  bio: String

  # Whether user is allowed to request email confirmation
  canRequestEmailConfirmation: Boolean!

  # A collection belonging to the current user
  collection(id: String!): Collection
  collectionsConnection(
    after: String
    before: String
    default: Boolean
    first: Int
    includesArtworkID: String
    last: Int
    page: Int
    saves: Boolean
    size: Int
    sort: CollectionSorts
  ): CollectionsConnection
  collectorLevel: Int

  # Current user's collector profile.
  collectorProfile: CollectorProfileType

  # A conversation, usually between a user and a partner
  conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Conversations, usually between a user and partner.
  conversationsConnection(
    after: String
    artistId: String
    before: String
    dismissed: Boolean
    first: Int
    fromId: String
    hasMessage: Boolean
    hasReply: Boolean
    last: Int
    partnerId: String
    toBeReplied: Boolean
    type: ConversationsInputMode = USER
  ): ConversationConnection
  counts: MeCounts
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A list of the current userâ€™s credit cards
  creditCards(after: String, before: String, first: Int, last: Int): CreditCardConnection

  # Currency preference of the user
  currencyPreference: CurrencyPreference!
  email: String

  # User has confirmed their email address
  emailConfirmed: Boolean!
    @deprecated(reason: "emailConfirmed is going to be removed, use isEmailConfirmed instead")

  # Frequency of marketing emails.
  emailFrequency: String
  followsAndSaves: FollowsAndSaves
  hasCreditCards: Boolean
  hasPassword: Boolean!
  hasQualifiedCreditCards: Boolean
  hasSecondFactorEnabled: Boolean!
  icon: Image

  # A globally unique ID.
  id: ID!

  # An identity verification that the user has access to
  identityVerification(
    # ID of the IdentityVerification
    id: String!
  ): IdentityVerification
  identityVerified: Boolean
    @deprecated(reason: "identityVerified is going to be removed, use isIdentityVerified instead")
  initials(length: Int = 3): String
  inquiryIntroduction: String

  # A type-specific ID.
  internalID: ID!

  # An invoice
  invoice(
    # The ID of the Conversation
    conversationId: String!

    # The ID of the invoice
    invoiceId: String!
  ): Invoice
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )
  isCollector: Boolean!

  # User has confirmed their email address
  isEmailConfirmed: Boolean!
  isIdentityVerified: Boolean

  # List of lab features for this user
  labFeatures: [String!]!

  # Length unit preference of the user
  lengthUnitPreference: LengthUnitPreference!
  location: MyLocation

  # The current user's status relating to bids on artworks
  lotStanding(artworkID: String, saleArtworkID: String, saleID: String): LotStanding

  # A list of the current user's auction standings for given lots
  lotStandings(
    # Only includes lots on which you have a leading bidder position.
    activePositions: Boolean

    # Only the lot standings on a specific artwork
    artworkID: String

    # Only the lot standings for currently open or closed auctions.
    live: Boolean
    saleArtworkID: String

    # Only the lot standings for a specific auction
    saleID: String
  ): [LotStanding]

  # Sale Artworks search results
  lotsByFollowedArtistsConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    biddableSale: Boolean
    estimateRange: String
    excludeClosedLots: Boolean
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    marketable: Boolean
    page: Int
    saleID: ID

    # Same as saleID argument, but matches the argument type of `sale(id: 'foo')` root field
    saleSlug: String
    size: Int
    sort: String
    userId: String
  ): SaleArtworksConnection
  myBids: MyBids

  # A list of auction results from artists in My Collection
  myCollectionAuctionResults(
    after: String

    # Allow auction results with empty created date values
    allowEmptyCreatedDates: Boolean = true
    before: String

    # Filter auction results by category (medium)
    categories: [String]

    # Filter auction results by earliest created at year
    earliestCreatedYear: Int
    first: Int
    last: Int

    # Filter auction results by latest created at year
    latestCreatedYear: Int

    # Filter auction results by organizations
    organizations: [String]

    # When true, will only return records for allowed artists.
    recordsTrusted: Boolean = false

    # Filter auction results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: AuctionResultSorts

    # State of the returned auction results (can be past, upcoming, or all)
    state: AuctionResultsState = ALL
  ): AuctionResultConnection
  myCollectionConnection(
    after: String

    # Filter by artist IDs
    artistIDs: [String!]
    before: String

    # Exclude artworks that have been purchased on Artsy and automatically added to the collection.
    excludePurchasedArtworks: Boolean = false
    first: Int

    # Show only artworks from target supply artists
    includeOnlyTargetSupply: Boolean = false
    last: Int
    page: Int
    size: Int
    sort: MyCollectionArtworkSorts

    # Sort by most recent price insight updates, filter out artworks without insights and return artworks uniq by artist & medium.
    sortByLastAuctionResultDate: Boolean = false
  ): MyCollectionConnection

  # Info about the current user's my-collection
  myCollectionInfo: MyCollectionInfo
  name: String

  # A connection of new works by artists the user interacted with (sorted by publication date).
  newWorksByInterestingArtists(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
  ): ArtworkConnection

  # A list of artworks from galleries the user follows.
  newWorksFromGalleriesYouFollowConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection

  # Retrieve one user's notification by notification ID
  notification(
    # The ID of the Notification
    id: String!
  ): Notification
  orders(
    after: String
    before: String
    first: Int
    last: Int
    mode: CommerceOrderModeEnum
    sellerId: String
    sort: CommerceOrderConnectionSortEnum
    states: [CommerceOrderStateEnum!]
  ): CommerceOrderConnectionWithTotalCount

  # Collector's position with relevant institutions
  otherRelevantPosition: String @deprecated(reason: "Use `otherRelevantPositions` instead")

  # Collector's position with relevant institutions
  otherRelevantPositions: String
  paddleNumber: String
  partnerOffersConnection(
    after: String
    artworkID: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
    sort: PartnerOfferToCollectorSorts
  ): PartnerOfferToCollectorConnection

  # A list of the current userâ€™s managed partners
  partners(size: Int): [Partner]

  # The user's most current pending identity verification, if it exists
  pendingIdentityVerification: IdentityVerification
  phone: String
  phoneNumber: PhoneNumberType
  priceRange: String
  priceRangeMax: Float
  priceRangeMin: Float
  privacy: String
  profession: String

  # The art quiz of a logged-in user
  quiz: Quiz!

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive order notifications
  receiveOrderNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive partner offer notifications
  receivePartnerOfferNotification: Boolean

  # This user should receive partner show notifications
  receivePartnerShowNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean

  # This user should receive viewing room notifications
  receiveViewingRoomNotification: Boolean
  recentlyViewedArtworkIds: [String]!

  # A list of the current userâ€™s recently viewed artworks.
  recentlyViewedArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection
  recommendedArtworks(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
  ): ArtworkConnection
  saleRegistrationsConnection(
    after: String
    auctionState: AuctionState
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts

    # If present, will search by term
    term: String
  ): SaleRegistrationConnection
  savedSearch(criteria: SearchCriteriaAttributes, id: ID): SearchCriteria
  savedSearchesConnection(
    after: String

    # Returns saved searches associated with the provided artist IDs
    artistIDs: [String!]
    before: String
    first: Int
    last: Int
    sort: SavedSearchesSortEnum
  ): SearchCriteriaConnection
  secondFactors(kinds: [SecondFactorKind]): [SecondFactor]
  shareFollows: Boolean!

  # A list of shows by followed artists
  showsByFollowedArtists(
    after: String
    before: String
    first: Int
    last: Int
    sort: ShowSorts = CREATED_AT_DESC

    # Filter shows by chronological event status
    status: EventStatus = CURRENT
  ): ShowConnection

  # A list of shows for the user (pagination logic might be broken)
  showsConnection(
    after: String
    before: String
    first: Int

    # Include shows near the user's location based on the IP address
    includeShowsNearIpBasedLocation: Boolean = false

    # When set, this IP address will be used to look up the location, instead of the request's IP address.
    ip: String
    last: Int

    # Include shows within a radius of the provided location
    near: Near
    sort: ShowSorts = CREATED_AT_DESC

    # Filter shows by chronological event status
    status: EventStatus = CURRENT
  ): ShowConnection

  # A list of artworks similar to recently viewed artworks.
  similarToRecentlyViewedConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection

  # A list of the current userâ€™s submissions
  submissionsConnection(
    after: String
    before: String
    first: Int
    last: Int
    states: [ArtworkConsignmentSubmissionState]
  ): ArtworkConsignmentSubmissionConnection
  type: String

  # The count of conversations with unread messages.
  unreadConversationCount: Int!

  # A count of unread notifications.
  unreadNotificationsCount: Int!

  # A count of unseen notifications.
  unseenNotificationsCount: Int!

  # Get a user interest
  userInterest(
    # The ID of the UserInterest
    id: String
  ): UserInterest
  userInterestsConnection(
    after: String
    before: String

    # UserInterest category to select. 'collected_before' or 'interested_in_collecting' category
    category: UserInterestCategory
    first: Int

    # Id of the user interests to return if found. Can be an 'Artist' Id or a 'Gene' Id
    interestID: String

    # UserInterest InterestType to select. 'Artist' or 'Gene' type
    interestType: UserInterestInterestType
    last: Int
    page: Int
    size: Int
  ): UserInterestConnection

  # A list of lots a user is watching.
  watchedLotConnection(after: String, before: String, first: Int, last: Int): LotConnection
}

type MeCounts {
  followedArtists: Int!

  # Returns the total count of followed profiles. There is currently no way to filter this count by `owner_type`.
  followedProfiles: Int!
  savedArtworks: Int!
  savedSearches: Int!
}

type MergeArtistsFailure {
  mutationError: GravityMutationError
}

# A map describing the field-level overrides that should be part of this merge.
# - Each **key** is a field name such as `nationality`
# - Each **value** is a BSON ID that indicates the artist record from which we will _prefer_ the value for the given field
input MergeArtistsFieldOverrides {
  # ID of the artist record that contains the `birthday` value that we want to preserve.
  birthday: ID

  # ID of the artist record that contains the `deathday` value that we want to preserve.
  deathday: ID

  # ID of the artist record that contains the `gender` value that we want to preserve.
  gender: ID

  # ID of the artist record that contains the `hometown` value that we want to preserve.
  hometown: ID

  # ID of the artist record that contains the `location` value that we want to preserve.
  location: ID

  # ID of the artist record that contains the `nationality` value that we want to preserve.
  nationality: ID
}

input MergeArtistsMutationInput {
  # The database ID of the "bad" artist record(s), which will be **discarded** after the merge
  badIds: [String!]!
  clientMutationId: String

  # The database ID of the "good" artist record, which will be **kept** after the merge. Relevant fields and associations from the bad records will be merged into this one.
  goodId: String!

  # A map describing the field-level overrides that should be part of this merge.
  overrides: MergeArtistsFieldOverrides
}

type MergeArtistsMutationPayload {
  clientMutationId: String

  # On success: the "good" artist record, which was kept after the merge. Upon a successful merge this record may have been updated.
  mergeArtistsResponseOrError: MergeArtistsResponseOrError
}

union MergeArtistsResponseOrError = MergeArtistsFailure | MergeArtistsSuccess

type MergeArtistsSuccess {
  artist: Artist
}

# A message in a conversation.
type Message implements Node {
  attachments: [Attachment]

  # Unaltered text if possible, otherwise `body`: a parsed/sanitized version from Sendgrid.
  body: String

  # Masked emails w/ display name of the recipients in copy.
  cc: [String!]!
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  deliveries: [Delivery]
  from: MessageInitiator

  # A globally unique ID.
  id: ID!

  # Impulse message id.
  impulseID: String! @deprecated(reason: "Prefer internalID")

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  invoice: Invoice
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )

  # True if message is the first in the conversation.
  isFirstMessage: Boolean

  # True if message is from the user to the partner.
  isFromUser: Boolean

  # True if message is an invoice message
  isInvoice: Boolean
    @deprecated(
      reason: "Payment Request was deprecated. The field was kept for legacy client support. [Will be removed in v2]"
    )

  # True if message was sent on the platform. False if sent via an email client.
  isMessageSentOnPlatform: Boolean
  sentAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Masked emails w/ display name of the recipients.
  to: [String!]!
}

# A connection to a list of items.
type MessageConnection {
  # A list of edges.
  edges: [MessageEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type MessageEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Message
}

# The participant who sent the message.
type MessageInitiator {
  email: String
  name: String
}

union MessageOrConversationEventType = ConversationEvent | Message

# A connection to a list of items.
type MessageOrConversationEventTypeConnection {
  # A list of edges.
  edges: [MessageOrConversationEventTypeEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type MessageOrConversationEventTypeEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: MessageOrConversationEventType
}

type MetaphysicsService {
  environment: String!
  queryTracing: Boolean!
  stitching: Boolean!
  stitchingConvection: Boolean!
  stitchingExchange: Boolean!
  stitchingGravity: Boolean!
}

type Money {
  # The ISO-4217 alphabetic currency code, as per https://en.wikipedia.org/wiki/ISO_4217
  currencyCode: String!

  # A pre-formatted price.
  display: String

  # An amount of money expressed in major units (like dollars).
  major(
    # ISO-4217 code of a destination currency for conversion
    convertTo: String
  ): Float!

  # An amount of money expressed in minor units (like cents).
  minor: Long!
}

# A money object with amount in minor currency and a currency code, or an error object
union MoneyOrErrorUnion = Error

type Mutation {
  acceptPartnerAgreement(
    # Parameters for AcceptPartnerAgreement
    input: AcceptPartnerAgreementInput!
  ): AcceptPartnerAgreementPayload
  addAssetToConsignmentSubmission(
    # Parameters for AddAssetToConsignmentSubmission
    input: AddAssetToConsignmentSubmissionInput!
  ): AddAssetToConsignmentSubmissionPayload
  addAssetsToConsignmentSubmission(
    # Parameters for AddAssetsToConsignmentSubmission
    input: AddAssetsToConsignmentSubmissionInput!
  ): AddAssetsToConsignmentSubmissionPayload

  # adds an item to an ordered set.
  addOrderedSetItem(input: addOrderedSetItemMutationInput!): addOrderedSetItemMutationPayload

  # Add a role associated with a user
  addUserRole(input: addUserRoleMutationInput!): addUserRoleMutationPayload
  addUserToSubmission(
    # Parameters for AddUserToSubmissionMutation
    input: AddUserToSubmissionMutationInput!
  ): AddUserToSubmissionMutationPayload

  # Creates a new feature flag
  adminCreateFeatureFlag(input: AdminCreateFeatureFlagInput!): AdminCreateFeatureFlagPayload

  # Deletes a feature flag
  adminDeleteFeatureFlag(input: AdminDeleteFeatureFlagInput!): AdminDeleteFeatureFlagPayload

  # Toggles a feature flag on or off for a given environment
  adminToggleFeatureFlag(input: AdminToggleFeatureFlagInput!): AdminToggleFeatureFlagPayload

  # Updates a feature flag
  adminUpdateFeatureFlag(input: AdminUpdateFeatureFlagInput!): AdminUpdateFeatureFlagPayload

  # Add / remove artworks to / from collections
  artworksCollectionsBatchUpdate(
    input: ArtworksCollectionsBatchUpdateInput!
  ): ArtworksCollectionsBatchUpdatePayload

  # Update all artworks that belong to the partner
  bulkUpdatePartnerArtworks(
    input: BulkUpdatePartnerArtworksMutationInput!
  ): BulkUpdatePartnerArtworksMutationPayload
  captureHold(
    # Parameters for CaptureHold
    input: CaptureHoldInput!
  ): CaptureHoldPayload

  # Creates a pending offer on an pending order.
  commerceAddInitialOfferToOrder(
    # Parameters for AddInitialOfferToOrder
    input: CommerceAddInitialOfferToOrderInput!
  ): CommerceAddInitialOfferToOrderPayload

  # Approves an order. Different procedures will be done depending on the payment method.
  # In general, approving an order will: debit the comission exemption; commit a
  # tax transaction; capture a hold or charge the payment; book the shippment.
  # If the payment method is asychronous, a pre-approval operation will be done instead.
  commerceApproveOrder(
    # Parameters for ApproveOrder
    input: CommerceApproveOrderInput!
  ): CommerceApproveOrderPayload

  # Allows the buyer to accept a seller's offer.
  # Once the offer is accepted, the order will be effectively approved.
  commerceBuyerAcceptOffer(
    # Parameters for BuyerAcceptOffer
    input: CommerceBuyerAcceptOfferInput!
  ): CommerceBuyerAcceptOfferPayload

  # Creates a pending counter offer on an order.
  commerceBuyerCounterOffer(
    # Parameters for BuyerCounterOffer
    input: CommerceBuyerCounterOfferInput!
  ): CommerceBuyerCounterOfferPayload

  # Allows the buyer to reject a seller's offer.
  # Once the offer is rejected, the order will be effectively cancelled.
  commerceBuyerRejectOffer(
    # Parameters for BuyerRejectOffer
    input: CommerceBuyerRejectOfferInput!
  ): CommerceBuyerRejectOfferPayload

  # Confirms the fulfillment of an order
  commerceConfirmFulfillment(
    # Parameters for ConfirmFulfillment
    input: CommerceConfirmFulfillmentInput!
  ): CommerceConfirmFulfillmentPayload

  # Confirms the pickup of an order
  commerceConfirmPickup(
    # Parameters for ConfirmPickup
    input: CommerceConfirmPickupInput!
  ): CommerceConfirmPickupPayload

  # Creates a bank debit setup intent in Stripe for a pending order. Also creates an internal Transaction record.
  commerceCreateBankDebitSetupForOrder(
    # Parameters for CreateBankDebitSetupForOrder
    input: CommerceCreateBankDebitSetupForOrderInput!
  ): CommerceCreateBankDebitSetupForOrderPayload

  # Creates an offer Order with inquiry as source.
  commerceCreateInquiryOfferOrderWithArtwork(
    # Parameters for CreateInquiryOfferOrderWithArtwork
    input: CommerceCreateInquiryOfferOrderWithArtworkInput!
  ): CommerceCreateInquiryOfferOrderWithArtworkPayload

  # Creates a buy Order with inquiry as source.
  commerceCreateInquiryOrderWithArtwork(
    # Parameters for CreateInquiryOrderWithArtwork
    input: CommerceCreateInquiryOrderWithArtworkInput!
  ): CommerceCreateInquiryOrderWithArtworkPayload

  # Creates an offer Order with artwork_page as source.
  commerceCreateOfferOrderWithArtwork(
    # Parameters for CreateOfferOrderWithArtwork
    input: CommerceCreateOfferOrderWithArtworkInput!
  ): CommerceCreateOfferOrderWithArtworkPayload

  # Creates a buy Order with artwork_page as source.
  commerceCreateOrderWithArtwork(
    # Parameters for CreateOrderWithArtwork
    input: CommerceCreateOrderWithArtworkInput!
  ): CommerceCreateOrderWithArtworkPayload

  # Creates a buy Order with partner_offer as source.
  commerceCreatePartnerOfferOrder(
    # Parameters for CreatePartnerOfferOrder
    input: CommerceCreatePartnerOfferOrderInput!
  ): CommerceCreatePartnerOfferOrderPayload

  # Fixes a failed payment. Essentially, it will update the credit card on the order and attempt to approve it again.
  commerceFixFailedPayment(
    # Parameters for FixFailedPayment
    input: CommerceFixFailedPaymentInput!
  ): CommerceFixFailedPaymentPayload

  # Fulfill an order with one Fulfillment, it sets this fulfillment to each line item in order
  commerceFulfillAtOnce(
    # Parameters for FulfillAtOnce
    input: CommerceFulfillAtOnceInput!
  ): CommerceFulfillAtOncePayload

  # Selects an ARTA shipping option for an order, updating the LineItem#selected_shipping_quote_id.
  commerceSelectShippingOption(
    # Parameters for SelectShippingOption
    input: CommerceSelectShippingOptionInput!
  ): CommerceSelectShippingOptionPayload

  # Accepts a buyer offer on an order from the seller perspective. This will essentially approve the order.
  commerceSellerAcceptOffer(
    # Parameters for SellerAcceptOffer
    input: CommerceSellerAcceptOfferInput!
  ): CommerceSellerAcceptOfferPayload

  # Seller accepts a provisional offer from buyer.
  # It submits a counter offer back to the buyer to review, with final totals defined such as tax, shipping, etc.
  commerceSellerAcceptProvisionalOffer(
    # Parameters for SellerAcceptProvisionalOffer
    input: CommerceSellerAcceptProvisionalOfferInput!
  ): CommerceSellerAcceptProvisionalOfferPayload

  # Creates a seller counter offer.
  commerceSellerCounterOffer(
    # Parameters for SellerCounterOffer
    input: CommerceSellerCounterOfferInput!
  ): CommerceSellerCounterOfferPayload

  # Rejects a buyer offer on an order. This will essentially cancel the order.
  commerceSellerRejectOffer(
    # Parameters for SellerRejectOffer
    input: CommerceSellerRejectOfferInput!
  ): CommerceSellerRejectOfferPayload

  # Sets the payment method for an order.
  commerceSetPayment(
    # Parameters for SetPayment
    input: CommerceSetPaymentInput!
  ): CommerceSetPaymentPayload

  # Creates a Stripe payment intent for ACH payments.
  commerceSetPaymentByStripeIntent(
    # Parameters for SetPaymentByStripeIntent
    input: CommerceSetPaymentByStripeIntentInput!
  ): CommerceSetPaymentByStripeIntentPayload

  # Sets shipping information on an order based on the fulfillment type.
  # Additionally, it recalculates and updates the order's total costs and tax values accordingly.
  # If 'address_verified_by' is provided, a server side address verification will be performed accordingly.
  commerceSetShipping(
    # Parameters for SetShipping
    input: CommerceSetShippingInput!
  ): CommerceSetShippingPayload

  # Submits an order. If the order is from a private sale, it will also approve the order.
  commerceSubmitOrder(
    # Parameters for SubmitOrder
    input: CommerceSubmitOrderInput!
  ): CommerceSubmitOrderPayload

  # Submits an order with an offer.
  commerceSubmitOrderWithOffer(
    # Parameters for SubmitOrderWithOffer
    input: CommerceSubmitOrderWithOfferInput!
  ): CommerceSubmitOrderWithOfferPayload

  # Submits a pending offer.
  commerceSubmitPendingOffer(
    # Parameters for SubmitPendingOffer
    input: CommerceSubmitPendingOfferInput!
  ): CommerceSubmitPendingOfferPayload

  # Updates the value of impulse_conversation_id on an order
  commerceUpdateImpulseConversationId(
    # Parameters for UpdateImpulseConversationId
    input: CommerceUpdateImpulseConversationIdInput!
  ): CommerceUpdateImpulseConversationIdPayload
  confirmPassword(
    # Parameters for ConfirmPassword
    input: ConfirmPasswordInput!
  ): ConfirmPasswordPayload
  convectionCreateConsignmentSubmission(
    # Parameters for CreateSubmissionMutation
    input: CreateSubmissionMutationInput!
  ): CreateSubmissionMutationPayload

  # Create an account request
  createAccountRequest(
    input: CreateAccountRequestMutationInput!
  ): CreateAccountRequestMutationPayload

  # Create an alert
  createAlert(input: createAlertInput!): createAlertPayload
  createAndSendBackupSecondFactor(
    # Parameters for CreateAndSendBackupSecondFactor
    input: CreateAndSendBackupSecondFactorInput!
  ): CreateAndSendBackupSecondFactorPayload
  createAppSecondFactor(
    # Parameters for CreateAppSecondFactor
    input: CreateAppSecondFactorInput!
  ): CreateAppSecondFactorPayload

  # Create an artist
  createArtist(input: CreateArtistMutationInput!): CreateArtistMutationPayload
  createBackupSecondFactors(
    # Parameters for CreateBackupSecondFactors
    input: CreateBackupSecondFactorsInput!
  ): CreateBackupSecondFactorsPayload
  createBankDebitSetup(
    # Parameters for CreateBankDebitSetup
    input: CreateBankDebitSetupInput!
  ): CreateBankDebitSetupPayload

  # Create a bidder
  createBidder(input: CreateBidderInput!): CreateBidderPayload

  # Creates a bidder position
  createBidderPosition(input: BidderPositionInput!): BidderPositionPayload

  # Creates Artist Career Highlight.
  createCareerHighlight(input: CreateCareerHighlightInput!): CreateCareerHighlightPayload

  # Create a collection
  createCollection(input: createCollectionInput!): createCollectionPayload

  # Make inquiry about consignments
  createConsignmentInquiry(
    input: CreateConsignmentInquiryMutationInput!
  ): CreateConsignmentInquiryMutationPayload
  createConsignmentOffer(
    # Parameters for CreateOfferMutation
    input: CreateOfferMutationInput!
  ): CreateOfferMutationPayload
  createConsignmentOfferResponse(
    # Parameters for CreateOfferResponseMutation
    input: CreateOfferResponseMutationInput!
  ): CreateOfferResponseMutationPayload
  createConsignmentSubmission(
    # Parameters for CreateSubmissionMutation
    input: CreateSubmissionMutationInput!
  ): CreateSubmissionMutationPayload

  # Create a credit card
  createCreditCard(input: CreditCardInput!): CreditCardPayload

  # Creates a feature.
  createFeature(input: CreateFeatureMutationInput!): CreateFeatureMutationPayload

  # Creates a featured link.
  createFeaturedLink(input: CreateFeaturedLinkMutationInput!): CreateFeaturedLinkMutationPayload

  # Attach an gemini asset to a consignment submission
  createGeminiEntryForAsset(
    input: CreateGeminiEntryForAssetInput!
  ): CreateGeminiEntryForAssetPayload

  # Creates a hero unit.
  createHeroUnit(input: CreateHeroUnitMutationInput!): CreateHeroUnitMutationPayload

  # Create an identity verification override
  createIdentityVerificationOverride(
    input: CreateIdentityVerificationOverrideMutationInput!
  ): CreateIdentityVerificationOverrideMutationPayload
  createImage(
    # Parameters for CreateImage
    input: CreateImageInput!
  ): CreateImagePayload
  createInquiryOfferOrder(
    input: CommerceCreateInquiryOfferOrderWithArtworkInput!
  ): CommerceCreateInquiryOfferOrderWithArtworkPayload

  # Creates an order and links the conversation to it
  createInquiryOrder(
    input: CommerceCreateInquiryOrderWithArtworkInput!
  ): CommerceCreateInquiryOrderWithArtworkPayload

  # Creates an ordered set.
  createOrderedSet(input: CreateOrderedSetMutationInput!): CreateOrderedSetMutationPayload

  # Creates a static Markdown-backed page.
  createPage(input: CreatePageMutationInput!): CreatePageMutationPayload

  # Create a partner offer for the users
  createPartnerOffer(input: createPartnerOfferMutationInput!): createPartnerOfferMutationPayload

  # Creates a static Markdown-backed sale agreement.
  createSaleAgreement(input: CreateSaleAgreementMutationInput!): CreateSaleAgreementMutationPayload
  createSavedSearch(
    # Parameters for CreateSavedSearch
    input: CreateSavedSearchInput!
  ): CreateSavedSearchPayload
  createSmsSecondFactor(
    # Parameters for CreateSmsSecondFactor
    input: CreateSmsSecondFactorInput!
  ): CreateSmsSecondFactorPayload
  createUserAddress(
    # Parameters for CreateUserAddress
    input: CreateUserAddressInput!
  ): CreateUserAddressPayload

  # Create a admin note for the user
  createUserAdminNote(input: createUserAdminNoteMutationInput!): createUserAdminNoteMutationPayload

  # Creates a UserInterest on the logged in User's CollectorProfile.
  createUserInterest(input: CreateUserInterestMutationInput!): CreateUserInterestMutationPayload

  # Creates a UserInterest for a user.
  createUserInterestForUser(
    input: CreateUserInterestForUserInput!
  ): CreateUserInterestForUserPayload

  # Collect Multiple Artists
  createUserInterests(input: CreateUserInterestsMutationInput!): CreateUserInterestsMutationPayload

  # Create a sale profile for a user
  createUserSaleProfile(
    input: CreateUserSaleProfileMutationInput!
  ): CreateUserSaleProfileMutationPayload

  # Creates Verified Representative.
  createVerifiedRepresentative(
    input: CreateVerifiedRepresentativeInput!
  ): CreateVerifiedRepresentativePayload
  createViewingRoom(
    # Parameters for CreateViewingRoom
    input: CreateViewingRoomInput!
  ): CreateViewingRoomPayload

  # Deletes an alert
  deleteAlert(input: deleteAlertInput!): deleteAlertPayload

  # Delete an artist
  deleteArtist(input: DeleteArtistInput!): DeleteArtistPayload

  # Deletes an image from an artwork in my collection
  deleteArtworkImage(input: DeleteArtworkImageInput!): DeleteArtworkImagePayload

  # Remove a bank account
  deleteBankAccount(input: DeleteBankAccountInput!): DeleteBankAccountPayload

  # Delete an artist career highlight
  deleteCareerHighlight(input: DeleteCareerHighlightInput!): DeleteCareerHighlightPayload

  # Delete a collection
  deleteCollection(input: deleteCollectionInput!): deleteCollectionPayload

  # Soft-delete a conversation.
  deleteConversation(input: DeleteConversationMutationInput!): DeleteConversationMutationPayload

  # Remove a credit card
  deleteCreditCard(input: DeleteCreditCardInput!): DeleteCreditCardPayload

  # deletes a feature.
  deleteFeature(input: DeleteFeatureMutationInput!): DeleteFeatureMutationPayload

  # deletes a featured link.
  deleteFeaturedLink(input: DeleteFeaturedLinkMutationInput!): DeleteFeaturedLinkMutationPayload

  # deletes a hero unit.
  deleteHeroUnit(input: deleteHeroUnitMutationInput!): deleteHeroUnitMutationPayload

  # Delete User Artsy Account
  deleteMyAccountMutation(input: DeleteAccountInput!): DeleteAccountPayload

  # Remove the user icon
  deleteMyUserProfileIcon(input: DeleteUserIconInput!): DeleteUserIconPayload

  # deletes an ordered set.
  deleteOrderedSet(input: deleteOrderedSetMutationInput!): deleteOrderedSetMutationPayload

  # deletes an item to an ordered set.
  deleteOrderedSetItem(
    input: deleteOrderedSetItemMutationInput!
  ): deleteOrderedSetItemMutationPayload

  # Deletes a page.
  deletePage(input: DeletePageMutationInput!): DeletePageMutationPayload

  # Delete a User
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  deleteUserAddress(
    # Parameters for DeleteUserAddress
    input: DeleteUserAddressInput!
  ): DeleteUserAddressPayload

  # delete an admin note for the user
  deleteUserAdminNote(input: deleteUserAdminNoteMutationInput!): deleteUserAdminNoteMutationPayload

  # Deletes a UserInterest on the logged in User's CollectorProfile.
  deleteUserInterest(input: DeleteUserInterestMutationInput!): DeleteUserInterestMutationPayload

  # Delete a UserInterest.
  deleteUserInterestForUser(
    input: DeleteUserInterestForUserInput!
  ): DeleteUserInterestForUserPayload

  # Deletes multiple UserInterests on the logged in User's CollectorProfile.
  deleteUserInterests(input: DeleteUserInterestsMutationInput!): DeleteUserInterestsMutationPayload

  # Delete a role associated with a user
  deleteUserRole(input: deleteUserRoleMutationInput!): deleteUserRoleMutationPayload

  # Deletes a Verified Representative.
  deleteVerifiedRepresentative(
    input: DeleteVerifiedRepresentativeMutationInput!
  ): DeleteVerifiedRepresentativeMutationPayload
  deleteViewingRoom(
    # Parameters for DeleteViewingRoom
    input: DeleteViewingRoomInput!
  ): DeleteViewingRoomPayload
  deliverSecondFactor(
    # Parameters for DeliverSecondFactor
    input: DeliverSecondFactorInput!
  ): DeliverSecondFactorPayload
  disableSavedSearch(
    # Parameters for DisableSavedSearch
    input: DisableSavedSearchInput!
  ): DisableSavedSearchPayload
  disableSecondFactor(
    # Parameters for DisableSecondFactor
    input: DisableSecondFactorInput!
  ): DisableSecondFactorPayload

  # Add (or remove) an artwork to (from) a users dislikes.
  dislikeArtwork(input: DislikeArtworkInput!): DislikeArtworkPayload
  enableSecondFactor(
    # Parameters for EnableSecondFactor
    input: EnableSecondFactorInput!
  ): EnableSecondFactorPayload

  # Mark sale as ended.
  endSale(input: EndSaleInput!): EndSalePayload

  # Follow (or unfollow) an artist
  followArtist(input: FollowArtistInput!): FollowArtistPayload

  # Follow (or unfollow) an gene
  followGene(input: FollowGeneInput!): FollowGenePayload

  # Follow (or unfollow) a profile
  followProfile(input: FollowProfileInput!): FollowProfilePayload

  # Follow (or unfollow) a show
  followShow(input: FollowShowInput!): FollowShowPayload
  holdInventory(
    # Parameters for HoldInventory
    input: HoldInventoryInput!
  ): HoldInventoryPayload

  # Links a 3rd party account
  linkAuthentication(input: LinkAuthenticationMutationInput!): LinkAuthenticationMutationPayload

  # Mark all unread notifications as read
  markAllNotificationsAsRead(
    input: MarkAllNotificationsAsReadInput!
  ): MarkAllNotificationsAsReadPayload

  # Mark an unread notifications as read
  markNotificationAsRead(input: MarkNotificationAsReadInput!): MarkNotificationAsReadPayload

  # Mark notifications as seen
  markNotificationsAsSeen(input: MarkNotificationsAsSeenInput!): MarkNotificationsAsSeenPayload

  # Merge multiple artist records in order to deduplicate artists
  mergeArtists(input: MergeArtistsMutationInput!): MergeArtistsMutationPayload

  # Create an artwork in my collection
  myCollectionCreateArtwork(
    input: MyCollectionCreateArtworkInput!
  ): MyCollectionCreateArtworkPayload

  # Deletes an artwork from my collection
  myCollectionDeleteArtwork(
    input: MyCollectionDeleteArtworkInput!
  ): MyCollectionDeleteArtworkPayload

  # Update an artwork in my collection
  myCollectionUpdateArtwork(
    input: MyCollectionUpdateArtworkInput!
  ): MyCollectionUpdateArtworkPayload
  publishViewingRoom(
    # Parameters for PublishViewingRoom
    input: PublishViewingRoomInput!
  ): PublishViewingRoomPayload
  recordArtworkView(
    # Parameters for RecordArtworkView
    input: RecordArtworkViewInput!
  ): RecordArtworkViewPayload
  removeAssetFromConsignmentSubmission(
    # Parameters for RemoveAssetFromConsignmentSubmission
    input: RemoveAssetFromConsignmentSubmissionInput!
  ): RemoveAssetFromConsignmentSubmissionPayload
  requestConditionReport(
    # Parameters for RequestConditionReport
    input: RequestConditionReportInput!
  ): RequestConditionReportPayload

  # Attach an gemini asset to a consignment submission
  requestCredentialsForAssetUpload(
    input: RequestCredentialsForAssetUploadInput!
  ): RequestCredentialsForAssetUploadPayload

  # Request price estimate of an artwork
  requestPriceEstimate(input: RequestPriceEstimateInput!): RequestPriceEstimatePayload

  # Save (or remove) an artwork to (from) a users default collection.
  saveArtwork(input: SaveArtworkInput!): SaveArtworkPayload

  # Send a confirmation email
  sendConfirmationEmail(
    input: SendConfirmationEmailMutationInput!
  ): SendConfirmationEmailMutationPayload

  # Appending a message to a conversation thread
  sendConversationMessage(
    input: SendConversationMessageMutationInput!
  ): SendConversationMessageMutationPayload

  # Send a feedback message
  sendFeedback(input: SendFeedbackMutationInput!): SendFeedbackMutationPayload

  # Send a identity verification email
  sendIdentityVerificationEmail(
    input: SendIdentityVerificationEmailMutationInput!
  ): SendIdentityVerificationEmailMutationPayload

  # Start an identity verification flow for a pending identity verification
  startIdentityVerification(
    input: startIdentityVerificationMutationInput!
  ): startIdentityVerificationMutationPayload

  # Create an artwork inquiry request
  submitInquiryRequestMutation(
    input: SubmitInquiryRequestMutationInput!
  ): SubmitInquiryRequestMutationPayload

  # Submits an OfferOrder and creates a conversation for it
  submitOfferOrderWithConversation(
    input: CommerceSubmitOrderWithOfferInput!
  ): CommerceSubmitOrderWithOfferPayload
  transferMyCollection(
    # Parameters for TransferMyCollection
    input: TransferMyCollectionInput!
  ): TransferMyCollectionPayload

  # Triggers a campaign send.
  triggerCampaign(input: TriggerCampaignInput!): TriggerCampaignPayload

  # Unlinks a 3rd party account
  unlinkAuthentication(
    input: UnlinkAuthenticationMutationInput!
  ): UnlinkAuthenticationMutationPayload
  unpublishViewingRoom(
    # Parameters for UnpublishViewingRoom
    input: UnpublishViewingRoomInput!
  ): UnpublishViewingRoomPayload

  # Create an alert
  updateAlert(input: updateAlertInput!): updateAlertPayload
  updateAppSecondFactor(
    # Parameters for UpdateAppSecondFactor
    input: UpdateAppSecondFactorInput!
  ): UpdateAppSecondFactorPayload

  # Update the artist
  updateArtist(input: UpdateArtistMutationInput!): UpdateArtistMutationPayload

  # Updates an artwork.
  updateArtwork(input: UpdateArtworkMutationInput!): UpdateArtworkMutationPayload

  # Updates the flags on a partner.
  updateCMSLastAccessTimestamp(
    input: UpdateCMSLastAccessTimestampMutationInput!
  ): UpdateCMSLastAccessTimestampMutationPayload

  # Updates Artist Career Highlight.
  updateCareerHighlight(input: UpdateCareerHighlightInput!): UpdateCareerHighlightPayload

  # Update a collection
  updateCollection(input: updateCollectionInput!): updateCollectionPayload

  # Update a collector profile.
  updateCollectorProfile(input: UpdateCollectorProfileInput!): UpdateCollectorProfilePayload

  # Updating a collector profile (loyalty applicant status).
  updateCollectorProfileWithID(
    input: UpdateCollectorProfileWithIDInput!
  ): UpdateCollectorProfileWithIDPayload
  updateConsignmentSubmission(
    # Parameters for UpdateSubmissionMutation
    input: UpdateSubmissionMutationInput!
  ): UpdateSubmissionMutationPayload

  # Update a conversation.
  updateConversation(input: UpdateConversationMutationInput!): UpdateConversationMutationPayload

  # updates a feature.
  updateFeature(input: UpdateFeatureMutationInput!): UpdateFeatureMutationPayload

  # updates a featured link.
  updateFeaturedLink(input: UpdateFeaturedLinkMutationInput!): UpdateFeaturedLinkMutationPayload

  # updates a hero unit.
  updateHeroUnit(input: UpdateHeroUnitMutationInput!): UpdateHeroUnitMutationPayload

  # Updates the user's collections in batch.
  updateMeCollectionsMutation(
    input: updateMeCollectionsMutationInput!
  ): updateMeCollectionsMutationPayload

  # Update a message.
  updateMessage(input: UpdateMessageMutationInput!): UpdateMessageMutationPayload

  # Updates the logged in user's password
  updateMyPassword(input: UpdateMyPasswordMutationInput!): UpdateMyPasswordMutationPayload

  # Update the current logged in user.
  updateMyUserProfile(input: UpdateMyProfileInput!): UpdateMyProfilePayload

  # Update notification preferences.
  updateNotificationPreferences(
    input: updateNotificationPreferencesMutationInput!
  ): updateNotificationPreferencesMutationPayload

  # updates an ordered set.
  updateOrderedSet(input: UpdateOrderedSetMutationInput!): UpdateOrderedSetMutationPayload

  # Updates a page.
  updatePage(input: UpdatePageMutationInput!): UpdatePageMutationPayload

  # Updates a partner artist.
  updatePartnerShow(input: UpdatePartnerShowMutationInput!): UpdatePartnerShowMutationPayload

  # Update a quiz artwork interacted_with flag
  updateQuiz(input: updateQuizMutationInput!): updateQuizMutationPayload

  # Updates a saleAgreement.
  updateSaleAgreement(input: UpdateSaleAgreementMutationInput!): UpdateSaleAgreementMutationPayload
  updateSavedSearch(
    # Parameters for UpdateSavedSearch
    input: UpdateSavedSearchInput!
  ): UpdateSavedSearchPayload
  updateSmsSecondFactor(
    # Parameters for UpdateSmsSecondFactor
    input: UpdateSmsSecondFactorInput!
  ): UpdateSmsSecondFactorPayload

  # Update the user
  updateUser(input: UpdateUserMutationInput!): UpdateUserMutationPayload
  updateUserAddress(
    # Parameters for UpdateUserAddress
    input: UpdateUserAddressInput!
  ): UpdateUserAddressPayload
  updateUserDefaultAddress(
    # Parameters for UpdateUserDefaultAddress
    input: UpdateUserDefaultAddressInput!
  ): UpdateUserDefaultAddressPayload

  # Updates a UserInterest on the logged in User's CollectorProfile.
  updateUserInterest(input: UpdateUserInterestMutationInput!): UpdateUserInterestMutationPayload

  # Update user interests for multiple artists
  updateUserInterests(input: UpdateUserInterestsMutationInput!): UpdateUserInterestsMutationPayload

  # Update the user sale profile
  updateUserSaleProfile(
    input: UpdateUserSaleProfileMutationInput!
  ): UpdateUserSaleProfileMutationPayload
  updateViewingRoom(
    # Parameters for UpdateViewingRoom
    input: UpdateViewingRoomInput!
  ): UpdateViewingRoomPayload
  updateViewingRoomArtworks(
    # Parameters for UpdateViewingRoomArtworks
    input: UpdateViewingRoomArtworksInput!
  ): UpdateViewingRoomArtworksPayload
  updateViewingRoomSubsections(
    # Parameters for UpdateViewingRoomSubsections
    input: UpdateViewingRoomSubsectionsInput!
  ): UpdateViewingRoomSubsectionsPayload
}

type MyBid {
  sale: Sale
  saleArtworks: [SaleArtwork]
}

type MyBids {
  active: [MyBid]
  closed: [MyBid]
}

input MyCollectionArtistInput {
  # The artist's display name.
  displayName: String
}

type MyCollectionArtworkMutationDeleteSuccess {
  success: Boolean
}

type MyCollectionArtworkMutationFailure {
  mutationError: GravityMutationError
}

type MyCollectionArtworkMutationSuccess {
  artwork: Artwork
  artworkEdge: MyCollectionEdge
}

union MyCollectionArtworkMutationType =
    MyCollectionArtworkMutationDeleteSuccess
  | MyCollectionArtworkMutationFailure
  | MyCollectionArtworkMutationSuccess

enum MyCollectionArtworkSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  POSITION_ASC
  POSITION_DESC
}

# A connection to a list of items.
type MyCollectionConnection {
  # Insights for all collected artists
  artistInsights(
    # The type of insight.
    kind: ArtistInsightKind
  ): [ArtistInsight!]!
  artistInsightsCount: ArtistInsightsCount
  artistsCount: Int!
  artworksCount: Int!

  # A connection of artists in the users' collection
  collectedArtistsConnection(
    after: String
    before: String
    first: Int

    # Include artists that have been created by the user.
    includePersonalArtists: Boolean = false
    last: Int
    page: Int
    size: Int
    sort: ArtistSorts
  ): ArtistConnection @deprecated(reason: "Please use `me.userInterestsConnection` instead")
  default: Boolean!
  description: String!

  # A list of edges.
  edges: [MyCollectionEdge]
  includesPurchasedArtworks: Boolean!
  name: String!
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  private: Boolean!
  totalCount: Int
}

input MyCollectionCreateArtworkInput {
  additionalInformation: String
  artistIds: [String]
  artists: [MyCollectionArtistInput]
  artworkLocation: String
  attributionClass: ArtworkAttributionClassType
  category: String
  clientMutationId: String
  coaByAuthenticatingBody: Boolean
  coaByGallery: Boolean

  # The given location of the user as structured data
  collectorLocation: EditableLocation
  condition: ArtworkConditionEnumType
  conditionDescription: String
  confidentialNotes: String
  costCurrencyCode: String
  costMajor: Int
  costMinor: Int
  date: String
  depth: String
  editionNumber: String
  editionSize: String
  externalImageUrls: [String]
  framedDepth: String
  framedHeight: String
  framedMetric: String
  framedWidth: String
  hasCertificateOfAuthenticity: Boolean
  height: String
  importSource: ArtworkImportSource
  isEdition: Boolean
  isFramed: Boolean
  medium: String
  metric: String

  # The price paid for the MyCollection artwork in cents for any given currency
  pricePaidCents: Long
  pricePaidCurrency: String
  provenance: String
  signatureDetails: String
  signatureTypes: [ArtworkSignatureTypeEnum]
  submissionId: String
  title: String!
  width: String
}

type MyCollectionCreateArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

input MyCollectionDeleteArtworkInput {
  artworkId: String!
  clientMutationId: String
}

type MyCollectionDeleteArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

# An edge in a connection.
type MyCollectionEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

type MyCollectionInfo {
  # Insights for all collected artists
  artistInsights(
    # The type of insight.
    kind: ArtistInsightKind
  ): [ArtistInsight!]!
  artistInsightsCount: ArtistInsightsCount
  artistsCount: Int!
  artworksCount: Int!

  # A connection of artists in the users' collection
  collectedArtistsConnection(
    after: String
    before: String
    first: Int

    # Include artists that have been created by the user.
    includePersonalArtists: Boolean = false
    last: Int
    page: Int
    size: Int
    sort: ArtistSorts
  ): ArtistConnection @deprecated(reason: "Please use `me.userInterestsConnection` instead")
  default: Boolean!
  description: String!
  includesPurchasedArtworks: Boolean!
  name: String!
  private: Boolean!
}

input MyCollectionUpdateArtworkInput {
  additionalInformation: String
  artistIds: [String]
  artworkId: String!
  artworkLocation: String
  attributionClass: ArtworkAttributionClassType
  category: String
  clientMutationId: String
  coaByAuthenticatingBody: Boolean
  coaByGallery: Boolean

  # The given location of the user as structured data
  collectorLocation: EditableLocation
  condition: ArtworkConditionEnumType
  conditionDescription: String
  confidentialNotes: String
  costCurrencyCode: String
  costMajor: Int
  costMinor: Int
  date: String
  depth: String
  editionNumber: String
  editionSize: String
  externalImageUrls: [String]
  framedDepth: String
  framedHeight: String
  framedMetric: String
  framedWidth: String
  hasCertificateOfAuthenticity: Boolean
  height: String
  isEdition: Boolean
  isFramed: Boolean
  medium: String
  metric: String
  pricePaidCents: Long
  pricePaidCurrency: String
  provenance: String
  signatureDetails: String
  signatureTypes: [ArtworkSignatureTypeEnum]
  submissionId: String
  title: String
  width: String
}

type MyCollectionUpdateArtworkPayload {
  artworkOrError: MyCollectionArtworkMutationType
  clientMutationId: String
}

type MyLocation {
  address: String
  address2: String
  city: String
  coordinates: LatLng!
  country: String
  countryCode: String
  display: String
  displayCountry: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  postalCode: String
  state: String
  summary: String
  timezone: String
}

input Near {
  lat: Float!
  lng: Float!
  maxDistance: Float
}

# An object with a Globally Unique ID
interface Node {
  # A globally unique ID.
  id: ID!
}

type Notification implements Node {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String @deprecated(reason: "Please use `publishedAt` instead")
  headline: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isUnread: Boolean!
  item: NotificationItem
  message: String!
  notificationType: NotificationTypesEnum!
  objectsCount: Int!
  previewImages(size: Int): [Image!]!
  publishedAt(
    # pass `RELATIVE` to display the human-friendly date (e.g. "Today", "Yesterday", "5 days ago")
    format: String
  ): String!
  targetHref: String!
  title: String!
}

# A connection to a list of items.
type NotificationConnection {
  counts: NotificationCounts

  # A list of edges.
  edges: [NotificationEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type NotificationCounts {
  total(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  unread(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  unseen(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type NotificationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Notification
}

union NotificationItem =
    AlertNotificationItem
  | ArticleFeaturedArtistNotificationItem
  | ArtworkPublishedNotificationItem
  | CollectorProfileUpdatePromptNotificationItem
  | PartnerOfferCreatedNotificationItem
  | ShowOpenedNotificationItem
  | ViewingRoomPublishedNotificationItem

type NotificationPreference {
  # email | push
  channel: String!
  id: String!
  name: String!
  status: SubGroupStatus!
}

input NotificationPreferenceInput {
  # email | push
  channel: String
  name: String!
  status: SubGroupInputStatus!
}

enum NotificationTypesEnum {
  ARTICLE_FEATURED_ARTIST
  ARTWORK_ALERT
  ARTWORK_PUBLISHED
  COLLECTOR_PROFILE_UPDATE_PROMPT
  PARTNER_OFFER_CREATED
  PARTNER_SHOW_OPENED
  VIEWING_ROOM_PUBLISHED
}

# Consignment Offer Response
type OfferResponse {
  comments: String

  # Uniq ID for this offer response
  id: ID!
  intendedState: IntendedState!
  offer: ConsignmentOffer!
  phoneNumber: String
  rejectionReason: String
}

type OfferableActivity {
  # Count of collectors with eligible offerable activities.
  totalCount: Int
}

type OpeningHoursArray {
  schedules: [FormattedDaySchedules]
}

type OpeningHoursText {
  text: String
}

union OpeningHoursUnion = OpeningHoursArray | OpeningHoursText

union OrderParty = Partner | User

type OrderedSet {
  cached: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  createdBy: User
  description(format: Format): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  internalName: String
  itemType: String
  items: [OrderedSetItem]

  # Returns a connection of the items. Only Artwork supported right now.
  itemsConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
    @deprecated(reason: "Utilize `orderedItemsConnection` for union type")
  key: String
  layout: OrderedSetLayouts!
  name: String
  orderedItemsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): OrderedSetItemConnection!
  ownerType: String
  published: Boolean!
}

# A connection to a list of items.
type OrderedSetConnection {
  # A list of edges.
  edges: [OrderedSetEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type OrderedSetEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: OrderedSet
}

union OrderedSetItem = Artist | Artwork | FeaturedLink | Gene | Profile | Sale | Show

# A connection to a list of items.
type OrderedSetItemConnection {
  # A list of edges.
  edges: [OrderedSetItemEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type OrderedSetItemEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: OrderedSetItem
}

enum OrderedSetLayouts {
  DEFAULT
  FULL
}

enum OrderedSetSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  INTERNAL_NAME_ASC
  INTERNAL_NAME_DESC
  ITEM_TYPE_ASC
  ITEM_TYPE_DESC
  KEY_ASC
  KEY_DESC
  NAME_ASC
  NAME_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  OWNER_TYPE_ASC
  OWNER_TYPE_DESC
}

type Page {
  content(format: Format): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  name: String!
  published: Boolean!
}

# A connection to a list of items.
type PageConnection {
  # A list of edges.
  edges: [PageEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type PageCursor {
  # first cursor on the page
  cursor: String!

  # is this the current page?
  isCurrent: Boolean!

  # page number out of totalPages
  page: Int!
}

type PageCursors {
  around: [PageCursor!]!

  # optional, may be included in field around
  first: PageCursor

  # optional, may be included in field around
  last: PageCursor
  previous: PageCursor
}

# An edge in a connection.
type PageEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Page
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# An artwork with partial data. useful for rendering an error state
type PartialArtwork {
  # Returns the associated Fair/Sale/Show
  context: ArtworkContext
  contextGrids(
    # Whether to include the `RelatedArtworksGrid` module. Defaults to `true`; preferred behavior is to opt out with `false`.
    includeRelatedArtworks: Boolean! = true
  ): [ArtworkContextGrid]

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  layer(id: String): ArtworkLayer

  # A slug ID.
  slug: ID!
}

type Partner implements Node {
  alertsConnection(
    after: String
    artistID: String
    before: String
    first: Int
    id: String
    last: Int
    page: Int
    size: Int
  ): PartnerAlertsConnection
  alertsSummaryArtistsConnection(
    activeInventory: Boolean
    after: String
    before: String
    first: Int
    hasMedium: Boolean
    hasPrice: Boolean
    hasRarity: Boolean
    last: Int
    page: Int
    represented: Boolean
    size: Int
  ): AlertsSummaryArtistConnection

  # A connection of all artists from a Partner.
  allArtistsConnection(
    displayOnPartnerProfile: Boolean
    hasNotRepresentedArtistWithPublishedArtworks: Boolean
    hasPublishedArtworks: Boolean

    # Include additional fields on artists, requires authentication
    includeAllFields: Boolean
    representedBy: Boolean
  ): ArtistPartnerConnection
  analytics: AnalyticsPartnerStats

  # A connection of articles related to a partner.
  articlesConnection(
    after: String
    before: String
    first: Int

    # Get only articles with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean
    last: Int
    page: Int
    sort: ArticleSorts
  ): ArticleConnection

  # A connection of artists at a partner.
  artistsConnection(
    after: String
    artistIDs: [String]
    before: String
    displayOnPartnerProfile: Boolean
    first: Int
    hasPublishedArtworks: Boolean

    # Include additional fields on artists, requires authentication
    includeAllFields: Boolean
    last: Int
    representedBy: Boolean

    # Include artists that are represented or have published artworks, should not be used in conjunction with hasPublishedArtworks or representedBy.
    representedByOrHasPublishedArtworks: Boolean
    sort: ArtistSorts
  ): ArtistPartnerConnection
  artistsSearchConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int = 1
    query: String!
    size: Int = 10
  ): ArtistConnection
  artistsWithAlertCountsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
    sort: ArtistAlertsSort
  ): ArtistsWithAlertCountsConnection

  # A connection of artworks from a Partner.
  artworksConnection(
    after: String

    # Return only artworks by this artist.
    artistID: String

    # Return only artwork(s) included in this list of IDs.
    artworkIDs: [String]
    before: String
    exclude: [String]
    first: Int
    forSale: Boolean

    # If true return both published and unpublished artworks, requires auth
    includeUnpublished: Boolean
    last: Int

    # Return artworks that are missing priority metadata
    missingPriorityMetadata: Boolean
    page: Int

    # Only return artworks that are partner-offerable
    partnerOfferable: Boolean

    # Return artworks published less than x seconds ago.
    publishedWithin: Int

    # Only allowed for authorized admin/partner requests. When false fetch :all properties on an artwork, when true or not present fetch artwork :short properties
    shallow: Boolean
    sort: ArtworkSorts

    # Return artworks according to visibility levels. Defaults to ['listed'].
    visibilityLevels: [Visibility]
  ): ArtworkConnection
  artworksSearchConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int = 1
    query: String!
    size: Int = 10
  ): ArtworkConnection
  cached: Int
  categories: [PartnerCategory]

  # A list of the partners unique city locations
  cities(size: Int = 25): [String]
  claimed: Boolean
  collectingInstitution: String
  counts: PartnerCounts
  defaultProfileID: String
  displayArtistsSection: Boolean
  displayFullPartnerPage: Boolean
  displayWorksSection: Boolean
  distinguishRepresentedArtists: Boolean

  # Return partner documents if current user has CMS access.
  documentsConnection(
    after: String
    artistID: String
    before: String

    # Filter documents by ID.
    documentIDs: [String]
    first: Int
    last: Int
    showID: String
  ): PartnerDocumentConnection

  # Suggested filters for associated artworks
  featuredKeywords: [String!]!
  featuredShow: Show

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  fullProfileEligible: Boolean @deprecated(reason: "Prefer displayFullPartnerPage")
  hasFairPartnership: Boolean

  # The url for a partner. May be `null` if partner is not eligible for page.
  href: String

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # Inquiry Request details
  inquiryRequest(
    # The inquiry id
    inquiryId: String!
  ): PartnerInquiryRequest

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isDefaultProfilePublic: Boolean

  # If the partner supports inquiries
  isInquireable: Boolean!
  isLinkable: Boolean
  isPreQualify: Boolean

  # Indicates the partner is a trusted seller on Artsy
  isVerifiedSeller: Boolean

  # This field is deprecated and is being used in Eigen release predating the 6.0 release
  locations(size: Int = 25): [Location]
    @deprecated(reason: "Prefer to use `locationsConnection`. [Will be removed in v2]")

  # A connection of locations from a Partner.
  locationsConnection(
    addressType: addressType
    after: String
    before: String
    first: Int
    last: Int
    page: Int

    # Return all partner-authenticated locations.
    private: Boolean
    size: Int
  ): LocationConnection
  meta: PartnerMeta
  name: String

  # A connection of search criteria hits from a Partner.
  partnerAlertHitsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): PartnerAlertHitsConnection
  partnerPageEligible: Boolean
  partnerType: String
  profile: Profile
  profileArtistsLayout: String
  profileBannerDisplay: String
  showPromoted: Boolean

  # A connection of shows from a Partner.
  showsConnection(
    after: String

    # If present only return shows including the artist
    artistID: String

    # True for only shows that are part of a fair, false for only shows not part of a fair, blank for all shows
    atAFair: Boolean
    before: String

    # Only used when status is CLOSING_SOON or UPCOMING. Number of days used to filter upcoming and closing soon shows
    dayThreshold: Int
    first: Int

    # If True returns only displayable items
    isDisplayable: Boolean
    last: Int
    page: Int
    sort: ShowSorts

    # Filter shows by chronological event status
    status: EventStatus = CURRENT
  ): ShowConnection
  showsSearchConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int = 1
    query: String!
    size: Int = 10
  ): ShowConnection

  # A slug ID.
  slug: ID!
  type: String
  vatNumber: String
  viewingRoomsConnection(
    after: String
    first: Int
    statuses: [ViewingRoomStatusEnum!]
  ): ViewingRoomsConnection

  # The gallery partner's web address
  website: String
}

# A partner agreement
type PartnerAgreement {
  # Datetime the agreement was accepted
  acceptedAt: ISO8601DateTime

  # ID of user who accepted this agreement
  acceptedBy: String

  # The associated agreement
  agreement: Agreement!

  # Unique ID for this partner agreement
  id: ID!
}

# A partner agreement or errors object
union PartnerAgreementOrErrorsUnion = Errors | PartnerAgreement

# A connection to a list of items.
type PartnerAlertHitsConnection {
  # A list of edges.
  edges: [PartnerAlertHitsEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerAlertHitsEdge {
  artwork: Artwork
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!

  # The item at the end of the edge
  node: Alert
  userIDs: [String]
}

# A connection to a list of items.
type PartnerAlertsConnection {
  # A list of edges.
  edges: [PartnerAlertsEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerAlertsEdge {
  artistID: String
  collectorProfilesConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): PartnerCollectorProfilesConnection

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  matchedAt: String

  # The item at the end of the edge
  node: Alert
  partnerID: String
  score: String
  searchCriteriaID: String
  userIDs: [String]
}

type PartnerArtist {
  artist: Artist
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: PartnerArtistArtworksSort
  ): ArtworkConnection
  biography: String
  biographyBlurb(format: Format): PartnerArtistBlurb
  counts: PartnerArtistCounts

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isHiddenInPresentationMode: Boolean
  isUseDefaultBiography: Boolean
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

enum PartnerArtistArtworksSort {
  POSITION_ASC
  POSITION_DESC
}

type PartnerArtistBlurb {
  credit: String
  text: String
}

# A connection to a list of items.
type PartnerArtistConnection {
  # A list of edges.
  edges: [PartnerArtistEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type PartnerArtistCounts {
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  forSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  managedArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  unlistedArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# A connection to a list of items.
type PartnerArtistDocumentConnection {
  # A list of edges.
  edges: [PartnerArtistDocumentEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerArtistDocumentEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: PartnerDocument
}

# An edge in a connection.
type PartnerArtistEdge {
  artist: Artist
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: PartnerArtistArtworksSort
  ): ArtworkConnection
  biography: String
  biographyBlurb(format: Format): PartnerArtistBlurb
  counts: PartnerArtistCounts

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!
  image: Image
  imageUrl: String

  # A type-specific ID.
  internalID: ID!
  isDisplayOnPartnerProfile: Boolean
  isHiddenInPresentationMode: Boolean
  isUseDefaultBiography: Boolean

  # The item at the end of the edge
  node: Partner
  partner: Partner
  representedBy: Boolean
  sortableID: String
}

type PartnerArtworkGrid implements ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

type PartnerCategory {
  cached: Int
  categoryType: PartnerCategoryType

  # A globally unique ID.
  id: ID!
  internal: Boolean

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String
  partners(
    defaultProfilePublic: Boolean
    eligibleForCarousel: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Indicates tier 1/2 for gallery, 1 for institution
    eligibleForPrimaryBucket: Boolean

    # Indicates tier 3/4 for gallery, 2 for institution
    eligibleForSecondaryBucket: Boolean

    # Exclude partners the user follows (only effective when `include_partners_with_followed_artists` is set to true).
    excludeFollowedPartners: Boolean
    hasFullProfile: Boolean
    ids: [String]

    # If true, will only return partners that are located near the user's location based on the IP address.
    includePartnersNearIpBasedLocation: Boolean = false

    # If true, will only return partners that list artists that the user follows
    includePartnersWithFollowedArtists: Boolean

    # Max distance to use when geo-locating partners, defaults to 75km.
    maxDistance: Int

    # Coordinates to find partners closest to
    near: String
    page: Int

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    size: Int
    sort: PartnersSortType

    # term used for searching Partners
    term: String
    type: [PartnerClassification]
  ): [Partner]

  # A slug ID.
  slug: ID!
}

enum PartnerCategoryType {
  GALLERY
  INSTITUTION
}

enum PartnerClassification {
  AUCTION
  BRAND
  DEMO
  GALLERY
  INSTITUTION
  INSTITUTIONAL_SELLER
  PRIVATE_COLLECTOR
  PRIVATE_DEALER
}

# A connection to a list of items.
type PartnerCollectorProfilesConnection {
  # A list of edges.
  edges: [PartnerCollectorProfilesEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerCollectorProfilesEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: CollectorProfileType
}

# A connection to a list of items.
type PartnerConnection {
  # A list of edges.
  edges: [PartnerEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type PartnerCounts {
  artistDocuments(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  artworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  currentDisplayableShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  displayableShows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  eligibleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerArtists(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  partnerShowDocuments(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  publishedForSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  publishedNotForSaleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
  shows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type PartnerDocument {
  filesize: Int!

  # A globally unique ID.
  id: ID!

  # A type-specific Gravity Mongo Document ID.
  internalID: ID!
  publicURL: String!
  publicUrl: String! @deprecated(reason: "Prefer `publicURL`")
  size: Int! @deprecated(reason: "Prefer `filesize`")
  title: String!
}

# A connection to a list of items.
type PartnerDocumentConnection {
  # A list of edges.
  edges: [PartnerDocumentEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerDocumentEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: PartnerDocument
}

# An edge in a connection.
type PartnerEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Partner
}

type PartnerEngagement {
  counts: PartnerEngagementCounts
}

# Counts relating to a collector's interest in the gallery program
type PartnerEngagementCounts {
  alerts: Int!
  artworkInquiries(
    # When present, returns the inquiry count for the artist (across partners).
    artistID: String
  ): Int!
  followedArtists: Int!
  savedArtworks: Int!
}

type PartnerInquiryRequest {
  collectorProfile: InquirerCollectorProfile

  # Returns the first message of an inquiry with the addition of any inquiry questions submitted by the user, formatted and if present.
  formattedFirstMessage: String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  questions: [InquiryQuestion]
  shippingLocation: Location
}

type PartnerMeta {
  description: String
  image: String
  title: String
}

type PartnerOffer implements Node {
  artworkId: String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  discountPercentage: Int
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isActive: Boolean
  isAvailable: Boolean
  note: String
  partnerId: String
  priceListed: Money
  priceListedMessage: String
    @deprecated(reason: "This field is deprecated. Use 'priceListed' instead.")
  priceWithDiscount: Money
  priceWithDiscountMessage: String
    @deprecated(reason: "This field is deprecated. Use 'priceWithDiscount' instead.")
  source: PartnerOfferSourceEnum
  userIds: [String]
}

# A connection to a list of items.
type PartnerOfferConnection {
  # A list of edges.
  edges: [PartnerOfferEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type PartnerOfferCreatedNotificationItem {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection

  # Deprecated. Use `partnerOffer.isAvailable` instead.
  available: Boolean

  # Deprecated. Use `partnerOffer.endAt` instead.
  expiresAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  partnerOffer: PartnerOffer
}

# An edge in a connection.
type PartnerOfferEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: PartnerOffer
}

enum PartnerOfferSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_AT_ASC
  END_AT_DESC
}

enum PartnerOfferSourceEnum {
  ABANDONED_ORDER
  SAVE
}

type PartnerOfferToCollector implements Node {
  artworkId: String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isActive: Boolean
  isAvailable: Boolean
  note: String
  partnerId: String
  priceWithDiscount: Money
  source: PartnerOfferSourceEnum
}

# A connection to a list of items.
type PartnerOfferToCollectorConnection {
  # A list of edges.
  edges: [PartnerOfferToCollectorEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerOfferToCollectorEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: PartnerOfferToCollector
}

enum PartnerOfferToCollectorSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_AT_ASC
  END_AT_DESC
}

# A connection to a list of items.
type PartnerShowDocumentConnection {
  # A list of edges.
  edges: [PartnerShowDocumentEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type PartnerShowDocumentEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: PartnerDocument
}

enum PartnerShowPartnerType {
  GALLERY
  MUSEUM
}

union PartnerTypes = ExternalPartner | Partner

enum PartnersAggregation {
  CATEGORY
  LOCATION
  TOTAL
}

# The results for one of the requested aggregations
type PartnersAggregationResults {
  counts: [AggregationCount]
  slice: PartnersAggregation
}

enum PartnersSortType {
  CREATED_AT_ASC
  CREATED_AT_DESC
  DISTANCE
  PUBLISHED_AT_DESC
  RANDOM_SCORE_DESC
  RELATIVE_SIZE_ASC
  RELATIVE_SIZE_DESC
  SORTABLE_ID_ASC
  SORTABLE_ID_DESC
}

union PaymentMethodUnion = BankAccount | CreditCard | WireTransfer

enum PhoneNumberErrors {
  INVALID_COUNTRY_CODE
  INVALID_NUMBER
  TOO_LONG
  TOO_SHORT
}

enum PhoneNumberFormats {
  E164
  INTERNATIONAL
  NATIONAL
  RFC3966
}

type PhoneNumberType {
  countryCode: String
  display(format: PhoneNumberFormats): String
  error: PhoneNumberErrors
  isValid: Boolean
  originalNumber: String
  regionCode: String
}

type PreviewSavedSearch {
  # A suggestion for a name that describes a set of saved search criteria in a conventional format
  displayName: String!

  # URL for a user to view the artwork grid with applied filters matching saved search criteria attributes
  href: String

  # Human-friendly labels that are added by Metaphysics to the upstream SearchCriteria type coming from Gravity
  labels: [SearchCriteriaLabel]!

  # Suggested filters for the user to use based on their search criteria
  suggestedFilters(
    # The context from which the alert originates
    source: AlertSource
  ): [SearchCriteriaLabel!]!
}

input PreviewSavedSearchAttributes {
  acquireable: Boolean
  additionalGeneIDs: [String]
  artistIDs: [String]
  artistSeriesIDs: [String]
  atAuction: Boolean
  attributionClass: [String]
  colors: [String]
  height: String
  inquireableOnly: Boolean
  locationCities: [String]
  majorPeriods: [String]
  materialsTerms: [String]
  offerable: Boolean
  partnerIDs: [String]
  priceRange: String

  # Filter results by Artwork sizes
  sizes: [ArtworkSizes]
  width: String
}

# The connection type for MarketPriceInsights.
type PriceInsightConnection {
  # A list of edges.
  edges: [PriceInsightEdge]

  # A list of nodes.
  nodes: [MarketPriceInsights]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: AnalyticsPageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type PriceInsightEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: MarketPriceInsights
}

enum PriceInsightSort {
  # sort by annual_lots_sold in ascending order
  ANNUAL_LOTS_SOLD_ASC

  # sort by annual_lots_sold in descending order
  ANNUAL_LOTS_SOLD_DESC

  # sort by annual_value_sold_cents in ascending order
  ANNUAL_VALUE_SOLD_CENTS_ASC

  # sort by annual_value_sold_cents in descending order
  ANNUAL_VALUE_SOLD_CENTS_DESC

  # sort by artist_id in ascending order
  ARTIST_ID_ASC

  # sort by artist_id in descending order
  ARTIST_ID_DESC

  # sort by artist_name in ascending order
  ARTIST_NAME_ASC

  # sort by artist_name in descending order
  ARTIST_NAME_DESC

  # sort by artsy_q_inventory in ascending order
  ARTSY_Q_INVENTORY_ASC

  # sort by artsy_q_inventory in descending order
  ARTSY_Q_INVENTORY_DESC

  # sort by created_at in ascending order
  CREATED_AT_ASC

  # sort by created_at in descending order
  CREATED_AT_DESC

  # sort by demand_rank in ascending order
  DEMAND_RANK_ASC

  # sort by demand_rank in descending order
  DEMAND_RANK_DESC

  # sort by demand_trend in ascending order
  DEMAND_TREND_ASC

  # sort by demand_trend in descending order
  DEMAND_TREND_DESC

  # sort by high_range_cents in ascending order
  HIGH_RANGE_CENTS_ASC

  # sort by high_range_cents in descending order
  HIGH_RANGE_CENTS_DESC

  # sort by id in ascending order
  ID_ASC

  # sort by id in descending order
  ID_DESC

  # sort by large_high_range_cents in ascending order
  LARGE_HIGH_RANGE_CENTS_ASC

  # sort by large_high_range_cents in descending order
  LARGE_HIGH_RANGE_CENTS_DESC

  # sort by large_low_range_cents in ascending order
  LARGE_LOW_RANGE_CENTS_ASC

  # sort by large_low_range_cents in descending order
  LARGE_LOW_RANGE_CENTS_DESC

  # sort by large_mid_range_cents in ascending order
  LARGE_MID_RANGE_CENTS_ASC

  # sort by large_mid_range_cents in descending order
  LARGE_MID_RANGE_CENTS_DESC

  # sort by last_auction_result_date in ascending order
  LAST_AUCTION_RESULT_DATE_ASC

  # sort by last_auction_result_date in descending order
  LAST_AUCTION_RESULT_DATE_DESC

  # sort by liquidity_rank in ascending order
  LIQUIDITY_RANK_ASC

  # sort by liquidity_rank in descending order
  LIQUIDITY_RANK_DESC

  # sort by lots_sold_last_12_months in ascending order
  LOTS_SOLD_LAST_12_MONTHS_ASC

  # sort by lots_sold_last_12_months in descending order
  LOTS_SOLD_LAST_12_MONTHS_DESC

  # sort by lots_sold_last_24_months in ascending order
  LOTS_SOLD_LAST_24_MONTHS_ASC

  # sort by lots_sold_last_24_months in descending order
  LOTS_SOLD_LAST_24_MONTHS_DESC

  # sort by lots_sold_last_36_months in ascending order
  LOTS_SOLD_LAST_36_MONTHS_ASC

  # sort by lots_sold_last_36_months in descending order
  LOTS_SOLD_LAST_36_MONTHS_DESC

  # sort by lots_sold_last_48_months in ascending order
  LOTS_SOLD_LAST_48_MONTHS_ASC

  # sort by lots_sold_last_48_months in descending order
  LOTS_SOLD_LAST_48_MONTHS_DESC

  # sort by lots_sold_last_60_months in ascending order
  LOTS_SOLD_LAST_60_MONTHS_ASC

  # sort by lots_sold_last_60_months in descending order
  LOTS_SOLD_LAST_60_MONTHS_DESC

  # sort by lots_sold_last_72_months in ascending order
  LOTS_SOLD_LAST_72_MONTHS_ASC

  # sort by lots_sold_last_72_months in descending order
  LOTS_SOLD_LAST_72_MONTHS_DESC

  # sort by lots_sold_last_84_months in ascending order
  LOTS_SOLD_LAST_84_MONTHS_ASC

  # sort by lots_sold_last_84_months in descending order
  LOTS_SOLD_LAST_84_MONTHS_DESC

  # sort by lots_sold_last_96_months in ascending order
  LOTS_SOLD_LAST_96_MONTHS_ASC

  # sort by lots_sold_last_96_months in descending order
  LOTS_SOLD_LAST_96_MONTHS_DESC

  # sort by low_range_cents in ascending order
  LOW_RANGE_CENTS_ASC

  # sort by low_range_cents in descending order
  LOW_RANGE_CENTS_DESC

  # sort by median_sale_price_last_36_months in ascending order
  MEDIAN_SALE_PRICE_LAST_36_MONTHS_ASC

  # sort by median_sale_price_last_36_months in descending order
  MEDIAN_SALE_PRICE_LAST_36_MONTHS_DESC

  # sort by median_sale_price_last_96_months in ascending order
  MEDIAN_SALE_PRICE_LAST_96_MONTHS_ASC

  # sort by median_sale_price_last_96_months in descending order
  MEDIAN_SALE_PRICE_LAST_96_MONTHS_DESC

  # sort by median_sale_to_estimate_ratio in ascending order
  MEDIAN_SALE_TO_ESTIMATE_RATIO_ASC

  # sort by median_sale_to_estimate_ratio in descending order
  MEDIAN_SALE_TO_ESTIMATE_RATIO_DESC

  # sort by medium in ascending order
  MEDIUM_ASC

  # sort by medium in descending order
  MEDIUM_DESC

  # sort by medium_high_range_cents in ascending order
  MEDIUM_HIGH_RANGE_CENTS_ASC

  # sort by medium_high_range_cents in descending order
  MEDIUM_HIGH_RANGE_CENTS_DESC

  # sort by medium_low_range_cents in ascending order
  MEDIUM_LOW_RANGE_CENTS_ASC

  # sort by medium_low_range_cents in descending order
  MEDIUM_LOW_RANGE_CENTS_DESC

  # sort by medium_mid_range_cents in ascending order
  MEDIUM_MID_RANGE_CENTS_ASC

  # sort by medium_mid_range_cents in descending order
  MEDIUM_MID_RANGE_CENTS_DESC

  # sort by mid_range_cents in ascending order
  MID_RANGE_CENTS_ASC

  # sort by mid_range_cents in descending order
  MID_RANGE_CENTS_DESC

  # sort by sell_through_rate in ascending order
  SELL_THROUGH_RATE_ASC

  # sort by sell_through_rate in descending order
  SELL_THROUGH_RATE_DESC

  # sort by small_high_range_cents in ascending order
  SMALL_HIGH_RANGE_CENTS_ASC

  # sort by small_high_range_cents in descending order
  SMALL_HIGH_RANGE_CENTS_DESC

  # sort by small_low_range_cents in ascending order
  SMALL_LOW_RANGE_CENTS_ASC

  # sort by small_low_range_cents in descending order
  SMALL_LOW_RANGE_CENTS_DESC

  # sort by small_mid_range_cents in ascending order
  SMALL_MID_RANGE_CENTS_ASC

  # sort by small_mid_range_cents in descending order
  SMALL_MID_RANGE_CENTS_DESC

  # sort by updated_at in ascending order
  UPDATED_AT_ASC

  # sort by updated_at in descending order
  UPDATED_AT_DESC
}

type PriceRange {
  display: String
  maxPrice: Money
  minPrice: Money
}

type Profile {
  bio: String
  cached: Int
  counts: ProfileCounts
  displayArtistsSection: Boolean @deprecated(reason: "Prefer displayArtistsSection in Partner type")
  fullBio: String
  href: String
  icon: Image

  # A globally unique ID.
  id: ID!
  image: Image
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isFollowed: Boolean
  isPubliclyVisible: Boolean
  isPublished: Boolean
  location: String
  name: String
  owner: ProfileOwnerType!
  profileArtistsLayout: String @deprecated(reason: "Prefer profileArtistsLayout in Partner type")

  # A slug ID.
  slug: ID!
}

# A connection to a list of items.
type ProfileConnection {
  # A list of edges.
  edges: [ProfileEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type ProfileCounts {
  follows(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type ProfileEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Profile
}

union ProfileOwnerType = Fair | FairOrganizer | Partner

# Autogenerated input type of PublishViewingRoom
input PublishViewingRoomInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomID: ID!
}

# Autogenerated return type of PublishViewingRoom
type PublishViewingRoomPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoom: ViewingRoom!
}

type Query {
  # Do not use (only used internally for stitching)
  _do_not_use_conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Do not use (only used internally for stitching)
  _do_not_use_image: Image

  # Returns a lot with specific `id`.
  _unused_auctionsLot(id: ID!): AuctionsLotState

  # Lot standings for a user
  _unused_auctionsLotStandingConnection(
    after: String
    before: String
    first: Int
    last: Int
    userId: ID!
  ): AuctionsLotStandingConnection!
  _unused_gravity_devices(userId: ID!): [Device!]!

  # Autocomplete resolvers.
  _unused_gravity_matchPartners(
    matchType: String
    page: Int = 1
    size: Int = 5
    term: String!
  ): [DoNotUseThisPartner!]

  # Autocomplete resolvers.
  _unused_gravity_match_partners(
    match_type: String
    page: Int = 1
    size: Int = 5
    term: String!
  ): [DoNotUseThisPartner!] @deprecated(reason: "Use matchPartners")

  # Find a partner by ID
  _unused_gravity_partner(id: ID!): DoNotUseThisPartner

  # Find partners by IDs
  _unused_gravity_partners(ids: [ID!]!): [DoNotUseThisPartner!]

  # Find a saved search by ID or criteria
  _unused_gravity_savedSearch(criteria: SearchCriteriaAttributes, id: ID): SearchCriteria

  # List of user's saved searches
  _unused_gravity_savedSearchesConnection(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns saved searches associated with the provided artist IDs (or slugs)
    artistIDs: [String!]

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Returns saved searches sorted by input (default: by created date in descending order)
    sort: SavedSearchesSortEnum
  ): SearchCriteriaConnection

  # List enabled Two-Factor Authentication factors
  _unused_gravity_secondFactors(kinds: [SecondFactorKind!] = [app, sms, backup]): [SecondFactor!]!

  # List of user's saved addresses
  _unused_gravity_userAddressConnection(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    userId: ID!
  ): UserAddressConnection

  # List viewing rooms
  _unused_gravity_viewingRoomsConnection(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    featured: Boolean

    # Returns the first _n_ elements from the list.
    first: Int
    ids: [ID!]

    # Returns the last _n_ elements from the list.
    last: Int
    partnerID: ID

    # Returns only viewing rooms with these statuses
    statuses: [ViewingRoomStatusEnum!] = [live]
  ): ViewingRoomsConnection
  admin: Admin

  # Find an agreement by ID
  agreement(id: ID!): Agreement

  # Get the year sparklines for the current artist.
  analyticsArtistSparklines(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    artistId: String!

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AnalyticsArtistSparklineConnection

  # Get all recommended artworks for the current user.
  analyticsArtworkRecommendations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    userId: String
  ): AnalyticsArtworkRecommendationConnection

  # Get price insights for a market for each calendar year sorted by year asc.
  analyticsCalendarYearMarketPriceInsights(
    artistId: ID!
    endYear: String
    medium: String!
    startYear: String
  ): [CalendarYearMarketPriceInsights!]

  # Get list of calendar year price insights for an artist for each market sorted by year asc.
  analyticsCalendarYearPriceInsights(
    artistId: ID!
    endYear: String
    startYear: String
  ): [CalendarYearPriceInsights!]

  # Last updated timestamp
  analyticsLastUpdatedAt: AnalyticsDateTime

  # Find PartnerStats
  analyticsPartnerStats(partnerId: String!): AnalyticsPartnerStats

  # Query UserStats
  analyticsUserStats(userId: String!): AnalyticsUserStats

  # An Article
  article(
    # The ID of the Article
    id: String!
  ): Article

  # A list of Articles
  articles(
    auctionID: String
    channelID: String
    featured: Boolean

    #
    #         Only return articles matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    layout: ArticleLayout
    limit: Int
    offset: Int
    omit: [String!]
    published: Boolean = true
    showID: String
    sort: ArticleSorts
  ): [Article!]!

  # A connection of articles
  articlesConnection(
    after: String
    before: String
    channelId: String
    featured: Boolean
    first: Int

    # Get only articles with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean
    last: Int
    layout: ArticleLayout
    omit: [String!]
    page: Int
    sort: ArticleSorts
  ): ArticleConnection

  # An Artist
  artist(
    # The slug or ID of the Artist
    id: String!
  ): Artist

  # Find an artist series by ID
  artistSeries(id: ID!): ArtistSeries

  # List all artist series, optionally filtered by artist or artwork
  artistSeriesConnection(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # ID of the artist by which to filter results
    artistID: ID

    # ID of the artwork by which to filter results
    artworkID: ID

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Array of IDs of artist series that should be excluded from results
    excludeIDs: [ID!]

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): ArtistSeriesConnection

  # A list of Artists
  artists(
    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    page: Int = 1
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): [Artist]

  # A list of artists
  artistsConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    last: Int
    letter: String
    page: Int
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs (e.g. 'andy-warhol', 'banksy').
    #
    slugs: [String]
    sort: ArtistSorts

    # If present, will search by term
    term: String
  ): ArtistConnection

  # An Artwork
  artwork(
    # The slug or ID of the Artwork
    id: String!
  ): Artwork

  # List of all artwork attribution classes
  artworkAttributionClasses: [AttributionClass]

  # List of all artwork mediums
  artworkMediums: [ArtworkMedium]

  # An artwork result
  artworkResult(
    # The slug or ID of the artwork
    id: String!
  ): ArtworkResult

  # A list of Artworks
  artworks(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
    respectParamsOrder: Boolean = false
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # Artworks Elastic Search results
  artworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A connection of artworks for a user.
  artworksForUser(
    after: String
    before: String
    excludeArtworkIds: [String] = []
    excludeDislikedArtworks: Boolean = false
    first: Int
    includeBackfill: Boolean!
    last: Int
    marketable: Boolean
    maxWorksPerArtist: Int
    onlyAtAuction: Boolean = false
    page: Int
    userId: String
    version: String
  ): ArtworkConnection

  # An auction result
  auctionResult(
    # The ID or slug of the auction result
    id: String!
  ): AuctionResult

  # Auction lot results
  auctionResultsByArtistsConnection(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    artistIds: [ID!]!

    # Returns the elements in the list that come before the specified cursor.
    before: String
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AuctionResultsByArtistsConnection

  # If user is logged out; status is `LOGGED_OUT`. If user is logged in; status is `LOGGED_IN`. If user is logged in with invalid authentication (401); 'Promise' resolves to 'Status.Invalid'. All other status codes will resolve to `LOGGED_IN` because we don't know whether or not the authentication is valid (error could be something else).
  authenticationStatus: AuthenticationStatus!

  # A user's bank account
  bankAccount(
    # The ID of the bank account
    id: String!
  ): BankAccount
  channel(id: ID!): Channel!

  # A list of cities
  cities(featured: Boolean = false): [City!]!

  # A city-based entry point for local discovery
  city(
    # A point which will be used to locate the nearest local discovery city within a threshold
    near: Near

    # A slug for the city, conforming to Gravity's city slug naming conventions
    slug: String
  ): City

  # A collector profile.
  collectorProfile(userID: String): CollectorProfileType

  # A list of collector profiles that have sent an inquiry to a partner
  collectorProfilesConnection(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: ID

    # Term used for searching collector profiles
    term: String
  ): CollectorProfileTypeConnection

  # Find list of abandoned orders
  commerceAbandonedOrders(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    artworkId: ID!

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Ignored for the time being, future iterations will support this.
    excludeFailedPayments: Boolean

    # Returns the first _n_ elements from the list.
    first: Int
    from: CommerceDateTime!

    # Returns the last _n_ elements from the list.
    last: Int
    sellerId: String!
  ): CommerceOrderConnectionWithTotalCount

  # Find balance of an account associated with a setup intent
  commerceBankAccountBalance(bankAccountId: ID, setupIntentId: ID): CommerceBankAccountBalance

  # Buyer Activity Data for Collector Resume
  commerceBuyerActivity(buyerId: String!, sellerId: String): CommerceBuyerActivity

  # Find list of competing orders
  commerceCompetingOrders(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    orderId: ID!
  ): CommerceOrderConnectionWithTotalCount
  commerceLineItems(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    artworkId: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    editionSetId: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    orderStates: [CommerceOrderStateEnum!]
  ): CommerceLineItemConnection

  # Return my orders
  commerceMyOrders(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    mode: CommerceOrderModeEnum
    sellerId: String
    sort: CommerceOrderConnectionSortEnum
    states: [CommerceOrderStateEnum!]
  ): CommerceOrderConnectionWithTotalCount

  # Find an order by ID
  commerceOrder(code: String, id: ID): CommerceOrder

  # Find list of orders
  commerceOrders(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    buyerId: String
    buyerType: String

    # Returns the first _n_ elements from the list.
    first: Int
    impulseConversationId: String

    # Returns the last _n_ elements from the list.
    last: Int
    mode: CommerceOrderModeEnum
    sellerId: String
    sellerType: String
    sort: CommerceOrderConnectionSortEnum
    state: CommerceOrderStateEnum
    states: [CommerceOrderStateEnum!]
  ): CommerceOrderConnectionWithTotalCount

  # Sold or bought-in consignments
  consignments(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Return sold or bought-in consignments for the given partner
    gravityPartnerId: ID!

    # Returns the last _n_ elements from the list.
    last: Int

    # Return consignments sorted by input (default sort by id)
    sort: ConsignmentSort
  ): ConsignmentConnection

  # A conversation, usually between a user and a partner
  conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Conversations, usually between a user and partner.
  conversationsConnection(
    after: String
    artistId: String
    before: String
    dismissed: Boolean
    first: Int
    fromId: String
    hasMessage: Boolean
    hasReply: Boolean
    last: Int
    partnerId: String
    toBeReplied: Boolean
    type: ConversationsInputMode = USER
  ): ConversationConnection

  # A user's credit card
  creditCard(
    # The ID of the Credit Card
    id: String!
  ): CreditCard
  curatedMarketingCollections(size: Int): [MarketingCollection]

  # A list of trending artists. Inferred from a manually curated collection of trending artworks.
  curatedTrendingArtists(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the first n items from the list.
    first: Int

    # Returns the last n items from the list.
    last: Int
  ): ArtistConnection
  departments: [Department!]!

  # A namespace external partners (provided by Galaxy)
  external: External!

  # A Fair
  fair(
    # The slug or ID of the Fair
    id: String!
  ): Fair

  # A fair organizer, e.g. The Armory Show
  fairOrganizer(
    # The slug or ID of the Fair organizer
    id: String!
  ): FairOrganizer

  # A list of Fairs
  fairs(
    fairOrganizerID: String
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    #
    #         Only return fairs matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    near: Near
    page: Int
    size: Int
    sort: FairSorts
    status: EventStatus
  ): [Fair]

  # A list of fairs
  fairsConnection(
    after: String
    before: String
    fairOrganizerID: String
    first: Int
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    # Only return fairs matching specified IDs. Accepts list of IDs.
    ids: [String]
    last: Int
    near: Near
    sort: FairSorts
    status: EventStatus
  ): FairConnection

  # A Feature
  feature(
    # The slug or ID of the Feature
    id: ID
  ): Feature
  featuredLinksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): FeaturedLinkConnection
  featuresConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: FeatureSorts

    # If present, will search by term
    term: String
  ): FeatureConnection

  # Partners Elastic Search results
  filterPartners(
    aggregations: [PartnersAggregation]!
    defaultProfilePublic: Boolean
    eligibleForCarousel: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Indicates tier 1/2 for gallery, 1 for institution
    eligibleForPrimaryBucket: Boolean

    # Indicates tier 3/4 for gallery, 2 for institution
    eligibleForSecondaryBucket: Boolean

    # Exclude partners the user follows (only effective when `include_partners_with_followed_artists` is set to true).
    excludeFollowedPartners: Boolean
    hasFullProfile: Boolean
    ids: [String]

    # If true, will only return partners that are located near the user's location based on the IP address.
    includePartnersNearIpBasedLocation: Boolean = false

    # If true, will only return partners that list artists that the user follows
    includePartnersWithFollowedArtists: Boolean

    # Max distance to use when geo-locating partners, defaults to 75km.
    maxDistance: Int

    # Coordinates to find partners closest to
    near: String
    page: Int

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    size: Int
    sort: PartnersSortType

    # term used for searching Partners
    term: String
    type: [PartnerClassification]
  ): FilterPartners
  gene(
    # The slug or ID of the Gene
    id: String!
  ): Gene

  # A list of Gene Families
  geneFamiliesConnection(after: String, before: String, first: Int, last: Int): GeneFamilyConnection

  # A list of Genes
  genes(
    size: Int

    #
    #         Only return genes matching specified slugs.
    #         Accepts list of slugs.
    #
    slugs: [String]
  ): [Gene]

  # A Hero Unit.
  heroUnit(
    # The ID of the Hero Unit
    id: String!
  ): HeroUnit
  heroUnitsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If true will include inactive hero units.
    private: Boolean = false

    # If present will search by term.
    term: String
  ): HeroUnitConnection
  highlights: Highlights

  # Home screen content
  homePage: HomePage

  # Home view content
  homeView: HomeView!

  # An identity verification that the user has access to
  identityVerification(
    # ID of the IdentityVerification
    id: String!
  ): IdentityVerification

  # A connection of identity verifications.
  identityVerificationsConnection(
    after: String
    before: String
    email: String
    first: Int
    last: Int
    name: String
    page: Int
    size: Int
    userId: String
  ): IdentityVerificationConnection
  job(id: ID!): Job!
  jobs: [Job!]!
  markdown(content: String!): MarkdownContent

  # Get price insights for a market.
  marketPriceInsights(artistId: ID!, medium: String!): MarketPriceInsights
  marketingCategories: [MarketingCollectionCategory!]!

  # Find a marketing collection by ID or slug
  marketingCollection(slug: String!): MarketingCollection

  # An array of marketing collections. Defaults to returning all available collections if no args are passed
  marketingCollections(
    artistID: String
    category: String
    isFeaturedArtistContent: Boolean
    size: Int
    slugs: [String!]
  ): [MarketingCollection!]

  # A Search for Artists
  matchArtist(
    # Exclude these MongoDB ids from results
    excludeIDs: [String]

    # Page to retrieve. Default: 1.
    page: Int

    # Maximum number of items to retrieve. Default: 5.
    size: Int

    # Your search term
    term: String!
  ): [Artist]
  matchConnection(
    after: String
    before: String

    # ARTIST_SERIES, CITY, COLLECTION, and VIEWING_ROOM are not yet supported
    entities: [SearchEntity!] = [
      ARTIST
      ARTIST_SERIES
      ARTWORK
      ARTICLE
      CITY
      COLLECTION
      FAIR
      FEATURE
      GALLERY
      GENE
      INSTITUTION
      PAGE
      PROFILE
      SALE
      SHOW
      TAG
      VIEWING_ROOM
    ]
    first: Int
    last: Int

    # Mode of search to execute
    mode: SearchMode = SITE
    page: Int = 1
    size: Int = 10
    term: String!
  ): MatchConnection
  me: Me

  # Fetches an object given its globally unique ID.
  node(
    # The globally unique ID of the node.
    id: ID!
  ): Node

  # User's notification preferences
  notificationPreferences(authenticationToken: String): [NotificationPreference!]!

  # A feed of notifications
  notificationsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Notification types to return
    notificationTypes: [NotificationTypesEnum]
  ): NotificationConnection

  # Get an Offer
  offer(
    # Return offers for the given partner
    gravityPartnerId: ID
    id: ID!
  ): ConsignmentOffer

  # List offers
  offers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Return offers for the given partner
    gravityPartnerId: ID!

    # Returns the last _n_ elements from the list.
    last: Int

    # Return offers sorted this way
    sort: ConsignmentOfferSort

    # Return only offers with matching states
    states: [String!]
  ): ConsignmentOfferConnection

  # An OrderedSet
  orderedSet(
    # The ID of the OrderedSet
    id: String!
  ): OrderedSet

  # A collection of OrderedSets
  orderedSets(
    # Key to the OrderedSet or group of OrderedSets
    key: String!
    public: Boolean = true
  ): [OrderedSet]

  # A connection of Ordered Sets
  orderedSetsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): OrderedSetConnection
  page(id: ID!): Page!
  pagesConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): PageConnection

  # A Partner
  partner(
    # The slug or ID of the Partner
    id: String!
  ): Partner

  # Retrieve all partner documents for a given partner
  partnerArtistDocumentsConnection(
    after: String

    # The slug or ID of the Artist
    artistID: String!
    before: String
    first: Int
    last: Int
    page: Int

    # The slug or ID of the Partner
    partnerID: String!
    size: Int
  ): PartnerArtistDocumentConnection @deprecated(reason: "Prefer `partner.documentsConnection`")

  # A list of Artworks for a partner
  partnerArtworks(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: String!
    private: Boolean
    viewingRoomID: String
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # A list of PartnerCategories
  partnerCategories(
    categoryType: PartnerCategoryType

    # Filter by whether category is internal
    internal: Boolean = false
    size: Int
  ): [PartnerCategory]

  # A PartnerCategory
  partnerCategory(
    # The slug or ID of the PartnerCategory
    id: String!
  ): PartnerCategory

  # Retrieve all partner show documents for a given partner and show
  partnerShowDocumentsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int

    # The slug or ID of the Partner
    partnerID: String!

    # The slug or ID of the Show
    showID: String!
    size: Int
  ): PartnerShowDocumentConnection @deprecated(reason: "Prefer `partner.documentsConnection`")

  # A list of Partners
  partnersConnection(
    after: String
    before: String
    defaultProfilePublic: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Exclude partners the user follows (only effective when `include_partners_with_followed_artists` is set to true).
    excludeFollowedPartners: Boolean
    first: Int
    ids: [String]

    # If true, will only return partners that are located near the user's location based on the IP address.
    includePartnersNearIpBasedLocation: Boolean = false

    # If true, will only return partners that list artists that the user follows
    includePartnersWithFollowedArtists: Boolean
    last: Int

    # Max distance to use when geo-locating partners, defaults to 75km.
    maxDistance: Int

    # Coordinates to find partners closest to
    near: String

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    sort: PartnersSortType
    type: [PartnerClassification]
  ): PartnerConnection

  # Phone number information
  phoneNumber(phoneNumber: String!, regionCode: String): PhoneNumberType

  # A previewed saved search
  previewSavedSearch(
    # The criteria which describe the alert
    attributes: PreviewSavedSearchAttributes
  ): PreviewSavedSearch

  # Get all price insights for an artist.
  priceInsights(
    # Returns the elements in the list that come after the specified cursor.
    after: String
    artistId: ID!

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Return price insights sorted this way
    sort: PriceInsightSort
  ): PriceInsightConnection

  # A Profile
  profile(
    # The slug or ID of the Profile
    id: String!
  ): Profile

  # A list of Profiles
  profilesConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int

    # If present, will search by term
    term: String
  ): ProfileConnection

  # Static set of recently sold artworks for the SWA landing page
  recentlySoldArtworks(
    after: String
    before: String
    first: Int
    last: Int
  ): RecentlySoldArtworkTypeConnection

  # A requested location
  requestLocation(ip: String): RequestLocation

  # A Sale
  sale(
    # The slug or ID of the Sale
    id: String!
  ): Sale
  saleAgreement(id: ID!): SaleAgreement!

  # The conditions of sale for Artsy or an individual sale.
  saleAgreementsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # if present, will return condition of sales with the input status
    status: SaleAgreementStatus
  ): SaleAgreementConnection

  # A Sale Artwork
  saleArtwork(
    # The slug or ID of the SaleArtwork
    id: String!
  ): SaleArtwork

  # Sale Artworks search results
  saleArtworksConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    biddableSale: Boolean
    estimateRange: String
    excludeClosedLots: Boolean
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    marketable: Boolean
    page: Int
    saleID: ID

    # Same as saleID argument, but matches the argument type of `sale(id: 'foo')` root field
    saleSlug: String
    size: Int
    sort: String
    userId: String
  ): SaleArtworksConnection

  # A list of Sales
  salesConnection(
    after: String
    auctionState: AuctionState
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts

    # If present, will search by term
    term: String
  ): SaleConnection

  # Global search
  searchConnection(
    after: String
    aggregations: [SearchAggregation]
    before: String

    # Entities to include in search. Default: [ARTIST, ARTWORK].
    entities: [SearchEntity]
    first: Int
    last: Int

    # Mode of search to execute. Default: SITE.
    mode: SearchMode

    # If present, will be used for pagination instead of cursors.
    page: Int

    # Search query to perform. Required.
    query: String!
  ): SearchableConnection
  shortcut(id: ID!): Shortcut

  # A Show
  show(
    # The slug or ID of the Show
    id: String!

    # Include shows that are no longer running/active (defaults to false)
    includeAllShows: Boolean = false
  ): Show

  # A list of Shows
  showsConnection(
    after: String
    atAFair: Boolean
    before: String
    displayable: Boolean = true
    first: Int
    hasLocation: Boolean
    ids: [String]
    last: Int
    sort: ShowSorts
    status: EventStatus

    # If present, will search by term
    term: String
  ): ShowConnection

  # Content for a specific page or view
  staticContent(
    # The slug or id for the view
    id: String
  ): StaticContent

  # Get a Submission
  submission(externalId: ID, id: ID, sessionID: String): ConsignmentSubmission

  # Filter all submission
  submissions(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # If true return only available submissions
    available: Boolean

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Get submissions filtered by category
    filterByCategory: ConsignmentSubmissionCategoryAggregation

    # Returns the first _n_ elements from the list.
    first: Int

    # Get all submissions with these IDs
    ids: [ID!]

    # Returns the last _n_ elements from the list.
    last: Int

    # Return submissions sorted this way
    sort: ConsignmentSubmissionSort

    # Get all submissions with these user IDs
    userId: [ID!]
  ): ConsignmentSubmissionConnection

  # Fields related to internal systems.
  system: System
  tag(
    # The slug or ID of the Tag
    id: String!
  ): Tag
  targetSupply: TargetSupply
  user(
    # Email to search for user by
    email: String

    # ID of the user
    id: String
  ): User

  # A list of Users
  usersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int

    # If present, will search by term, cannot be combined with `ids`
    term: String
  ): UserConnection

  # A Partner or Fair
  vanityURLEntity(
    # The slug or ID of the Profile to get a partner or fair for
    id: String!
  ): VanityURLEntityType

  # Verify a given address.
  verifyAddress(input: VerifyAddressInput!): VerifyAddressPayload

  # Verify a given user.
  verifyUser(
    # Email address to verify.
    email: String!

    # Recaptcha token.
    recaptchaToken: String!
  ): VerifyUser

  # A wildcard used to support complex root queries in Relay
  viewer: Viewer

  # Find a viewing room by ID
  viewingRoom(id: ID!): ViewingRoom

  # (Deprecate) use viewingRoomsConnection
  viewingRooms(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    featured: Boolean

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    partnerID: ID

    # (Deprecated) Use statuses
    published: Boolean

    # Returns only viewing rooms with these statuses
    statuses: [ViewingRoomStatusEnum!] = [live]
  ): ViewingRoomConnection @deprecated(reason: "Use viewingRoomsConnection")
}

type Quiz {
  completedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  quizArtworkConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int
    size: Int
  ): QuizArtworkConnection
  recommendedArtworks: [Artwork!]!
  savedArtworks: [Artwork!]!
}

# A connection to a list of items.
type QuizArtworkConnection {
  # A list of edges.
  edges: [QuizArtworkEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type QuizArtworkEdge {
  # A cursor for use in pagination
  cursor: String!
  interactedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # The item at the end of the edge
  node: Artwork
  position: Int!
}

type RecenltySoldArtworkPerformance {
  # Percentage performance over mid-estimate
  mid: String
}

type RecentlySoldArtworkType {
  artwork: Artwork
  highEstimate: Money
  lowEstimate: Money
  performance: RecenltySoldArtworkPerformance
  priceRealized: Money
}

# A connection to a list of items.
type RecentlySoldArtworkTypeConnection {
  # A list of edges.
  edges: [RecentlySoldArtworkTypeEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type RecentlySoldArtworkTypeEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: RecentlySoldArtworkType
}

# Autogenerated input type of RecordArtworkView
input RecordArtworkViewInput {
  artwork_id: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of RecordArtworkView
type RecordArtworkViewPayload {
  # Id of viewed artwork
  artworkId: String!

  # Id of viewed artwork
  artwork_id: String! @deprecated(reason: "Use artworkId")

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

enum RelatedArtistsKind {
  CONTEMPORARY
  MAIN
}

type RelatedArtworkGrid implements ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# Autogenerated input type of RemoveAssetFromConsignmentSubmission
input RemoveAssetFromConsignmentSubmissionInput {
  assetID: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  sessionID: String
}

# Autogenerated return type of RemoveAssetFromConsignmentSubmission
type RemoveAssetFromConsignmentSubmissionPayload {
  asset: ConsignmentSubmissionCategoryAsset

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

type Request {
  # IP Address of the current request, useful for debugging
  ipAddress: String!
}

# Autogenerated input type of RequestConditionReport
input RequestConditionReportInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the sale artwork.
  saleArtworkID: String!
}

# Autogenerated return type of RequestConditionReport
type RequestConditionReportPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  conditionReportRequest: ConditionReportRequest!
}

input RequestCredentialsForAssetUploadInput {
  # The desired access control
  acl: String!
  clientMutationId: String

  # The gemini template you want to request
  name: String!
}

type RequestCredentialsForAssetUploadPayload {
  asset: Credentials
  clientMutationId: String
}

type RequestError {
  statusCode: Int!
}

type RequestLocation {
  cached: Int
  city: String
  coordinates: LatLng
  country: String
  countryCode: String
  id: ID!
}

input RequestPriceEstimateInput {
  artworkId: String!
  clientMutationId: String
  requesterEmail: String
  requesterName: String
  requesterPhoneNumber: String
}

union RequestPriceEstimateMutationType =
    RequestPriceEstimatedMutationFailure
  | RequestPriceEstimatedMutationSuccess

type RequestPriceEstimatePayload {
  clientMutationId: String
  priceEstimateParamsOrError: RequestPriceEstimateMutationType
}

type RequestPriceEstimatedMutationFailure {
  mutationError: GravityMutationError
}

type RequestPriceEstimatedMutationSuccess {
  submittedPriceEstimateParams: SubmittedPriceEstimateParams
}

type ResizedImageUrl {
  factor: Float!
  height: Int
  src: String!
  srcSet: String!
  url: String!
  width: Int
}

# The conditions for uploading assets to media.artsy.net
type S3PolicyConditionsType {
  # The assigned access control
  acl: String!

  # The bucket to upload to.
  bucket: String!

  # A key which is prefixed on your file
  geminiKey: String!

  # The returned status code, currently always 201
  successActionStatus: String!
}

# An policy for uploading assets to media.artsy.net
type S3PolicyDocumentType {
  # The details for the upload
  conditions: S3PolicyConditionsType!

  # An expiration date string.
  expiration: String!
}

type Sale implements Node {
  # Returns a connection of artworks for a sale.
  artworksConnection(
    after: String
    before: String

    # When this is true and there is no access token present, allow a loader that caches to be used.
    cached: Boolean = true

    # List of artwork IDs to exclude from the response (irrespective of size)
    exclude: [String]
    first: Int
    last: Int
    status: SaleArtworkStatus
  ): ArtworkConnection
  associatedSale: Sale

  # A bid increment policy that explains minimum bids in ranges.
  bidIncrements: [BidIncrement]
  bidder: Bidder

  # Auction's buyer's premium policy.
  buyersPremium: [BuyersPremium]
  cached: Int
  cascadingEndTime: SaleCascadingEndTime

  # Amount of minutes in between each lot closing.
  cascadingEndTimeIntervalMinutes: Int
  collectPayments: Boolean!
  coverImage: Image
  currency: String
  description(format: Format): String
  displayTimelyAt: String
  eligibleSaleArtworksCount: Int
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  endedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  eventEndAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  eventStartAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Amount of time added when a late bid comes in.
  extendedBiddingIntervalMinutes: Int

  # Duration before lot closes that a late bid would extend the end time.
  extendedBiddingPeriodMinutes: Int

  # Suggested filters for associated artworks
  featuredKeywords: [String!]!

  # A formatted description of when the auction starts or ends or if it has ended
  formattedStartDateTime: String
  href: String

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isArtsyLicensed: Boolean!
  isAuction: Boolean
  isAuctionPromo: Boolean
  isBenefit: Boolean
  isClosed: Boolean
  isGalleryAuction: Boolean
  isLiveOpen: Boolean
  isLotConditionsReportEnabled: Boolean

  # True for a cascading-end-time enabled sale where lots have started closing
  isLotsClosing: Boolean!
  isOpen: Boolean
  isPreliminary: Boolean
  isPreview: Boolean
  isRegistrationClosed: Boolean
  isWithBuyersPremium: Boolean
  liveStartAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Returns a live auctions url if the sale is open and start time is after now
  liveURLIfOpen: String
  name: String
  partner: Partner
  profile: Profile
  promotedSale: Sale
  registrationEndsAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A registration for this sale or null
  registrationStatus: Bidder
  requireBidderApproval: Boolean
  requireIdentityVerification: Boolean
  saleAgreement: SaleAgreement
  saleArtwork(id: String!): SaleArtwork
  saleArtworksConnection(
    after: String
    all: Boolean = false
    before: String
    first: Int

    # List of sale artwork internal IDs to fetch
    internalIDs: [ID]
    last: Int
    status: SaleArtworkStatus
  ): SaleArtworkConnection
  saleType: String

  # A slug ID.
  slug: ID!
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  status: String
  symbol: String
  timeZone: String

  # True if the current user needs to undergo identity verification for this sale, false otherwise
  userNeedsIdentityVerification: Boolean
}

type SaleAdministrationFields {
  collectorVetting: String
  id: ID!
  marketingTier: String
  marketingTierConfirmed: Boolean!
  partnerTier: String
  region: String
  status: String
}

type SaleAgreement {
  content(format: Format): String
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  displayEndAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  displayStartAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  published: Boolean!
  sale: Sale
  saleId: String!
  status: SaleAgreementStatus!
  updatedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  userId: String!
}

# A connection to a list of items.
type SaleAgreementConnection {
  # A list of edges.
  edges: [SaleAgreementEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type SaleAgreementEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: SaleAgreement
}

enum SaleAgreementStatus {
  ARCHIVED
  CURRENT
  PAST
}

type SaleArtwork implements ArtworkEdgeInterface & Node {
  artwork: Artwork
  cached: Int
  calculatedCost(
    # Max bid price for the sale artwork
    bidAmountMinor: Int!
  ): CalculatedCost
  counts: SaleArtworkCounts

  # Currency abbreviation (e.g. "USD")
  currency: String
  currentBid: SaleArtworkCurrentBid
  cursor: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  endedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  estimate: String

  # Singular estimate field, if specified
  estimateCents: Int
  extendedBiddingEndAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A formatted description of the lot end date and time
  formattedEndDateTime: String

  # A formatted description of when the lot starts or ends or if it has ended
  formattedStartDateTime: String
  highEstimate: SaleArtworkHighEstimate
  highestBid: SaleArtworkHighestBid

  # A globally unique ID.
  id: ID!
  increments(
    # Whether or not to start the increments at the user's latest bid
    useMyMaxBid: Boolean
  ): [BidIncrementsFormatted]

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  isBidOn: Boolean

  # Can bids be placed on the artwork?
  isBiddable: Boolean

  # Is the user the highest bidder on the sale artwork. (Currently only being used via me.myBids.)
  isHighestBidder: Boolean

  # True if this sale artwork is being watched by a user and they have not bid on it. (Currently only used on me.myBids and me.watchedLotsConnection.)
  isWatching: Boolean
  isWithReserve: Boolean
  lotID: String
  lotLabel(
    # Whether to trim anything past the first alphanumeric chunk
    trim: Boolean = false
  ): String
  lotState: CausalityLotState
  lowEstimate: SaleArtworkLowEstimate
  minimumNextBid: SaleArtworkMinimumNextBid
  node: Artwork
  openingBid: SaleArtworkOpeningBid
  position: Float
  reserve: SaleArtworkReserve
  reserveMessage: String
  reserveStatus: String
  sale: Sale
  saleID: String

  # A slug ID.
  slug: ID!

  # Currency symbol (e.g. "$")
  symbol: String
}

enum SaleArtworkAggregation {
  ARTIST
  FOLLOWED_ARTISTS
  MEDIUM
  TOTAL
}

# A connection to a list of items.
type SaleArtworkConnection {
  # A list of edges.
  edges: [SaleArtworkEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type SaleArtworkCounts {
  bidderPositions(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

type SaleArtworkCurrentBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

# An edge in a connection.
type SaleArtworkEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: SaleArtwork
}

type SaleArtworkHighEstimate {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkHighestBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  cents: Int
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  display: String
  isCancelled: Boolean
}

type SaleArtworkLowEstimate {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkMinimumNextBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkOpeningBid {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

type SaleArtworkReserve {
  # A formatted price with various currency formatting options.
  amount(
    decimal: String = "."
    disambiguate: Boolean = false

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String

  # An amount of money expressed in cents.
  cents: Float

  # A pre-formatted price.
  display: String
}

enum SaleArtworkStatus {
  CLOSED
  OPEN
}

# The results for one of the requested aggregations
type SaleArtworksAggregationResults {
  counts: [AggregationCount]
  slice: SaleArtworkAggregation
}

# A connection to a list of items.
type SaleArtworksConnection implements ArtworkConnectionInterface {
  # Returns aggregation counts for the given filter query.
  aggregations: [SaleArtworksAggregationResults]
  counts: FilterSaleArtworksCounts

  # A list of edges.
  edges: [SaleArtwork]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type SaleCascadingEndTime {
  # A more granular formatted description of when the auction starts or ends if it has ended
  formattedStartDateTime: String

  # A label indicating the interval in minutes in which lots close
  intervalLabel: String
}

# A connection to a list of items.
type SaleConnection {
  # A list of edges.
  edges: [SaleEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type SaleEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Sale
}

type SaleRegistration {
  bidder: Bidder

  # A globally unique ID.
  id: ID!
  isRegistered: Boolean
  sale: Sale
}

# A connection to a list of items.
type SaleRegistrationConnection {
  # A list of edges.
  edges: [SaleRegistrationEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type SaleRegistrationEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: SaleRegistration
}

enum SaleSorts {
  CREATED_AT_ASC
  CREATED_AT_DESC
  ELIGIBLE_SALE_ARTWORKS_COUNT_ASC
  ELIGIBLE_SALE_ARTWORKS_COUNT_DESC
  END_AT_ASC
  END_AT_DESC
  LICENSED_TIMELY_AT_NAME_DESC
  NAME_ASC
  NAME_DESC
  START_AT_ASC
  START_AT_DESC
  TIMELY_AT_NAME_ASC
  TIMELY_AT_NAME_DESC
  _ID_ASC
  _ID_DESC
}

input SaveArtworkInput {
  artworkID: String
  clientMutationId: String
  remove: Boolean
}

type SaveArtworkPayload {
  artwork: Artwork
  clientMutationId: String
  me: Me!
}

# A connection to a list of items.
type SavedArtworksConnection {
  default: Boolean!
  description: String!

  # A list of edges.
  edges: [SavedArtworksEdge]
  name: String!
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  private: Boolean!
  totalCount: Int
}

# An edge in a connection.
type SavedArtworksEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Artwork
}

# Saved Search User Alert Settings
type SavedSearchUserAlertSettings {
  details: String
  email: Boolean!
  frequency: UserSearchCriteriaFrequency!
  name: String
  push: Boolean!
}

enum SavedSearchesSortEnum {
  # Sort by created date in descending order
  CREATED_AT_DESC

  # Sort by name in ascending order
  NAME_ASC
}

enum SearchAggregation {
  TYPE
}

# The results for a requested aggregations
type SearchAggregationResults {
  counts: [AggregationCount]
  slice: SearchAggregation
}

# Search criteria
type SearchCriteria {
  acquireable: Boolean

  # Medium slug
  additionalGeneIDs: [String!]!

  # Medium name
  additionalGeneNames: [String!]!
  artistID: String @deprecated(reason: "Deprecated in favor of artistIDs array")
  artistIDs: [String!]
  artistSeriesIDs: [String!]!
  artistsConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
    sort: ArtistSorts
    term: String
  ): ArtistConnection
  atAuction: Boolean
  attributionClass: [String!]!
  colors: [String!]!
  dimensionRange: String
  displayName: String!

  # Human readable price range value
  formattedPriceRange: String
  height: String
  highPriceAmount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  href: String!
  inquireableOnly: Boolean
  internalID: ID!
  keyword: String

  # Human-friendly labels that are added by Metaphysics to the upstream SearchCriteria type coming from Gravity
  labels: [SearchCriteriaLabel!]!
  locationCities: [String!]!
  lowPriceAmount(
    decimal: String = "."

    # Allows control of symbol position (%v = value, %s = symbol)
    format: String = "%s%v"
    precision: Int = 0
    symbol: String
    thousand: String = ","
  ): String
  majorPeriods: [String!]!
  materialsTerms: [String!]!
  offerable: Boolean
  partnerIDs: [String!]!
  priceRange: String
  sizes: [String!]!

  # Summary of the fields selected
  summary: JSON
  userAlertSettings: SavedSearchUserAlertSettings!
  userSearchCriteriaCount: Int!
  width: String
}

# Attributes for a search criteria
input SearchCriteriaAttributes {
  acquireable: Boolean = null
  additionalGeneIDs: [String!] = []

  # DEPRECATED Please use artistIDs instead
  artistID: String = null
  artistIDs: [String!] = []
  artistSeriesIDs: [String!] = []
  atAuction: Boolean = null
  attributionClass: [String!] = []
  colors: [String!] = []
  dimensionRange: String = null
  height: String = null
  inquireableOnly: Boolean = null
  keyword: String = null
  locationCities: [String!] = []
  majorPeriods: [String!] = []
  materialsTerms: [String!] = []
  offerable: Boolean = null
  partnerIDs: [String!] = []
  priceRange: String = null
  sizes: [String!] = []
  width: String = null
}

# The connection type for SearchCriteria.
type SearchCriteriaConnection {
  # A list of edges.
  edges: [SearchCriteriaEdge]

  # A list of nodes.
  nodes: [SearchCriteria]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type SearchCriteriaEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: SearchCriteria
}

enum SearchCriteriaFields {
  acquireable
  additionalGeneIDs
  artistIDs
  artistSeriesIDs
  atAuction
  attributionClass
  colors
  height
  inquireableOnly
  locationCities
  majorPeriods
  materialsTerms
  offerable
  partnerIDs
  priceRange
  sizes
  width
}

# Human-friendly representation of a single SearchCriteria filter
type SearchCriteriaLabel {
  # The human-friendly label of the filter facet
  displayValue: String!

  # The GraphQL field name of the filter facet
  field: String!

  # The human-friendly name of the filter facet
  name: String!

  # The value of the filter facet
  value: String!
}

# A search criteria or errors object
union SearchCriteriaOrErrorsUnion = Errors | SearchCriteria

enum SearchEntity {
  ARTICLE
  ARTIST
  ARTIST_SERIES
  ARTWORK
  CITY
  COLLECTION
  FAIR
  FEATURE
  GALLERY
  GENE
  INSTITUTION
  PAGE
  PROFILE
  SALE
  SHOW
  TAG
  VIEWING_ROOM
}

enum SearchMode {
  AUTOSUGGEST
  SITE
}

# An object that may be searched for
interface Searchable {
  displayLabel: String
  href: String
  imageUrl: String
}

# A connection to a list of items.
type SearchableConnection {
  # Returns aggregation counts for the given filter query.
  aggregations: [SearchAggregationResults]

  # A list of edges.
  edges: [SearchableEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type SearchableEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Searchable
}

type SearchableItem implements Node & Searchable {
  description: String
  displayLabel: String
  displayType: String
  href: String

  # A globally unique ID.
  id: ID!
  imageUrl: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # A slug ID.
  slug: ID!
}

interface SecondFactor {
  createdAt: ISO8601DateTime!
  disabledAt: ISO8601DateTime
  enabled: Boolean!
  enabledAt: ISO8601DateTime
  internalID: ID!
  kind: SecondFactorKind!
  updatedAt: ISO8601DateTime!
}

# Two-Factor Authentication (2FA) Method
enum SecondFactorKind {
  # App authenticator 2FA method
  app

  # Backup 2FA method
  backup

  # SMS 2FA method
  sms
}

# A second factor or errors
union SecondFactorOrErrorsUnion = AppSecondFactor | Errors | SmsSecondFactor

# A piece that can be sold
interface Sellable {
  dimensions: dimensions
  editionOf: String

  # Whether a piece can be purchased through e-commerce
  isAcquireable: Boolean
  isForSale: Boolean

  # Whether a user can make an offer on the work
  isOfferable: Boolean

  # Whether a user can make an offer on the work through inquiry
  isOfferableFromInquiry: Boolean
  isSold: Boolean
  saleMessage: String
}

type SendConfirmationEmailMutationFailure {
  mutationError: GravityMutationError
}

input SendConfirmationEmailMutationInput {
  clientMutationId: String
}

type SendConfirmationEmailMutationPayload {
  clientMutationId: String
  confirmationOrError: SendConfirmationEmailMutationType
}

type SendConfirmationEmailMutationSuccess {
  confirmationSentAt: String
  unconfirmedEmail: String
}

union SendConfirmationEmailMutationType =
    SendConfirmationEmailMutationFailure
  | SendConfirmationEmailMutationSuccess

input SendConversationMessageMutationInput {
  # Attachments to the message
  attachments: [ConversationMessageAttachmentInput!]

  # Message body (html)
  bodyHTML: String

  # Message body (text)
  bodyText: String!
  clientMutationId: String

  # Sender email, optionally including display string (like 'Jane Doe <jane@doe.com>').
  from: String!

  # Sender user id
  fromId: String

  # The id of the conversation to be updated
  id: String!

  # Reply to all
  replyAll: Boolean = true

  # The message being replied to
  replyToMessageID: String!

  # Recepients emails.
  to: [String]
}

type SendConversationMessageMutationPayload {
  clientMutationId: String
  conversation: Conversation
  messageEdge: MessageEdge
}

type SendFeedbackMutationFailure {
  mutationError: GravityMutationError
}

input SendFeedbackMutationInput {
  clientMutationId: String

  # Email to associate with message (only used if logged out).
  email: String

  # Message to be sent.
  message: String!

  # Name to associate with message (only used if logged out).
  name: String

  # URL of page where feedback originated.
  url: String
}

type SendFeedbackMutationPayload {
  clientMutationId: String
  feedbackOrError: SendFeedbackMutationType
}

type SendFeedbackMutationSuccess {
  feedback: Feedback
}

union SendFeedbackMutationType = SendFeedbackMutationFailure | SendFeedbackMutationSuccess

input SendIdentityVerificationEmailMutationInput {
  clientMutationId: String

  # The email for the user undergoing identity verification
  email: String

  # The ID of the user (self or admin) who initiated the IDV process
  initiatorID: String

  # The name to be used for the user undergoing identity verification
  name: String

  # The ID of the order where the IDV process was initated
  orderID: String

  # The ID of the sale where the IDV process was initated
  saleID: String

  # Whether an automated identity verification is sent or not
  sendEmail: Boolean

  # The user Id for the user undergoing identity verification
  userID: String
}

type SendIdentityVerificationEmailMutationPayload {
  clientMutationId: String
  confirmationOrError: IdentityVerificationEmailMutationType
}

type Services {
  convection: ConvectionService!
  metaphysics: MetaphysicsService!
}

type Shortcut {
  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  long: String!
  short: String!
}

type Show implements EntityWithFilterArtworksConnectionInterface & Node {
  # The Artists presenting in this show
  artists: [Artist]

  # Artists in the show grouped by last name
  artistsGroupedByName: [ArtistGroup]

  # Artists inside the show who do not have artworks present
  artistsWithoutArtworks: [Artist]

  # The artworks featured in the show.
  artworksConnection(
    after: String
    before: String

    # List of artwork IDs to exclude from the response (irrespective of size)
    exclude: [String]
    first: Int
    forSale: Boolean = false
    last: Int
    published: Boolean = true
  ): ArtworkConnection

  # The total count of artworks, both unpublished and published, in a show
  artworksCount: Int
  cached: Int

  # The general city, derived from a fair location, a show location or a potential city
  city: String

  # An object that represents some of the numbers you might want to highlight
  counts: ShowCounts

  # The image you should use to represent this show
  coverImage: Image
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A description of the show
  description: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Events from the partner that runs this show
  events: [ShowEventType]

  # A formatted description of the start to end dates
  exhibitionPeriod(
    # Formatting option to apply to exhibition period
    format: ExhibitionPeriodFormat = LONG
  ): String

  # If the show is in a Fair, then that fair
  fair: Fair

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A Connection of followed artists by current user for this show
  followedArtistsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ShowFollowArtistConnection

  # Flag showing if show has any location.
  hasLocation: Boolean

  # A path to the show on Artsy
  href: String

  # A globally unique ID.
  id: ID!

  # Images that represent the show, you may be interested in meta_image or cover_image for a definitive thumbnail
  images(
    # Pass true/false to include cover or not
    default: Boolean
    page: Int

    # Number of images to return
    size: Int
  ): [Image]

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Gravity doesnâ€™t expose the `active` flag. Temporarily re-state its logic.
  isActive: Boolean

  # Is this something we can display to the front-end?
  isDisplayable: Boolean

  # Does the show exist as a fair booth?
  isFairBooth: Boolean
  isFeatured: Boolean

  # Is the user following this show
  isFollowed: Boolean

  # Does the show exist soley online
  isOnlineExclusive: Boolean!

  # Is it a show provided for historical reference?
  isReference: Boolean

  # Is it an outsourced local discovery stub show?
  isStubShow: Boolean

  # Whether the show is in a fair, group or solo
  kind: String

  # Where the show is located (Could also be a fair location)
  location: Location

  # An image representing the show, or a sharable image from an artwork in the show
  metaImage: Image

  # The exhibition title
  name: String

  # Shows that are near (~75km) from this show
  nearbyShowsConnection(
    after: String
    before: String

    # Whether to include local discovery stubs as well as displayable shows
    discoverable: Boolean
    first: Int
    last: Int
    sort: ShowSorts

    # By default show only current shows
    status: EventStatus = CURRENT
  ): ShowConnection

  # Alternate Markdown-supporting free text representation of the opening reception eventâ€™s date/time
  openingReceptionText: String

  # The partner that represents this show, could be a non-Artsy partner
  partner: PartnerTypes

  # The press release for this show
  pressRelease(format: Format): String

  # Link to the press release for this show
  pressReleaseUrl: String

  # A slug ID.
  slug: ID!

  # When this show starts
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Is this show running, upcoming or closed?
  status: String

  # A formatted update on upcoming status changes
  statusUpdate(
    # Before this many days no update will be generated
    maxDays: Int
  ): String

  # Is it a fair booth or a show?
  type: String
  viewingRoomIDs: [String!]!
  viewingRoomsConnection: ViewingRoomsConnection
}

type ShowArtworkGrid implements ArtworkContextGrid {
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection
  ctaHref: String
  ctaTitle: String
  title: String
}

# A connection to a list of items.
type ShowConnection {
  # A list of edges.
  edges: [ShowEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

type ShowCounts {
  artists: Int
  artworks(
    # The slug or ID of an artist in the show.
    artistID: String
  ): Int
  eligibleArtworks(
    # Returns a `String` when format is specified. e.g.`'0,0.0000''`
    format: String
    label: String
  ): FormattedNumber
}

# An edge in a connection.
type ShowEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: Show
}

type ShowEventType {
  # A formatted description of the dates with hours
  dateTimeRange: String
  description: String
  endAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  eventType: String

  # A formatted description of the start to end dates
  exhibitionPeriod(
    # Formatting option to apply to exhibition period
    format: ExhibitionPeriodFormat = LONG
  ): String
  startAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  title: String
}

type ShowFollowArtist {
  artist: Artist
}

# A connection to a list of items.
type ShowFollowArtistConnection {
  # A list of edges.
  edges: [ShowFollowArtistEdge]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type ShowFollowArtistEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: ShowFollowArtist
}

type ShowOpenedNotificationItem {
  partner: Partner
  showsConnection(after: String, before: String, first: Int, last: Int): ShowConnection
}

enum ShowSorts {
  CREATED_AT_DESC
  END_AT_ASC
  END_AT_DESC
  FEATURED_ASC
  FEATURED_DESC
  FEATURED_DESC_END_AT_DESC
  NAME_ASC
  NAME_DESC
  PARTNER_ASC
  SORTABLE_NAME_ASC
  SORTABLE_NAME_DESC
  START_AT_ASC
  START_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# SMS Two-Factor Authentication factor
type SmsSecondFactor implements SecondFactor {
  countryCode: String
  createdAt: ISO8601DateTime!
  disabledAt: ISO8601DateTime
  enabled: Boolean!
  enabledAt: ISO8601DateTime
  formattedPhoneNumber: String
  internalID: ID!
  kind: SecondFactorKind!
  lastDeliveredAt: ISO8601DateTime
  maskedPhone: String @deprecated(reason: "Use formattedPhoneNumber instead")
  phoneNumber: String
  updatedAt: ISO8601DateTime!
}

# SMS second factor input attributes
input SmsSecondFactorAttributes {
  # ISO 3166 country code for the SMS second factor
  countryCode: String

  # Phone number of the SMS second factor
  phoneNumber: String
}

# An SMS second factor or errors
union SmsSecondFactorOrErrorsUnion = Errors | SmsSecondFactor

type SpecialistBio {
  bio: String!
  email: String!
  firstName: String!
  image: Image!
  jobTitle: String!
  name: String!
}

type StartIdentityVerificationFailure {
  mutationError: GravityMutationError
}

union StartIdentityVerificationResponseOrError =
    StartIdentityVerificationFailure
  | StartIdentityVerificationSuccess

type StartIdentityVerificationSuccess {
  # URL that hosts the user-facing identity verification flow (Jumio)
  identityVerificationFlowUrl: String

  # Primary ID of the started identity verification
  identityVerificationId: String
}

type StaticContent {
  content(format: Format): String

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String

  # A slug ID.
  slug: ID!

  # A list of specialists
  specialistBios: [SpecialistBio!]
}

enum SubGroupInputStatus {
  SUBSCRIBED
  UNSUBSCRIBED
}

enum SubGroupStatus {
  SUBSCRIBED
  UNSUBSCRIBED
}

# An edge in a connection.
type SubmissionEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: ConsignmentSubmission
}

input SubmitInquiryRequestMutationInput {
  clientMutationId: String

  # Whether or not to contact the gallery (for instance, for specialist questions)
  contactGallery: Boolean

  # The inquireable object id (Artwork ID or Show ID)
  inquireableID: String!

  # The type of inquireable object (Artwork or Show)
  inquireableType: String!

  # Optional inquiry message
  message: String

  # List of structured inquiry questions
  questions: [InquiryQuestionInput]
}

type SubmitInquiryRequestMutationPayload {
  clientMutationId: String

  # Artwork Inquiry request
  inquiryRequest: InquiryRequest
}

type SubmittedPriceEstimateParams {
  # Artwork ID submitted for estimate
  artworkId: String!

  # Email of the requester
  requesterEmail: String

  # Name of the requester
  requesterName: String

  # Phone number of the requester
  requesterPhoneNumber: String
}

type SuggestedAddress {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  postalCode: String!
  region: String
}

type SuggestedAddressFields {
  address: SuggestedAddress
  lines: [String]
}

type System {
  # Deprecated Algolia fields, temporarily kept for legacy compatibility
  algolia: Algolia @deprecated(reason: "Algolia search is no longer supported")

  # Creates, and authorizes, a JWT custom for Causality
  causalityJWT(
    #
    role: LiveAuctionRole

    # The id of the auction to participate in
    saleID: String!
  ): String
  request: Request

  # The schema for difference micro-service settings
  services: Services

  # Gravity system time, necessary for synchronizing device clocks.
  time: SystemTime

  # List of all available product privileges
  userRoles: [UserRole!]!
}

type SystemTime {
  day: Int
  dst: Boolean
  hour: Int
  iso8601: String
  min: Int
  month: Int
  sec: Int
  unix: Int
  utcOffset: Int
  wday: Int
  year: Int
  zone: String
}

type Tag implements Node {
  cached: Int
  count: Int
  description: String

  # Artworks Elastic Search results
  filterArtworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection
  href: String

  # A globally unique ID.
  id: ID!
  image: Image

  # A type-specific ID likely used as a database ID.
  internalID: ID!
  name: String

  # A slug ID.
  slug: ID!
}

type TargetSupply {
  microfunnel: [TargetSupplyMicrofunnelItem]
}

type TargetSupplyMicrofunnelItem {
  artist: Artist

  # A list of recently sold artworks.
  artworksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Randomize the order of artworks for display purposes.
    randomize: Boolean
  ): ArtworkConnection
  metadata: TargetSupplyMicrofunnelMetadata
}

type TargetSupplyMicrofunnelMetadata {
  highestRealized: String
  realized: String
  recentlySoldArtworkIDs: [String]
  roundedUniqueVisitors: String
  roundedViews: String
  str: String
  uniqueVisitors: String
  views: String
}

type TaxInfo {
  displayText: String!
  moreInfo: TaxMoreInfo!
}

type TaxMoreInfo {
  displayText: String!
  url: String!
}

# Autogenerated input type of TransferMyCollection
input TransferMyCollectionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  emailFrom: String
  emailTo: String
  idFrom: String
  idTo: String
}

# Autogenerated return type of TransferMyCollection
type TransferMyCollectionPayload {
  artworkCountOrError: TransferMyCollectionSuccessOrErrorsUnion!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Successfully transferred My Collection artworks.
type TransferMyCollectionSuccess {
  # Number of transferred artworks.
  count: Int!
}

# A transfer My Collection success or errors object
union TransferMyCollectionSuccessOrErrorsUnion = Errors | TransferMyCollectionSuccess

type TrendingArtists {
  artists: [Artist]
}

enum TriggerCampaignID {
  ART_QUIZ
}

input TriggerCampaignInput {
  campaignID: TriggerCampaignID!
  clientMutationId: String
}

type TriggerCampaignMutationFailure {
  message: String!
  mutationError: GravityMutationError
  statusCode: Int
}

type TriggerCampaignMutationSuccess {
  message: String!
  statusCode: Int
  success: Boolean
}

union TriggerCampaignMutationSuccessOrError =
    TriggerCampaignMutationFailure
  | TriggerCampaignMutationSuccess

type TriggerCampaignPayload {
  clientMutationId: String
  successOrError: TriggerCampaignMutationSuccessOrError
}

union UnderlyingCurrentEvent = Sale | Show

input UnlinkAuthenticationMutationInput {
  clientMutationId: String
  provider: AuthenticationProvider!
}

type UnlinkAuthenticationMutationPayload {
  clientMutationId: String
  me: Me!
}

# Autogenerated input type of UnpublishViewingRoom
input UnpublishViewingRoomInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomID: ID!
}

# Autogenerated return type of UnpublishViewingRoom
type UnpublishViewingRoomPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoom: ViewingRoom!
}

type UpdateAlertFailure {
  mutationError: GravityMutationError
}

union UpdateAlertResponseOrError = UpdateAlertFailure | UpdateAlertSuccess

type UpdateAlertSuccess {
  alert: Alert
}

# Autogenerated input type of UpdateAppSecondFactor
input UpdateAppSecondFactorInput {
  attributes: AppSecondFactorAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorID: ID!
}

# Autogenerated return type of UpdateAppSecondFactor
type UpdateAppSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: AppSecondFactorOrErrorsUnion!
}

type UpdateArtistFailure {
  mutationError: GravityMutationError
}

input UpdateArtistMutationInput {
  alternateNames: [String!]
  awards: String
  birthday: String
  blurb: String
  clientMutationId: String
  coverArtworkId: String
  criticallyAcclaimed: Boolean
  deathday: String
  displayName: String
  first: String
  gender: String
  groupIndicator: ArtistGroupIndicator
  hometown: String
  id: String!
  last: String
  location: String
  middle: String
  nationality: String
  public: Boolean
  recentShow: String
  targetSupplyPriority: ArtistTargetSupplyPriority
  targetSupplyType: ArtistTargetSupplyType
  vanguardYear: String
}

type UpdateArtistMutationPayload {
  # On success: the updated artist
  artistOrError: UpdateArtistResponseOrError
  clientMutationId: String
}

union UpdateArtistResponseOrError = UpdateArtistFailure | UpdateArtistSuccess

type UpdateArtistSuccess {
  artist: Artist
}

input UpdateArtworkMutationInput {
  # The availability of the artwork
  availability: String
  clientMutationId: String

  # The id of the artwork to update.
  id: String!
}

type UpdateArtworkMutationPayload {
  # On success: the artwork updated.
  artworkOrError: updateArtworkResponseOrError
  clientMutationId: String
}

type UpdateCMSLastAccessTimestampFailure {
  mutationError: GravityMutationError
}

input UpdateCMSLastAccessTimestampMutationInput {
  clientMutationId: String

  # The id of the partner to update.
  id: String!
}

type UpdateCMSLastAccessTimestampMutationPayload {
  clientMutationId: String

  # On success: the updated partner. On error: the error that occurred.
  partnerOrError: UpdateCMSLastAccessTimestampResponseOrError
}

union UpdateCMSLastAccessTimestampResponseOrError =
    UpdateCMSLastAccessTimestampFailure
  | UpdateCMSLastAccessTimestampSuccess

type UpdateCMSLastAccessTimestampSuccess {
  partner: Partner
}

type UpdateCareerHighlightFailure {
  mutationError: GravityMutationError
}

input UpdateCareerHighlightInput {
  clientMutationId: String
  collected: Boolean
  group: Boolean
  id: String!
  solo: Boolean
}

type UpdateCareerHighlightPayload {
  # On success: updated Artist Career Highlight.
  careerHighlightOrError: UpdateCareerHighlightsSuccessResponseOrError
  clientMutationId: String
}

type UpdateCareerHighlightSuccess {
  careerHighlight: CareerHighlight
}

union UpdateCareerHighlightsSuccessResponseOrError =
    UpdateCareerHighlightFailure
  | UpdateCareerHighlightSuccess

type UpdateCollectionFailure {
  mutationError: GravityMutationError
}

union UpdateCollectionResponseOrError = UpdateCollectionFailure | UpdateCollectionSuccess

type UpdateCollectionSuccess {
  collection: Collection
}

type UpdateCollectorProfileFailure {
  mutationError: GravityMutationError
}

input UpdateCollectorProfileInput {
  # List of affiliated auction house ids, referencing Galaxy.
  affiliatedAuctionHouseIds: [String]

  # List of affiliated fair ids, referencing Galaxy.
  affiliatedFairIds: [String]

  # List of affiliated gallery ids, referencing Galaxy.
  affiliatedGalleryIds: [String]
  clientMutationId: String
  companyName: String
  companyWebsite: String
  institutionalAffiliations: String
  intents: [Intents]
  loyaltyApplicant: Boolean
  professionalBuyer: Boolean

  # Since we don't want to ask a collector to update their profile too often, set this to record they've been prompted
  promptedForUpdate: Boolean

  # Free-form text of purchases the collector has indicated.
  selfReportedPurchases: String
}

type UpdateCollectorProfilePayload {
  clientMutationId: String

  # On success: the updated collector profile.
  collectorProfileOrError: updateCollectorProfileResponseOrError
}

type UpdateCollectorProfileSuccess {
  collectorProfile: CollectorProfileType
}

type UpdateCollectorProfileWithIDFailure {
  mutationError: GravityMutationError
}

input UpdateCollectorProfileWithIDInput {
  # List of affiliated auction house ids, referencing Galaxy.
  affiliatedAuctionHouseIds: [String]

  # List of affiliated fair ids, referencing Galaxy.
  affiliatedFairIds: [String]

  # List of affiliated gallery ids, referencing Galaxy.
  affiliatedGalleryIds: [String]
  clientMutationId: String
  companyName: String
  companyWebsite: String
  confirmedBuyer: Boolean

  # The internal ID of the collector profile to update
  id: String
  institutionalAffiliations: String
  intents: [Intents]
  loyaltyApplicant: Boolean
  professionalBuyer: Boolean

  # Free-form text of purchases the collector has indicated.
  selfReportedPurchases: String
}

type UpdateCollectorProfileWithIDPayload {
  clientMutationId: String

  # On success: the collector profile
  collectorProfileOrError: UpdateCollectorProfileWithIDResponseOrError
}

union UpdateCollectorProfileWithIDResponseOrError =
    UpdateCollectorProfileWithIDFailure
  | UpdateCollectorProfileWithIDSuccess

type UpdateCollectorProfileWithIDSuccess {
  collectorProfile: CollectorProfileType
}

input UpdateConversationMutationInput {
  clientMutationId: String

  # The id of the conversation to be updated.
  conversationId: String!

  # Mark the conversation as dismissed
  dismissed: Boolean

  # The message id to mark as read as a collector (from).
  fromLastViewedMessageId: String

  # The seller outcome for the conversation. Options include `already_contacted`, `dont_trust`, `other`, `work_unavailable`.
  sellerOutcome: String

  # The seller outcome comment for the conversation.
  sellerOutcomeComment: String

  # The message id to mark as read as a partner (to).
  toLastViewedMessageId: String
}

type UpdateConversationMutationPayload {
  clientMutationId: String
  conversation: Conversation
}

type UpdateFeatureFailure {
  mutationError: GravityMutationError
}

input UpdateFeatureMutationInput {
  active: Boolean
  callout: String
  clientMutationId: String
  description: String
  id: String!
  layout: FeatureLayouts
  name: String
  sourceBucket: String
  sourceKey: String
  subheadline: String
}

type UpdateFeatureMutationPayload {
  clientMutationId: String

  # On success: the feature updated.
  featureOrError: UpdateFeatureResponseOrError
}

union UpdateFeatureResponseOrError = UpdateFeatureFailure | UpdateFeatureSuccess

type UpdateFeatureSuccess {
  feature: Feature
}

type UpdateFeaturedLinkFailure {
  mutationError: GravityMutationError
}

input UpdateFeaturedLinkMutationInput {
  clientMutationId: String
  description: String
  href: String
  id: String!
  sourceBucket: String
  sourceKey: String
  subtitle: String
  title: String
}

type UpdateFeaturedLinkMutationPayload {
  clientMutationId: String

  # On success: featured link updated.
  featuredLinkOrError: UpdateFeaturedLinkResponseOrError
}

union UpdateFeaturedLinkResponseOrError = UpdateFeaturedLinkFailure | UpdateFeaturedLinkSuccess

type UpdateFeaturedLinkSuccess {
  featuredLink: FeaturedLink
}

input UpdateHeroUnitLinkInput {
  text: String!
  url: String!
}

input UpdateHeroUnitMutationInput {
  body: String!
  clientMutationId: String
  credit: String
  endAt: String
  id: String!
  imageUrl: String
  label: String
  link: UpdateHeroUnitLinkInput!
  position: Int
  startAt: String
  title: String!
}

type UpdateHeroUnitMutationPayload {
  clientMutationId: String

  # On success: the hero unit updated.
  heroUnitOrError: updateHeroUnitResponseOrError
}

input UpdateMeCollectionInput {
  id: String!
  shareableWithPartners: Boolean!
}

type UpdateMeCollectionsFailure {
  mutationError: GravityMutationError
}

union UpdateMeCollectionsResponseOrError = UpdateMeCollectionsFailure | UpdateMeCollectionsSuccess

type UpdateMeCollectionsSuccess {
  collection: Collection
}

type UpdateMessageFailure {
  mutationError: GravityMutationError
}

input UpdateMessageMutationInput {
  clientMutationId: String

  # The id of the message to be updated.
  id: String!

  # Mark the message as spam
  spam: Boolean!
}

type UpdateMessageMutationPayload {
  clientMutationId: String

  # On success: the updated conversation
  conversationOrError: UpdateMessageResponseOrError
}

union UpdateMessageResponseOrError = UpdateMessageFailure | UpdateMessageSuccess

type UpdateMessageSuccess {
  conversation: Conversation
}

input UpdateMyPasswordMutationInput {
  clientMutationId: String
  currentPassword: String!
  newPassword: String!
  passwordConfirmation: String!
}

type UpdateMyPasswordMutationPayload {
  clientMutationId: String
  me: Me!
}

input UpdateMyProfileInput {
  # Number of artworks purchased per year.
  artworksPerYear: String

  # The user's bio
  bio: String
  clientMutationId: String

  # The collector level for the user
  collectorLevel: Int

  # The user completed onboarding.
  completedOnboarding: Boolean

  # Currency preference of the user
  currencyPreference: CurrencyPreference

  # The given email of the user.
  email: String

  # Frequency of marketing emails.
  emailFrequency: String

  # Gender.
  gender: String

  # User's icon source_url for Gemini
  iconUrl: String

  # Works in the art industry?
  industry: String

  # Is a collector?
  isCollector: Boolean

  # Length unit preference of the user
  lengthUnitPreference: LengthUnitPreference

  # The given location of the user as structured data
  location: EditableLocation

  # The given name of the user.
  name: String

  # Additional personal notes.
  notes: String

  # Collector's positions with relevant institutions
  otherRelevantPositions: String

  # The user's password, required to change email address.
  password: String

  # The given phone number of the user.
  phone: String
  phoneCountryCode: String
  phoneNumber: String

  # The maximum price collector has selected
  priceRangeMax: Float

  # The minimum price collector has selected
  priceRangeMin: Int

  # Wheter or not the collector shares detailed profile information with galleries.
  privacy: String

  # Profession.
  profession: String

  # Since we don't want to ask a collector to update their profile too often, set this to record they've been prompted
  promptedForUpdate: Boolean

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive order notifications
  receiveOrderNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive partner offer notifications
  receivePartnerOfferNotification: Boolean

  # This user should receive partner show notifications
  receivePartnerShowNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean

  # This user should receive viewing room notifications
  receiveViewingRoomNotification: Boolean

  # Shares FollowArtists, FollowGenes, and FollowProfiles with partners.
  shareFollows: Boolean
}

union UpdateMyProfileMutation = UpdateMyProfileMutationFailure | UpdateMyProfileMutationSuccess

type UpdateMyProfileMutationFailure {
  mutationError: GravityMutationError
}

type UpdateMyProfileMutationSuccess {
  user: User
}

type UpdateMyProfilePayload {
  clientMutationId: String
  me: Me
  user: User
  userOrError: UpdateMyProfileMutation
}

type UpdateOrderedSetFailure {
  mutationError: GravityMutationError
}

input UpdateOrderedSetMutationInput {
  clientMutationId: String
  description: String
  id: String!
  internalName: String
  itemId: String

  # Modify the OrderedSet's items to only included provided ids. An empty array will remove all items from the set
  itemIds: [String]
  itemType: String
  key: String
  layout: OrderedSetLayouts
  name: String
  ownerId: String
  ownerType: String
  published: Boolean
  unsetOwner: Boolean
}

type UpdateOrderedSetMutationPayload {
  clientMutationId: String

  # On success: the ordered set updated.
  orderedSetOrError: UpdateOrderedSetResponseOrError
}

union UpdateOrderedSetResponseOrError = UpdateOrderedSetFailure | UpdateOrderedSetSuccess

type UpdateOrderedSetSuccess {
  feature: Feature
  set: OrderedSet
}

type UpdatePageFailure {
  mutationError: GravityMutationError
}

input UpdatePageMutationInput {
  clientMutationId: String
  content: String!
  id: String!
  name: String!
  published: Boolean!
}

type UpdatePageMutationPayload {
  clientMutationId: String

  # On success: the page updated.
  pageOrError: UpdatePageResponseOrError
}

union UpdatePageResponseOrError = UpdatePageFailure | UpdatePageSuccess

type UpdatePageSuccess {
  page: Page
}

type UpdatePartnerShowFailure {
  mutationError: GravityMutationError
}

input UpdatePartnerShowMutationInput {
  clientMutationId: String

  # Is
  featured: Boolean

  # The id of the partner to update.
  partnerId: String!

  # The id of the artist to update.
  showId: String!
}

type UpdatePartnerShowMutationPayload {
  clientMutationId: String

  # On success: the updated partner. On error: the error that occurred.
  showOrError: UpdatePartnerShowResponseOrError
}

union UpdatePartnerShowResponseOrError = UpdatePartnerShowFailure | UpdatePartnerShowSuccess

type UpdatePartnerShowSuccess {
  show: Show
}

type UpdateSaleAgreementFailure {
  mutationError: GravityMutationError
}

input UpdateSaleAgreementMutationInput {
  clientMutationId: String
  content: String
  displayEndAt: String
  displayStartAt: String
  id: String!
  published: Boolean
  saleId: String
  status: SaleAgreementStatus
}

type UpdateSaleAgreementMutationPayload {
  clientMutationId: String

  # On success: the saleAgreement updated.
  saleAgreementOrError: UpdateSaleAgreementResponseOrError
}

union UpdateSaleAgreementResponseOrError = UpdateSaleAgreementFailure | UpdateSaleAgreementSuccess

type UpdateSaleAgreementSuccess {
  saleAgreement: SaleAgreement
}

# Autogenerated input type of UpdateSavedSearch
input UpdateSavedSearchInput {
  attributes: SearchCriteriaAttributes

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  searchCriteriaID: String!
  userAlertSettings: UserAlertSettingsInput
}

# Autogenerated return type of UpdateSavedSearch
type UpdateSavedSearchPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  savedSearchOrErrors: SearchCriteriaOrErrorsUnion!
}

# Autogenerated input type of UpdateSmsSecondFactor
input UpdateSmsSecondFactorInput {
  attributes: SmsSecondFactorAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorID: ID!
}

# Autogenerated return type of UpdateSmsSecondFactor
type UpdateSmsSecondFactorPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  secondFactorOrErrors: SmsSecondFactorOrErrorsUnion!
}

# Autogenerated input type of UpdateSubmissionMutation
input UpdateSubmissionMutationInput {
  additionalInfo: String
  artistID: String
  attributionClass: ConsignmentAttributionClass
  authenticityCertificate: Boolean
  category: ConsignmentSubmissionCategoryAggregation

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  currency: String
  depth: String
  dimensionsMetric: String
  edition: Boolean
  editionNumber: String

  # Deprecated: Use edition_size_formatted field instead
  editionSize: Int
  editionSizeFormatted: String
  externalId: ID
  height: String
  id: ID
  locationAddress: String
  locationAddress2: String
  locationCity: String
  locationCountry: String
  locationCountryCode: String
  locationPostalCode: String
  locationState: String
  medium: String
  minimumPriceDollars: Int
  provenance: String
  sessionID: String
  signature: Boolean
  state: ConsignmentSubmissionStateAggregation
  title: String
  userEmail: String
  userName: String
  userPhone: String
  utmMedium: String
  utmSource: String
  utmTerm: String
  width: String
  year: String
}

# Autogenerated return type of UpdateSubmissionMutation
type UpdateSubmissionMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consignmentSubmission: ConsignmentSubmission
}

# Autogenerated input type of UpdateUserAddress
input UpdateUserAddressInput {
  attributes: UserAddressAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userAddressID: ID!
}

# Autogenerated return type of UpdateUserAddress
type UpdateUserAddressPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
  userAddressOrErrors: UserAddressOrErrorsUnion!
}

# Autogenerated input type of UpdateUserDefaultAddress
input UpdateUserDefaultAddressInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  userAddressID: ID!
}

# Autogenerated return type of UpdateUserDefaultAddress
type UpdateUserDefaultAddressPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
  userAddressOrErrors: UserAddressOrErrorsUnion!
}

type UpdateUserInterestFailure {
  mutationError: GravityMutationError
}

input UpdateUserInterestInput {
  id: String!
  private: Boolean
}

input UpdateUserInterestMutationInput {
  clientMutationId: String
  id: String!
  private: Boolean
}

type UpdateUserInterestMutationPayload {
  clientMutationId: String
  userInterestEdge: UserInterestEdge

  # On success: the new state of the UserInterest
  userInterestOrError: UpdateUserInterestResponseOrError
}

union UpdateUserInterestOrError = UpdateUserInterestsFailure | UserInterest

union UpdateUserInterestResponseOrError = UpdateUserInterestFailure | UpdateUserInterestSuccess

type UpdateUserInterestSuccess {
  userInterest: UserInterest
}

type UpdateUserInterestsFailure {
  mutationError: GravityMutationError
}

input UpdateUserInterestsMutationInput {
  clientMutationId: String
  userInterests: [UpdateUserInterestInput!]!
}

type UpdateUserInterestsMutationPayload {
  clientMutationId: String
  me: Me!
  userInterestsOrErrors: [UpdateUserInterestOrError!]!
}

input UpdateUserMutationInput {
  clientMutationId: String
  dataTransferOptOut: Boolean
  email: String
  id: String!
  name: String
  phone: String
}

type UpdateUserMutationPayload {
  clientMutationId: String
}

input UpdateUserSaleProfileMutationInput {
  addressLine1: String
  addressLine2: String
  city: String
  clientMutationId: String
  country: String
  id: String!
  requireBidderApproval: Boolean
  state: String
  zip: String
}

type UpdateUserSaleProfileMutationPayload {
  clientMutationId: String
}

# Autogenerated input type of UpdateViewingRoomArtworks
input UpdateViewingRoomArtworksInput {
  artworks: [ViewingRoomArtworkInput!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomID: String!
}

# Autogenerated return type of UpdateViewingRoomArtworks
type UpdateViewingRoomArtworksPayload {
  artworkIDs: [String!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateViewingRoom
input UpdateViewingRoomInput {
  attributes: ViewingRoomAttributes!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  image: ARImageInput
  viewingRoomID: String!
}

# Autogenerated return type of UpdateViewingRoom
type UpdateViewingRoomPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  viewingRoomOrErrors: ViewingRoomOrErrorsUnion!
}

# Autogenerated input type of UpdateViewingRoomSubsections
input UpdateViewingRoomSubsectionsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  subsections: [ViewingRoomSubsectionInput!]!
  viewingRoomID: ID!
}

# Autogenerated return type of UpdateViewingRoomSubsections
type UpdateViewingRoomSubsectionsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  subsections: [ViewingRoomSubsection!]!
}

input UploadSource {
  bucket: String
  key: String
}

input UploadSources {
  buckets: [String!]
  keys: [String!]
}

type User implements Node {
  accessiblePropertiesConnection(
    after: String
    before: String
    first: Int
    last: Int
    model: UserAccessiblePropertyInput
  ): UserAccessiblePropertyConnection

  # The admin notes associated with the user
  adminNotes: [UserAdminNotes]
  analytics: AnalyticsUserStats
  cached: Int
  collectorProfile: CollectorProfileType
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # Has the user opted out of data transfer.
  dataTransferOptOut: Boolean
  devices: [Device!]!

  # The given email of the user.
  email: String!
  emailConfirmationSentAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  emailConfirmedAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  follows: UserFollows

  # A globally unique ID.
  id: ID!
  initials(length: Int = 3): String
  inquiredArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): UserInquiredArtworksConnection
  interestsConnection(after: String, before: String, first: Int, last: Int): UserInterestConnection

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # Has the users identity been verified.
  isIdentityVerified: Boolean!
  lastSignInAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # The given location of the user as structured data
  location: Location
  myCollectionArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ArtworkConnection

  # The given name of the user.
  name: String!

  # The paddle number of the user
  paddleNumber: String

  # The Partner or Profile access granted to the user
  partnerAccess: [String]!

  # The given phone number of the user.
  phone: String

  # Pin for bidding at an auction
  pin: String

  # The price range the collector has selected
  priceRange: String

  # The Partner or Profile access granted to the user
  profileAccess: [String]!
  purchasedArtworksConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): UserPurchasesConnection

  # The art quiz of a logged-in user
  quiz: Quiz!

  # This user should receive lot opening notifications
  receiveLotOpeningSoonNotification: Boolean

  # This user should receive new sales notifications
  receiveNewSalesNotification: Boolean

  # This user should receive new works notifications
  receiveNewWorksNotification: Boolean

  # This user should receive order notifications
  receiveOrderNotification: Boolean

  # This user should receive outbid notifications
  receiveOutbidNotification: Boolean

  # This user should receive partner offer notifications
  receivePartnerOfferNotification: Boolean

  # This user should receive partner show notifications
  receivePartnerShowNotification: Boolean

  # This user should receive promotional notifications
  receivePromotionNotification: Boolean

  # This user should receive purchase notifications
  receivePurchaseNotification: Boolean

  # This user should receive sale opening/closing notifications
  receiveSaleOpeningClosingNotification: Boolean

  # This user should receive viewing room notifications
  receiveViewingRoomNotification: Boolean

  # The roles of the user
  roles: [String]!

  # The sale profile of the user.
  saleProfile: UserSaleProfile
  savedArtworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection

  # If the user has enabled two-factor authentication on their account
  secondFactorEnabled: Boolean!

  # The number of times a user has signed in
  signInCount: Int!

  # The unconfirmed email of the user.
  unconfirmedEmail: String

  # Check whether a user exists by email address before creating an account.
  userAlreadyExists: Boolean
}

union UserAccessibleProperty = Artist | Artwork | Partner | Profile

# A connection to a list of items.
type UserAccessiblePropertyConnection {
  # A list of edges.
  edges: [UserAccessiblePropertyEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserAccessiblePropertyEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: UserAccessibleProperty
}

enum UserAccessiblePropertyInput {
  ARTIST
  ARTWORK
  PARTNER
  PROFILE
}

# User saved address
type UserAddress {
  # Address line 1
  addressLine1: String!

  # Address line 2
  addressLine2: String

  # Address line 3
  addressLine3: String

  # City
  city: String!

  # Country
  country: String!
  id: ID!

  # Unique ID for this address
  internalID: ID!

  # Is default address
  isDefault: Boolean!

  # Name on addreess
  name: String

  # Phone number
  phoneNumber: String

  # Phone number country code
  phoneNumberCountryCode: String

  # Postal Code
  postalCode: String

  # Region
  region: String
}

# Shipping address input attributes
input UserAddressAttributes {
  # Address line 1
  addressLine1: String!

  # Address line 2
  addressLine2: String

  # Address line 3
  addressLine3: String

  # City
  city: String!

  # Country
  country: String!

  # Name
  name: String!

  # Phone number
  phoneNumber: String

  # ISO Phone number country code
  phoneNumberCountryCode: String

  # Postal code
  postalCode: String

  # Region
  region: String
}

# The connection type for UserAddress.
type UserAddressConnection {
  # A list of edges.
  edges: [UserAddressEdge]

  # A list of nodes.
  nodes: [UserAddress]

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Total count of matching nodes, before pagination
  totalCount: Int!
}

# An edge in a connection.
type UserAddressEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: UserAddress
}

# An address or errors object
union UserAddressOrErrorsUnion = Errors | UserAddress

type UserAdminNotes {
  # The body of the admin note
  body: String!
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # The user who created the note
  creator: User

  # A globally unique ID.
  id: ID!

  # A type-specific ID likely used as a database ID.
  internalID: ID!
}

# Settings for user saved search
input UserAlertSettingsInput {
  details: String
  email: Boolean
  frequency: UserSearchCriteriaFrequency
  name: String
  push: Boolean
}

# A connection to a list of items.
type UserConnection {
  # A list of edges.
  edges: [UserEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserEdge {
  # A cursor for use in pagination
  cursor: String!

  # The item at the end of the edge
  node: User
}

type UserFollows {
  artistsConnection(after: String, before: String, first: Int, last: Int): ArtistConnection
  genesConnection(after: String, before: String, first: Int, last: Int): GeneConnection
}

type UserIconDeleteFailureType {
  mutationError: GravityMutationError
}

type UserIconDeleteSuccessType {
  icon: Image
  success: Boolean
}

union UserIconDeletionMutationType = UserIconDeleteFailureType | UserIconDeleteSuccessType

# A connection to a list of items.
type UserInquiredArtworksConnection {
  # A list of edges.
  edges: [UserInquiredArtworksEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserInquiredArtworksEdge {
  createdAt(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  isSentToGallery: Boolean

  # The item at the end of the edge
  node: Artwork
  note: String
  outcome: String

  # This reflects the `title` attribute of the most recent embedded object in `statuses`
  status: String
}

type UserInterest {
  body: String
  category: UserInterestCategory!

  # A globally unique ID.
  id: ID!
  interest: UserInterestInterest!

  # A type-specific ID.
  internalID: ID!
  ownerType: UserInterestOwnerType
  private: Boolean!
}

enum UserInterestCategory {
  COLLECTED_BEFORE
  INTERESTED_IN_COLLECTING
}

# A connection to a list of items.
type UserInterestConnection {
  # A list of edges.
  edges: [UserInterestEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserInterestEdge {
  body: String
  category: UserInterestCategory!
  createdByAdmin: Boolean!

  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!

  # The item at the end of the edge
  node: UserInterestInterest
  ownerType: String
  private: Boolean!
}

input UserInterestInput {
  anonymousSessionId: String

  # Optional body for note
  body: String
  category: UserInterestCategory!
  interestId: String!
  interestType: UserInterestInterestType!
  private: Boolean
  sessionID: String
}

union UserInterestInterest = Artist | Gene

enum UserInterestInterestType {
  ARTIST
  GENE
}

union UserInterestOrError = CreateUserInterestFailure | UserInterest

enum UserInterestOwnerType {
  COLLECTOR_PROFILE
  USER_SALE_PROFILE
}

# A connection to a list of items.
type UserPurchasesConnection {
  # A list of edges.
  edges: [UserPurchasesEdge]
  pageCursors: PageCursors!

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
}

# An edge in a connection.
type UserPurchasesEdge {
  # A cursor for use in pagination
  cursor: String!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!

  # The item at the end of the edge
  node: Artwork
  ownerType: String
  saleDate(
    format: String

    # A tz database time zone, otherwise falls back to "X-TIMEZONE" header. See http://www.iana.org/time-zones, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    timezone: String
  ): String
  salePrice: Float
  source: String
}

# Fields corresponding to a given product privilege
type UserRole {
  # unique label for this role
  name: String!
}

type UserSaleProfile {
  # The first line of address for this user.
  addressLine1: String

  # The second line of address for this user.
  addressLine2: String

  # The alternative email for this user
  alternativeEmail: String

  # The birth year for this user
  birthYear: Int

  # The buyer status for this user
  buyerStatus: Int

  # The city for this user.
  city: String

  # The country for this user.
  country: String

  # The email for this user
  email: String

  # The employer for this user
  employer: String

  # The first name for this user
  firstName: String

  # The gender for this user
  gender: String

  # A globally unique ID.
  id: ID!

  # The indusrty for this user
  industry: String

  # A type-specific ID likely used as a database ID.
  internalID: ID!

  # The job title for this user
  jobTitle: String

  # The last name  for this user
  lastName: String

  # The marital status for this user
  maritalStatus: String

  # The name for this user
  name: String

  # The prefix for this user
  prefix: String

  # The price range for this user
  priceRange: Int

  # The profession for this user
  profession: String

  # If this user requires manual approval for auction bidding
  requireBidderApproval: Boolean!

  # The salary(USD) for this user
  salaryUSD: Int

  # The spouse for this user
  spouse: String

  # The state for this user.
  state: String

  # The zip for this user.
  zip: String
}

enum UserSearchCriteriaFrequency {
  daily
  instant
}

union VanityURLEntityType = Fair | Partner

enum VerificationStatuses {
  NOT_FOUND
  NOT_PERFORMED
  VERIFICATION_UNAVAILABLE
  VERIFIED_NO_CHANGE
  VERIFIED_WITH_CHANGES
}

type VerifiedRepresentative implements Node {
  artist: Artist!

  # A globally unique ID.
  id: ID!

  # A type-specific ID.
  internalID: ID!
  partner: Partner!
}

type VerifyAddressFailureType {
  mutationError: GravityMutationError
}

input VerifyAddressInput {
  addressLine1: String!
  addressLine2: String
  city: String
  clientMutationId: String
  country: String!
  postalCode: String!
  region: String
}

union VerifyAddressMutationType = VerifyAddressFailureType | VerifyAddressType

type VerifyAddressPayload {
  clientMutationId: String
  verifyAddressOrError: VerifyAddressMutationType
}

type VerifyAddressType {
  addressVerificationId: String!
  inputAddress: InputAddressFields!
  suggestedAddresses: [SuggestedAddressFields]!
  verificationStatus: VerificationStatuses!
}

type VerifyUser {
  exists: Boolean!
}

# An object containing video metadata
type Video {
  # The height of the video
  height: Int!
  id: ID!

  # Returns a full-qualified url that can be embedded in an iframe player
  playerUrl: String!

  # The width of the video
  width: Int!
}

# A wildcard used to support complex root queries in Relay
type Viewer {
  # Do not use (only used internally for stitching)
  _do_not_use_conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Do not use (only used internally for stitching)
  _do_not_use_image: Image
  admin: Admin

  # An Article
  article(
    # The ID of the Article
    id: String!
  ): Article

  # A list of Articles
  articles(
    auctionID: String
    channelID: String
    featured: Boolean

    #
    #         Only return articles matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    layout: ArticleLayout
    limit: Int
    offset: Int
    omit: [String!]
    published: Boolean = true
    showID: String
    sort: ArticleSorts
  ): [Article!]!

  # A connection of articles
  articlesConnection(
    after: String
    before: String
    channelId: String
    featured: Boolean
    first: Int

    # Get only articles with 'standard', 'feature', 'series' or 'video' layouts.
    inEditorialFeed: Boolean
    last: Int
    layout: ArticleLayout
    omit: [String!]
    page: Int
    sort: ArticleSorts
  ): ArticleConnection

  # An Artist
  artist(
    # The slug or ID of the Artist
    id: String!
  ): Artist

  # A list of Artists
  artists(
    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    page: Int = 1
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs. (e.g. 'andy-warhol', 'banksy')
    #
    slugs: [String]
    sort: ArtistSorts
  ): [Artist]

  # A list of artists
  artistsConnection(
    after: String
    before: String
    first: Int

    #
    #         Only return artists matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    last: Int
    letter: String
    page: Int
    size: Int

    #
    #         Only return artists matching specified slugs.
    #         Accepts list of slugs (e.g. 'andy-warhol', 'banksy').
    #
    slugs: [String]
    sort: ArtistSorts

    # If present, will search by term
    term: String
  ): ArtistConnection

  # An Artwork
  artwork(
    # The slug or ID of the Artwork
    id: String!
  ): Artwork

  # List of all artwork attribution classes
  artworkAttributionClasses: [AttributionClass]

  # List of all artwork mediums
  artworkMediums: [ArtworkMedium]

  # An artwork result
  artworkResult(
    # The slug or ID of the artwork
    id: String!
  ): ArtworkResult

  # A list of Artworks
  artworks(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int
    respectParamsOrder: Boolean = false
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # Artworks Elastic Search results
  artworksConnection(
    acquireable: Boolean
    additionalGeneIDs: [String]
    after: String
    aggregationPartnerCities: [String]
    aggregations: [ArtworkAggregation]
    artistID: String
    artistIDs: [String]
    artistNationalities: [String]
    artistSeriesID: String
    artistSeriesIDs: [String]
    atAuction: Boolean
    attributionClass: [String]
    before: String
    color: String
    colors: [String]
    dimensionRange: String
    excludeArtworkIDs: [String]
    extraAggregationGeneIDs: [String]
    first: Int
    forSale: Boolean
    geneID: String
    geneIDs: [String]
    height: String
    includeArtworksByFollowedArtists: Boolean
    includeMediumFilterInAggregation: Boolean
    input: FilterArtworksInput
    inquireableOnly: Boolean
    keyword: String

    # When true, will only return exact keyword match
    keywordMatchExact: Boolean
    last: Int
    locationCities: [String]
    majorPeriods: [String]

    # When true, will only return `marketable` works (not nude or provocative).
    marketable: Boolean
    marketingCollectionID: String
    materialsTerms: [String]

    # A string from the list of allocations, or * to denote all mediums
    medium: String
    offerable: Boolean
    page: Int
    partnerCities: [String]
    partnerID: ID
    partnerIDs: [String]
    period: String
    periods: [String]
    priceRange: String
    saleID: ID
    size: Int

    # Filter results by Artwork sizes
    sizes: [ArtworkSizes]
    sort: String
    tagID: String
    width: String
  ): FilterArtworksConnection

  # A connection of artworks for a user.
  artworksForUser(
    after: String
    before: String
    excludeArtworkIds: [String] = []
    excludeDislikedArtworks: Boolean = false
    first: Int
    includeBackfill: Boolean!
    last: Int
    marketable: Boolean
    maxWorksPerArtist: Int
    onlyAtAuction: Boolean = false
    page: Int
    userId: String
    version: String
  ): ArtworkConnection

  # An auction result
  auctionResult(
    # The ID or slug of the auction result
    id: String!
  ): AuctionResult

  # If user is logged out; status is `LOGGED_OUT`. If user is logged in; status is `LOGGED_IN`. If user is logged in with invalid authentication (401); 'Promise' resolves to 'Status.Invalid'. All other status codes will resolve to `LOGGED_IN` because we don't know whether or not the authentication is valid (error could be something else).
  authenticationStatus: AuthenticationStatus!

  # A user's bank account
  bankAccount(
    # The ID of the bank account
    id: String!
  ): BankAccount
  channel(id: ID!): Channel!

  # A list of cities
  cities(featured: Boolean = false): [City!]!

  # A city-based entry point for local discovery
  city(
    # A point which will be used to locate the nearest local discovery city within a threshold
    near: Near

    # A slug for the city, conforming to Gravity's city slug naming conventions
    slug: String
  ): City

  # A collector profile.
  collectorProfile(userID: String): CollectorProfileType

  # A list of collector profiles that have sent an inquiry to a partner
  collectorProfilesConnection(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: ID

    # Term used for searching collector profiles
    term: String
  ): CollectorProfileTypeConnection
  commerceOrders(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    buyerId: String
    buyerType: String

    # Returns the first _n_ elements from the list.
    first: Int
    impulseConversationId: String

    # Returns the last _n_ elements from the list.
    last: Int
    mode: CommerceOrderModeEnum
    sellerId: String
    sellerType: String
    sort: CommerceOrderConnectionSortEnum
    state: CommerceOrderStateEnum
    states: [CommerceOrderStateEnum!]
  ): CommerceOrderConnectionWithTotalCount

  # A conversation, usually between a user and a partner
  conversation(
    # The ID of the Conversation
    id: String!
  ): Conversation

  # Conversations, usually between a user and partner.
  conversationsConnection(
    after: String
    artistId: String
    before: String
    dismissed: Boolean
    first: Int
    fromId: String
    hasMessage: Boolean
    hasReply: Boolean
    last: Int
    partnerId: String
    toBeReplied: Boolean
    type: ConversationsInputMode = USER
  ): ConversationConnection

  # A user's credit card
  creditCard(
    # The ID of the Credit Card
    id: String!
  ): CreditCard

  # A list of trending artists. Inferred from a manually curated collection of trending artworks.
  curatedTrendingArtists(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the first n items from the list.
    first: Int

    # Returns the last n items from the list.
    last: Int
  ): ArtistConnection
  departments: [Department!]!

  # A namespace external partners (provided by Galaxy)
  external: External!

  # A Fair
  fair(
    # The slug or ID of the Fair
    id: String!
  ): Fair

  # A fair organizer, e.g. The Armory Show
  fairOrganizer(
    # The slug or ID of the Fair organizer
    id: String!
  ): FairOrganizer

  # A list of Fairs
  fairs(
    fairOrganizerID: String
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    #
    #         Only return fairs matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]
    near: Near
    page: Int
    size: Int
    sort: FairSorts
    status: EventStatus
  ): [Fair]

  # A list of fairs
  fairsConnection(
    after: String
    before: String
    fairOrganizerID: String
    first: Int
    hasFullFeature: Boolean
    hasHomepageSection: Boolean
    hasListing: Boolean

    # Only return fairs matching specified IDs. Accepts list of IDs.
    ids: [String]
    last: Int
    near: Near
    sort: FairSorts
    status: EventStatus
  ): FairConnection

  # A Feature
  feature(
    # The slug or ID of the Feature
    id: ID
  ): Feature
  featuredLinksConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): FeaturedLinkConnection
  featuresConnection(
    after: String
    before: String
    first: Int
    last: Int
    sort: FeatureSorts

    # If present, will search by term
    term: String
  ): FeatureConnection

  # Partners Elastic Search results
  filterPartners(
    aggregations: [PartnersAggregation]!
    defaultProfilePublic: Boolean
    eligibleForCarousel: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Indicates tier 1/2 for gallery, 1 for institution
    eligibleForPrimaryBucket: Boolean

    # Indicates tier 3/4 for gallery, 2 for institution
    eligibleForSecondaryBucket: Boolean

    # Exclude partners the user follows (only effective when `include_partners_with_followed_artists` is set to true).
    excludeFollowedPartners: Boolean
    hasFullProfile: Boolean
    ids: [String]

    # If true, will only return partners that are located near the user's location based on the IP address.
    includePartnersNearIpBasedLocation: Boolean = false

    # If true, will only return partners that list artists that the user follows
    includePartnersWithFollowedArtists: Boolean

    # Max distance to use when geo-locating partners, defaults to 75km.
    maxDistance: Int

    # Coordinates to find partners closest to
    near: String
    page: Int

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    size: Int
    sort: PartnersSortType

    # term used for searching Partners
    term: String
    type: [PartnerClassification]
  ): FilterPartners
  gene(
    # The slug or ID of the Gene
    id: String!
  ): Gene

  # A list of Gene Families
  geneFamiliesConnection(after: String, before: String, first: Int, last: Int): GeneFamilyConnection

  # A list of Genes
  genes(
    size: Int

    #
    #         Only return genes matching specified slugs.
    #         Accepts list of slugs.
    #
    slugs: [String]
  ): [Gene]

  # A Hero Unit.
  heroUnit(
    # The ID of the Hero Unit
    id: String!
  ): HeroUnit
  heroUnitsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If true will include inactive hero units.
    private: Boolean = false

    # If present will search by term.
    term: String
  ): HeroUnitConnection
  highlights: Highlights

  # Home screen content
  homePage: HomePage

  # Home view content
  homeView: HomeView!

  # An identity verification that the user has access to
  identityVerification(
    # ID of the IdentityVerification
    id: String!
  ): IdentityVerification

  # A connection of identity verifications.
  identityVerificationsConnection(
    after: String
    before: String
    email: String
    first: Int
    last: Int
    name: String
    page: Int
    size: Int
    userId: String
  ): IdentityVerificationConnection
  job(id: ID!): Job!
  jobs: [Job!]!
  markdown(content: String!): MarkdownContent
  marketingCollections(
    artistID: String
    category: String
    isFeaturedArtistContent: Boolean
    size: Int
    slugs: [String!]
  ): [MarketingCollection]

  # A Search for Artists
  matchArtist(
    # Exclude these MongoDB ids from results
    excludeIDs: [String]

    # Page to retrieve. Default: 1.
    page: Int

    # Maximum number of items to retrieve. Default: 5.
    size: Int

    # Your search term
    term: String!
  ): [Artist]
  matchConnection(
    after: String
    before: String

    # ARTIST_SERIES, CITY, COLLECTION, and VIEWING_ROOM are not yet supported
    entities: [SearchEntity!] = [
      ARTIST
      ARTIST_SERIES
      ARTWORK
      ARTICLE
      CITY
      COLLECTION
      FAIR
      FEATURE
      GALLERY
      GENE
      INSTITUTION
      PAGE
      PROFILE
      SALE
      SHOW
      TAG
      VIEWING_ROOM
    ]
    first: Int
    last: Int

    # Mode of search to execute
    mode: SearchMode = SITE
    page: Int = 1
    size: Int = 10
    term: String!
  ): MatchConnection
  me: Me

  # Fetches an object given its globally unique ID.
  node(
    # The globally unique ID of the node.
    id: ID!
  ): Node

  # User's notification preferences
  notificationPreferences(authenticationToken: String): [NotificationPreference!]!

  # A feed of notifications
  notificationsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # Notification types to return
    notificationTypes: [NotificationTypesEnum]
  ): NotificationConnection

  # An OrderedSet
  orderedSet(
    # The ID of the OrderedSet
    id: String!
  ): OrderedSet

  # A collection of OrderedSets
  orderedSets(
    # Key to the OrderedSet or group of OrderedSets
    key: String!
    public: Boolean = true
  ): [OrderedSet]

  # A connection of Ordered Sets
  orderedSetsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): OrderedSetConnection
  page(id: ID!): Page!
  pagesConnection(
    after: String
    before: String
    first: Int
    last: Int

    # If present, will search by term
    term: String
  ): PageConnection

  # A Partner
  partner(
    # The slug or ID of the Partner
    id: String!
  ): Partner

  # Retrieve all partner documents for a given partner
  partnerArtistDocumentsConnection(
    after: String

    # The slug or ID of the Artist
    artistID: String!
    before: String
    first: Int
    last: Int
    page: Int

    # The slug or ID of the Partner
    partnerID: String!
    size: Int
  ): PartnerArtistDocumentConnection @deprecated(reason: "Prefer `partner.documentsConnection`")

  # A list of Artworks for a partner
  partnerArtworks(
    after: String
    before: String
    first: Int
    last: Int
    partnerID: String!
    private: Boolean
    viewingRoomID: String
  ): ArtworkConnection
    @deprecated(
      reason: "This is only for use in resolving stitched queries, not for first-class client use."
    )

  # A list of PartnerCategories
  partnerCategories(
    categoryType: PartnerCategoryType

    # Filter by whether category is internal
    internal: Boolean = false
    size: Int
  ): [PartnerCategory]

  # A PartnerCategory
  partnerCategory(
    # The slug or ID of the PartnerCategory
    id: String!
  ): PartnerCategory

  # Retrieve all partner show documents for a given partner and show
  partnerShowDocumentsConnection(
    after: String
    before: String
    first: Int
    last: Int
    page: Int

    # The slug or ID of the Partner
    partnerID: String!

    # The slug or ID of the Show
    showID: String!
    size: Int
  ): PartnerShowDocumentConnection @deprecated(reason: "Prefer `partner.documentsConnection`")

  # A list of Partners
  partnersConnection(
    after: String
    before: String
    defaultProfilePublic: Boolean

    # Indicates an active subscription
    eligibleForListing: Boolean

    # Exclude partners the user follows (only effective when `include_partners_with_followed_artists` is set to true).
    excludeFollowedPartners: Boolean
    first: Int
    ids: [String]

    # If true, will only return partners that are located near the user's location based on the IP address.
    includePartnersNearIpBasedLocation: Boolean = false

    # If true, will only return partners that list artists that the user follows
    includePartnersWithFollowedArtists: Boolean
    last: Int

    # Max distance to use when geo-locating partners, defaults to 75km.
    maxDistance: Int

    # Coordinates to find partners closest to
    near: String

    #
    #         Only return partners of the specified partner categories.
    #         Accepts list of slugs.
    #
    partnerCategories: [String]
    sort: PartnersSortType
    type: [PartnerClassification]
  ): PartnerConnection

  # Phone number information
  phoneNumber(phoneNumber: String!, regionCode: String): PhoneNumberType

  # A previewed saved search
  previewSavedSearch(
    # The criteria which describe the alert
    attributes: PreviewSavedSearchAttributes
  ): PreviewSavedSearch

  # A Profile
  profile(
    # The slug or ID of the Profile
    id: String!
  ): Profile

  # A list of Profiles
  profilesConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int

    # If present, will search by term
    term: String
  ): ProfileConnection

  # Static set of recently sold artworks for the SWA landing page
  recentlySoldArtworks(
    after: String
    before: String
    first: Int
    last: Int
  ): RecentlySoldArtworkTypeConnection

  # A requested location
  requestLocation(ip: String): RequestLocation

  # A Sale
  sale(
    # The slug or ID of the Sale
    id: String!
  ): Sale
  saleAgreement(id: ID!): SaleAgreement!

  # The conditions of sale for Artsy or an individual sale.
  saleAgreementsConnection(
    after: String
    before: String
    first: Int
    last: Int

    # if present, will return condition of sales with the input status
    status: SaleAgreementStatus
  ): SaleAgreementConnection

  # A Sale Artwork
  saleArtwork(
    # The slug or ID of the SaleArtwork
    id: String!
  ): SaleArtwork

  # Sale Artworks search results
  saleArtworksConnection(
    after: String

    # Please make sure to supply the TOTAL aggregation if you will be setting any aggregations
    aggregations: [SaleArtworkAggregation]
    artistIDs: [String]
    before: String
    biddableSale: Boolean
    estimateRange: String
    excludeClosedLots: Boolean
    first: Int
    geneIDs: [String]

    # When called under the Me field, this defaults to true. Otherwise it defaults to false
    includeArtworksByFollowedArtists: Boolean
    isAuction: Boolean
    last: Int
    liveSale: Boolean
    marketable: Boolean
    page: Int
    saleID: ID

    # Same as saleID argument, but matches the argument type of `sale(id: 'foo')` root field
    saleSlug: String
    size: Int
    sort: String
    userId: String
  ): SaleArtworksConnection

  # A list of Sales
  salesConnection(
    after: String
    auctionState: AuctionState
    before: String
    first: Int

    #
    #         Only return sales matching specified ids.
    #         Accepts list of ids.
    #
    ids: [String]

    # Limit by auction.
    isAuction: Boolean = true
    last: Int

    # Limit by live status.
    live: Boolean = true

    # Limit by published status.
    published: Boolean = true

    # Returns sales the user has registered for if true, returns sales the user has not registered for if false.
    registered: Boolean
    sort: SaleSorts

    # If present, will search by term
    term: String
  ): SaleConnection

  # Global search
  searchConnection(
    after: String
    aggregations: [SearchAggregation]
    before: String

    # Entities to include in search. Default: [ARTIST, ARTWORK].
    entities: [SearchEntity]
    first: Int
    last: Int

    # Mode of search to execute. Default: SITE.
    mode: SearchMode

    # If present, will be used for pagination instead of cursors.
    page: Int

    # Search query to perform. Required.
    query: String!
  ): SearchableConnection
  shortcut(id: ID!): Shortcut

  # A Show
  show(
    # The slug or ID of the Show
    id: String!

    # Include shows that are no longer running/active (defaults to false)
    includeAllShows: Boolean = false
  ): Show

  # A list of Shows
  showsConnection(
    after: String
    atAFair: Boolean
    before: String
    displayable: Boolean = true
    first: Int
    hasLocation: Boolean
    ids: [String]
    last: Int
    sort: ShowSorts
    status: EventStatus

    # If present, will search by term
    term: String
  ): ShowConnection

  # Content for a specific page or view
  staticContent(
    # The slug or id for the view
    id: String
  ): StaticContent

  # Fields related to internal systems.
  system: System
  tag(
    # The slug or ID of the Tag
    id: String!
  ): Tag
  targetSupply: TargetSupply
  user(
    # Email to search for user by
    email: String

    # ID of the user
    id: String
  ): User

  # A list of Users
  usersConnection(
    after: String
    before: String
    first: Int
    ids: [String]
    last: Int

    # If present, will search by term, cannot be combined with `ids`
    term: String
  ): UserConnection

  # A Partner or Fair
  vanityURLEntity(
    # The slug or ID of the Profile to get a partner or fair for
    id: String!
  ): VanityURLEntityType

  # Verify a given address.
  verifyAddress(input: VerifyAddressInput!): VerifyAddressPayload

  # Verify a given user.
  verifyUser(
    # Email address to verify.
    email: String!

    # Recaptcha token.
    recaptchaToken: String!
  ): VerifyUser
  viewingRoomsConnection(
    after: String
    first: Int
    partnerID: ID
    statuses: [ViewingRoomStatusEnum!]
  ): ViewingRoomsConnection
}

# An artwork viewing room
type ViewingRoom {
  artworkIDs: [String!]!
  artworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection

  # Body copy
  body: String
  distanceToClose(short: Boolean! = false): String
  distanceToOpen(short: Boolean! = false): String

  # Datetime after which the viewing room is no longer viewable
  endAt: ISO8601DateTime
  exhibitionPeriod: String

  # Datetime when viewing room first viewable
  firstLiveAt: ISO8601DateTime
  heroImageURL: String @deprecated(reason: "Use image field instead")
  href: String
  image: ARImage

  # Unique ID for this room
  internalID: ID!

  # Introductory paragraph
  introStatement: String
  partner: Partner
  partnerArtworksConnection(after: String, before: String, first: Int, last: Int): ArtworkConnection

  # ID of the partner associated with this viewing room
  partnerID: String!
  published: Boolean!
  pullQuote: String
  slug: String!

  # Datetime when the viewing room is viewable
  startAt: ISO8601DateTime

  # Calculated field to reflect visibility and state of this viewing room
  status: String!
  subsections: [ViewingRoomSubsection!]!
  timeZone: String

  # Viewing room name
  title: String!
  viewingRoomArtworks: [ViewingRoomArtwork!]!
}

# Relationship between a Viewing Room and an Artwork
type ViewingRoomArtwork {
  artworkID: ID!
  internalID: ID!
  published: Boolean!
}

# An input type for a Viewing Room artwork
input ViewingRoomArtworkInput {
  artworkID: ID!
  delete: Boolean = false
  internalID: ID
  position: Int
}

# Basic viewing room attributes
input ViewingRoomAttributes {
  body: String

  # Datetime (in UTC) when Viewing Room closes
  endAt: ISO8601DateTime
  introStatement: String
  pullQuote: String

  # Datetime (in UTC) when Viewing Room opens
  startAt: ISO8601DateTime

  # Time zone (tz database format, e.g. America/New_York) in which start_at/end_at attributes were input
  timeZone: String

  # Title
  title: String
}

# The connection type for ViewingRoom.
type ViewingRoomConnection {
  # A list of edges.
  edges: [ViewingRoomEdge]

  # A list of nodes.
  nodes: [ViewingRoom]

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Total count of matching nodes, before pagination
  totalCount: Int!
}

# An edge in a connection.
type ViewingRoomEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: ViewingRoom
}

# A viewing room or errors object
union ViewingRoomOrErrorsUnion = Errors | ViewingRoom

type ViewingRoomPublishedNotificationItem {
  partner: Partner

  # The IDs of the viewing rooms, for use in stitching
  viewingRoomIDs: [String]
  viewingRoomsConnection(
    after: String
    before: String
    first: Int
    last: Int
  ): ViewingRoomsConnection
}

enum ViewingRoomStatusEnum {
  closed
  draft
  live
  scheduled
}

# Title, image, text, and caption for a viewing room section
type ViewingRoomSubsection {
  # Body copy
  body: String

  # Image caption
  caption: String
  image: ARImage

  # Image URL
  imageURL: String

  # Unique ID for this subsection
  internalID: ID!

  # Section header
  title: String
}

# Attributes for creating or updating a viewing room subsection
input ViewingRoomSubsectionAttributes {
  body: String
  caption: String
  title: String
}

# An input type for the creation of viewing room subsections
input ViewingRoomSubsectionInput {
  attributes: ViewingRoomSubsectionAttributes

  # If true, delete this subsection from the database
  delete: Boolean = false
  image: ARImageInput
  internalID: ID
}

# The connection type for ViewingRoom.
type ViewingRoomsConnection {
  # A list of edges.
  edges: [ViewingRoomsEdge]

  # A list of nodes.
  nodes: [ViewingRoom]
  pageCursors: PageCursors

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int
  totalPages: Int
}

# An edge in a connection.
type ViewingRoomsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: ViewingRoom
}

enum Visibility {
  LISTED
  UNLISTED
}

type WireTransfer {
  isManualPayment: Boolean!
}

type YearRange {
  # The last year of the year range
  endAt: Int

  # The first year of the year range
  startAt: Int
}

type addOrderedSetItemFailure {
  mutationError: GravityMutationError
}

input addOrderedSetItemMutationInput {
  clientMutationId: String
  geminiToken: String
  id: String!
  itemId: String!
  position: Int
}

type addOrderedSetItemMutationPayload {
  # On success: the updated parent set or the set item added.
  addOrderedSetItemResponseOrError: addOrderedSetItemResponseOrError
  clientMutationId: String
}

union addOrderedSetItemResponseOrError = addOrderedSetItemFailure | addOrderedSetItemSuccess

type addOrderedSetItemSuccess {
  set: OrderedSet
  setItem: OrderedSetItem
}

type addUserRoleFailure {
  mutationError: GravityMutationError
}

input addUserRoleMutationInput {
  clientMutationId: String
  id: String!
  role_type: String!
}

type addUserRoleMutationPayload {
  clientMutationId: String

  # On success: the user
  userOrError: addUserRoleResponseOrError
}

union addUserRoleResponseOrError = addUserRoleFailure | addUserRoleSuccess

type addUserRoleSuccess {
  user: User
}

enum addressType {
  BUSINESS
  OTHER
  TEMPORARY
}

input createAlertInput {
  acquireable: Boolean
  additionalGeneIDs: [String]
  artistIDs: [String]!
  artistSeriesIDs: [String]
  atAuction: Boolean
  attributionClass: [String]
  clientMutationId: String
  colors: [String]
  dimensionRange: String
  height: String
  inquireableOnly: Boolean
  keyword: String
  locationCities: [String]
  majorPeriods: [String]
  materialsTerms: [String]
  offerable: Boolean
  partnerIDs: [String]
  priceRange: String
  settings: AlertSettingsInput
  sizes: [String]
  width: String
}

type createAlertPayload {
  clientMutationId: String
  responseOrError: CreateAlertResponseOrError
}

input createCollectionInput {
  clientMutationId: String
  name: String!
  shareableWithPartners: Boolean
}

type createCollectionPayload {
  clientMutationId: String
  responseOrError: CreateCollectionResponseOrError
}

union createFeatureResponseOrError = CreateFeatureFailure | CreateFeatureSuccess

type createHeroUnitFailure {
  mutationError: GravityMutationError
}

union createHeroUnitResponseOrError = createHeroUnitFailure | createHeroUnitSuccess

type createHeroUnitSuccess {
  heroUnit: HeroUnit
}

type createOrderedSetFailure {
  mutationError: GravityMutationError
}

union createOrderedSetResponseOrError = createOrderedSetFailure | createOrderedSetSuccess

type createOrderedSetSuccess {
  set: OrderedSet
}

type createPartnerOfferFailure {
  mutationError: GravityMutationError
}

input createPartnerOfferMutationInput {
  artwork_id: String!
  clientMutationId: String
  discount_percentage: Int!
  note: String
}

type createPartnerOfferMutationPayload {
  clientMutationId: String

  # On success: the partner offer created.
  partnerOfferOrError: createPartnerOfferResponseOrError
}

union createPartnerOfferResponseOrError = createPartnerOfferFailure | createPartnerOfferSuccess

type createPartnerOfferSuccess {
  partner: Partner
  partnerOffer: PartnerOffer
}

type createUserAdminNoteFailure {
  mutationError: GravityMutationError
}

input createUserAdminNoteMutationInput {
  body: String!
  clientMutationId: String
  id: String!
}

type createUserAdminNoteMutationPayload {
  # On success: the admin note created.
  adminNoteOrError: createUserAdminNoteResponseOrError
  clientMutationId: String
}

union createUserAdminNoteResponseOrError = createUserAdminNoteFailure | createUserAdminNoteSuccess

type createUserAdminNoteSuccess {
  adminNote: UserAdminNotes
}

type createUserInterestForUserFailure {
  mutationError: GravityMutationError
}

union createUserInterestForUserResponseOrError =
    createUserInterestForUserFailure
  | createUserInterestForUserSuccess

type createUserInterestForUserSuccess {
  user: User
  userInterest: UserInterest
}

input deleteAlertInput {
  clientMutationId: String
  id: String!
}

type deleteAlertPayload {
  clientMutationId: String
  responseOrError: DeleteAlertResponseOrError
}

input deleteCollectionInput {
  clientMutationId: String
  id: String!
}

type deleteCollectionPayload {
  clientMutationId: String

  # On success: the deleted collection
  responseOrError: DeleteCollectionResponseOrError
}

type deleteHeroUnitFailure {
  mutationError: GravityMutationError
}

input deleteHeroUnitMutationInput {
  clientMutationId: String
  id: String!
}

type deleteHeroUnitMutationPayload {
  clientMutationId: String

  # On success: the deleted hero unit.
  heroUnitOrError: deleteHeroUnitResponseOrError
}

union deleteHeroUnitResponseOrError = deleteHeroUnitFailure | deleteHeroUnitSuccess

type deleteHeroUnitSuccess {
  heroUnit: HeroUnit
}

type deleteOrderedSetFailure {
  mutationError: GravityMutationError
}

type deleteOrderedSetItemFailure {
  mutationError: GravityMutationError
}

input deleteOrderedSetItemMutationInput {
  clientMutationId: String
  id: String!
  itemId: String!
}

type deleteOrderedSetItemMutationPayload {
  clientMutationId: String

  # On success: the updated parent set or the set item deleted.
  deleteOrderedSetItemResponseOrError: deleteOrderedSetItemResponseOrError
}

union deleteOrderedSetItemResponseOrError =
    deleteOrderedSetItemFailure
  | deleteOrderedSetItemSuccess

type deleteOrderedSetItemSuccess {
  set: OrderedSet
  setItem: OrderedSetItem
}

input deleteOrderedSetMutationInput {
  clientMutationId: String
  id: String!
}

type deleteOrderedSetMutationPayload {
  clientMutationId: String

  # On success: the deleted ordered set.
  orderedSetOrError: deleteOrderedSetResponseOrError
}

union deleteOrderedSetResponseOrError = deleteOrderedSetFailure | deleteOrderedSetSuccess

type deleteOrderedSetSuccess {
  set: OrderedSet
}

type deleteUserAdminNoteFailure {
  mutationError: GravityMutationError
}

input deleteUserAdminNoteMutationInput {
  adminNoteId: String!
  clientMutationId: String
  id: String!
}

type deleteUserAdminNoteMutationPayload {
  # On success: the admin note deleted.
  adminNoteOrError: deleteUserAdminNoteResponseOrError
  clientMutationId: String
}

union deleteUserAdminNoteResponseOrError = deleteUserAdminNoteFailure | deleteUserAdminNoteSuccess

type deleteUserAdminNoteSuccess {
  adminNote: UserAdminNotes
}

type deleteUserInterestForUserFailure {
  mutationError: GravityMutationError
}

union deleteUserInterestForUserResponseOrError =
    deleteUserInterestForUserFailure
  | deleteUserInterestForUserSuccess

type deleteUserInterestForUserSuccess {
  user: User
  userInterest: UserInterest
}

type deleteUserRoleFailure {
  mutationError: GravityMutationError
}

input deleteUserRoleMutationInput {
  clientMutationId: String
  id: String!
  role_type: String!
}

type deleteUserRoleMutationPayload {
  clientMutationId: String

  # On success: the user.
  userOrError: deleteUserRoleResponseOrError
}

union deleteUserRoleResponseOrError = deleteUserRoleFailure | deleteUserRoleSuccess

type deleteUserRoleSuccess {
  user: User
}

type dimensions {
  cm: String
  in: String
}

type partnerBiographyBlurb {
  text: String
}

type purchases {
  # Total number of auction winning bids
  totalAuctionCount: Int!

  # Total number of private sales
  totalPrivateSaleCount: Int!
}

enum sort {
  ASC
  DESC
}

input startIdentityVerificationMutationInput {
  clientMutationId: String

  # Primary ID of the identity verification to be started
  identityVerificationId: String!
}

type startIdentityVerificationMutationPayload {
  clientMutationId: String
  startIdentityVerificationResponseOrError: StartIdentityVerificationResponseOrError
}

input updateAlertInput {
  acquireable: Boolean
  additionalGeneIDs: [String]
  artistIDs: [String]
  artistSeriesIDs: [String]
  atAuction: Boolean
  attributionClass: [String]
  clientMutationId: String
  colors: [String]
  dimensionRange: String
  height: String
  id: String!
  inquireableOnly: Boolean
  keyword: String
  locationCities: [String]
  majorPeriods: [String]
  materialsTerms: [String]
  offerable: Boolean
  partnerIDs: [String]
  priceRange: String
  settings: AlertSettingsInput
  sizes: [String]
  width: String
}

type updateAlertPayload {
  clientMutationId: String
  responseOrError: UpdateAlertResponseOrError
}

type updateArtworkFailure {
  mutationError: GravityMutationError
}

union updateArtworkResponseOrError = updateArtworkFailure | updateArtworkSuccess

type updateArtworkSuccess {
  artwork: Artwork
}

input updateCollectionInput {
  clientMutationId: String

  # The internal ID of the collection
  id: String!
  name: String!
  shareableWithPartners: Boolean
}

type updateCollectionPayload {
  clientMutationId: String
  responseOrError: UpdateCollectionResponseOrError
}

union updateCollectorProfileResponseOrError =
    UpdateCollectorProfileFailure
  | UpdateCollectorProfileSuccess

type updateHeroUnitFailure {
  mutationError: GravityMutationError
}

union updateHeroUnitResponseOrError = updateHeroUnitFailure | updateHeroUnitSuccess

type updateHeroUnitSuccess {
  heroUnit: HeroUnit
}

input updateMeCollectionsMutationInput {
  attributes: [UpdateMeCollectionInput!]!
  clientMutationId: String
}

type updateMeCollectionsMutationPayload {
  clientMutationId: String
  meCollectionsOrErrors: [UpdateMeCollectionsResponseOrError!]!
}

input updateNotificationPreferencesMutationInput {
  authenticationToken: String
  clientMutationId: String
  subscriptionGroups: [NotificationPreferenceInput!]!
}

type updateNotificationPreferencesMutationPayload {
  clientMutationId: String

  # User's notification preferences
  notificationPreferences(authenticationToken: String): [NotificationPreference!]!
}

input updateQuizMutationInput {
  artworkId: String!
  clearInteraction: Boolean
  clientMutationId: String
  userId: String!
}

type updateQuizMutationPayload {
  clientMutationId: String
  quiz: Quiz
}
